Lock the database environment when updating a dataSet
=====================================================

Problem
=======
The problem is best illustrated using the following example:

At t=0 I have a dataset with one triple ex:1 ex:name "Jan Jansen".
At t=1 I call generateLog with some code that will generate the mutations: - ex:1 ex:name "Jan Jansen" and + ex:1 ex:name "Jan Pieterson" i.e. change the name from Jansen to Pieterson. Even though I called generateLog at t=1, due to the timbuctoo process being busy the triples will not be inserted into berkeley db until t=3
But in the meantime (at t=2) I call generateLogs with some code that retracts alle ex:name triples in the dataset. Since it executes immediately (unserialized) it will generate the mutation - ex:1 ex:name "Jan Jansen" This mutation will not be applied until t>3 though. because it's appended to the log.
at t=3 the first mutation is applied the dataset now contains 1 triple ex:1 ex:name "Jan Pieterson"
at t=4 the second mutation is applied. because ex:1 ex:name "Jan Jansen" is not in the dataset. This mutation has no visible effect and the dataset still contains the one triple: ex:1 ex:name "Jan Pieterson"
However, if the mutations would have executed in order, the dataset would have been empty!

The problem is further complicated in that the UoW is handled in spawn-of threads that are, or could be, left to their own. So the regular mechanism of
- acquire a common lock
- try process the UoW (in this thread or another)
- wait for the UoW fully processed
- finally release the lock
is not going to work, because we do not (always) wait and the lock would be released to soon.

Intended result
===============
Processing mutations as described above may include quadstore reading and writing and in between the store should not be altered. We can consider a complete mutation as a Unit of Work (UoW). UoWs should be serialized, i.e. done as a whole and executed one after the other. We can distinguish UoW's in methods of classes that handle API calls. We only consider cases where the store will be mutated. Dirty reads can still take place.

Approach
========
A quick scan of the call hierarchy of BdbTripleStore.putQuad (as an indication) reveals that calls to this method stem from ImportManager.processLogsUntil and from classes in the package bulkupload. The readme in the last mentioned package says
  || todo:bug["The data entered like this is not yet part of the changelog, but should be."]" ||
So we assume that synchronizing calls to ImportManager.processLogsUntil and taking care that a UoW is processed as one unit will solve the problem. As an example where a UoW is defined we take JsonLdEditEndpoint.

Changes in ImportManager
------------------------
- We introduce a lock mechanism on ImportStatus. The 3 public methods in ImportManager that call the private processLogsUntil acquire this lock. These 3 methods are addLog, generateLog and processLog.
- We change the method signature of generateLog. Instead of taking an RdfCreator it will take a Supplier<RdfCreator>. Instantiating the RdfCreator fromCurrentState (which will read the store) is now taking place in a block that is synchronized on the lock in ImortStatus.

Introduction of LambdaOriginatedException
-----------------------------------------
The instantiation of RdfCreator, which is now taking place in a lambda in ImportManager.generateLog, throws checked Exceptions. Supplier.get() is not allowed to throw CE's, furthermore the CE's cannot traverse the lambda boundaries. Above all, ImportManager should not be bothered with exceptions it is not supposed to handle. So we wrap them in a LambdaOriginatedException, which is a RuntimeException.

By degrading checked exceptions to RuntimeExceptions we somehow obscure 'normal' program flow. Can we create an Annotation that says: this method handles LambdaOriginatedException?
See also: ImportManagerTest.lambdaOriginatedExceptionsAreCaught

Alternatives for LambdaOriginatedException
------------------------------------------
Alternatively we could sneakily throw CE's from lambda bodies and catch them as regular CE outside the lambda body by introducing two methods in LambdaExceptionUtil:

  @SuppressWarnings("unchecked")
  public static <E extends Exception> void sneakyThrow(Exception e) throws E {
    throw (E) e;
  }

  public static <E extends Exception> E expectSneaky(Exception e) throws E {
    return null;
  }

The first method will take the CE under the radar of the Java compiler, the second will put the CE back on the radar so we can catch it. But in the case at hand the IOException is prematurely caught in the try catch of generateLogs and rethrown as a LogStorageFailedException, effectively bypassing the catch in JsonLdEditEndpoint.

Alternatively we could do away with exceptions as a way for starting alternative routes through code. Most exceptions cannot be handled anyway and can only be reported in the log, reported to the end user or both. The ImportStatus is a candidate for carrying messages of failure across. Code should be adapted for handling cases where 'normal' or success program flow is interrupted. Consequence of the latter is extensive rewriting of code to the extend of a paradigm change.

Changes in JsonLdEditEndpoint
-----------------------------
In stead of creating and using the RdfCreator asynchronously the construction of RdfCreator (fromCurrentState) is now done by a Supplier, effectively placing the reading of current state of the store in the same UoW in which the writing is done. Exceptions in construction of the RdfCreator travel by means of the LambdaOriginatedException.cause to the lastError of importStatus. The special case where a ConcurrentUpdateException is causing mishap is reported to the user as Status.CONFLICT by the translateStatusError function.

Changes in ImportStatus
-----------------------
The start of an import cycle is now by means of method lock, which may block until ImportStatus lock has been released.

The status after import cycle has been completed is reflected in ImportStatusReport, which is given to the API calls. ImportStatus itself can still be queried for all intermediate states.

Changes in ErrorResponseHandler
-------------------------------
New method:
  handleImportManagerResult(Future<ImportStatus> promise, Function<ImportStatus, Response.Status> errorStatusTranslator)

Changes in IntegrationTest
--------------------------
New method:
  checkJsonLdDeserializationWithIntentionallyWrongJson()

Changes in ImportManagerTest
----------------------------
New method:
  lambdaOriginatedExceptionsAreCaught




