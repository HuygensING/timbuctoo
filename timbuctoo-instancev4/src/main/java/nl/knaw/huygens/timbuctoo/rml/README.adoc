= RML implementation

The code in this package to implements the http://rml.io[rml specification].
It does not implement any of the datasources itself, but allows you to provide your own implementations.

== Context

In timbuctoo we import data in tabular form as a "raw import" and then use a http://github.com/huygensING/timbuctoo-default-frontend[GUI] to generate an RML mapping that converts it into RDF.
We then import the RDF using our generic RDF importer.

 * This allows us to import many different data formats.
 * It decouples the GUI from the importer which has allowed us to import data that the GUI does not support without having to make the GUI more complex (we can bypass it if needed).
 * It makes our mapping software usable for people who do not use the full timbuctoo stack (by generating basic RDF).

== Usage

```java
  //First you should generate a Jena Model of the data somehow
  
  //Dependencies:
  //The thing that can construct an RmlMappingDocument from a jena model
  final rmlBuilder = new JenaBasedReader();

  //The thing that constructs dataSource instances as needed.
  //This factory should use the contents of the rdfResource to determine what dataSource to create
  Function<RdfResource, Optional<DataSource>> dataSourceFactory = rdfResource -> Optional.of(new MyDataSource(rdfResource));
  
  //The thing that responds to errors that can occur in valid RML mappings, such as missing values.
  ErrorHandler errorHandler = new ErrorHandler() {
    @Override
    public void linkError(Map<String, Object> rowData, String childField, String parentCollection, String parentField) {
      throw new RuntimeException("Linking failed!");
    }
  };
  
  //create the mappingDocument instance
  final RmlMappingDocument rmlMappingDocument = rmlBuilder.fromRdf(model, dataSourceFactory);

  //You can see how it's interpreted using toString()

  if (rmlMappingDocument.getErrors().size() == 0) { //check for errors that make the RML mapping invalid
    //execute the mapping
    rmlMappingDocument.execute(errorHandler).forEach((triple) -> {
      System.out.println(triple);
    });
  }
```

Implementing a minimal DataSource with shipped JoinHandler::

```java
 class MyDataSource implements DataSource {
   // This wil handle references from one table to another
   private final JoinHandler joinHandler = new HashMapBasedJoinHandler();
   private final MyData myData;

   public MyDataSource(RdfResource rdfResource) {
     this.myData = new MyData(rdfResource); // somehow derive the correct data rows for this rdfResource
   }

   @Override
   public Iterator<Row> getRows(ErrorHandler errorHandler) {
     return myData
       .turnIntoStream()
       .map(values -> {
         // values in Map should look like this:
         // { "columnName": "cellValue", ... }
         Map<String, Object> valueMap = transFormValuesOfThisDataRowToValueMap(values);

         // This will handle the reference from one data source to another
         joinHandler.resolveReferences(valueMap);

         return new Row(valueMap, errorHandler);
       })
       .iterator();
   }

   @Override
   public void willBeJoinedOn(String fieldName, Object referenceJoinValue, String uri, String outputFieldName) {
    // This will handle the reference from one data source to another
     joinHandler.willBeJoinedOn(fieldName, referenceJoinValue, uri, outputFieldName);
   }
 }
```

More information on how a JoinHandler can be implemented is documented in the source of link: ./datasource/joinhandlers/HashMapBasedJoinHandler.java[HashMapBasedJoinHandler].

== Code layout
The package contains the following folders:

link:./rmldata[/rmldata]::
  Contains the java representation of the RML rdf classes.
  The java classes form a tree rooted in RmlMappingDocument.
  They usually have a method that generates data (i.e. `execute()` or `getItems()`) and a toString() method that recursively prints the tree.
  You will normally only interact with the outermost RmlMappingDocument class which calls the other classes recursively.
link:./rmldata/builders[/rmldata/builders]::
  RML contains a bunch of shorthands and the builders contain the logic needed to interpret the RML in context so that the built instances no longer need this context.
  For example: you can omit the termType in the source mapping document. 
  The `TermMapBuilder` will decide what the termType should be and the resulting `RrTermMap` will simply have a property TermType set to the correct value.
link:./jena[/jena]::
link:./rdfshim[/rdfshim]::
  The library depends on jena at this moment, but we've invested some effort to make this a minimal dependency. 
  It should be possible to extract the jena package to a separate package that depends on this library while the library is jena agnostic.
link:./datasource[/datasource]::
  The library ships with a JoinHandler interface which can be used by the datasource to handle joins and one sample implementation backed by a HashMap.

== Handling of circular and self-referencing data sources (let's call them tables)
In order for this library to support big datasets without the leverage SQL based databases provide data rows are expected to be streamed.

References without a cycle::

When exactly one table references exactly one other table this is simply resolved by first mapping the rows of the table that is referred to and then the table that refers to it.
```
sample here

solution here
```

Self reference::
The solution above does not solve the issue of a table in which one column references another column in the same table.
In this case a new mapper is generated (split off) from the original mapper, so that two passes are made through the same datasource.
The first pass maps all the values that are not a reference.
The second pass maps all the values that are a reference to another column.

```
sample here

solution here
```

Cyclic references::
In cases where table A references table B and table B references table A there is a circular depency as well.
The same solutions as above apply here: first sort by dependency, then split off any unresolved dependencies.
This even works for more complex cases with multiple cycles.
The full implementation of sort and split is here: link:./rml/rmldata/builders/MappingDocumentBuilder.java[/rml/rmldata/builders/MappingDocumentBuilder.java].

```
sample here

solution here
```

== Known issues

Mapping columns::
You cannot transform a column in RML.
The R2RML languages gives you the ability to use an arbitrary SQL query as a datasource which allows for most of the conversions in SQL.
RML does not have this support.
This is especially annoying for implementing manytomany links and when you want to derive the name of the predicate.
+
We might implement an extension that allows for referencingMaps in subjectMaps and predicateMaps and an extension that allows you to transform the inputline to aleviate some of this pain.
