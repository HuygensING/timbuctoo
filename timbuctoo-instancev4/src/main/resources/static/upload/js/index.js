(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ExcelImportMock = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],3:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":4,"./lib/keys.js":5}],4:[function(require,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],5:[function(require,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}],6:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":27}],7:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],8:[function(require,module,exports){
/**
 * Indicates that navigation was caused by a call to history.push.
 */
'use strict';

exports.__esModule = true;
var PUSH = 'PUSH';

exports.PUSH = PUSH;
/**
 * Indicates that navigation was caused by a call to history.replace.
 */
var REPLACE = 'REPLACE';

exports.REPLACE = REPLACE;
/**
 * Indicates that navigation was caused by some other action such
 * as using a browser's back/forward buttons and/or manually manipulating
 * the URL in a browser's location bar. This is the default.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
 * for more information.
 */
var POP = 'POP';

exports.POP = POP;
exports['default'] = {
  PUSH: PUSH,
  REPLACE: REPLACE,
  POP: POP
};
},{}],9:[function(require,module,exports){
"use strict";

exports.__esModule = true;
var _slice = Array.prototype.slice;
exports.loopAsync = loopAsync;

function loopAsync(turns, work, callback) {
  var currentTurn = 0,
      isDone = false;
  var sync = false,
      hasNext = false,
      doneArgs = undefined;

  function done() {
    isDone = true;
    if (sync) {
      // Iterate instead of recursing if possible.
      doneArgs = [].concat(_slice.call(arguments));
      return;
    }

    callback.apply(this, arguments);
  }

  function next() {
    if (isDone) {
      return;
    }

    hasNext = true;
    if (sync) {
      // Iterate instead of recursing if possible.
      return;
    }

    sync = true;

    while (!isDone && currentTurn < turns && hasNext) {
      hasNext = false;
      work.call(this, currentTurn++, next, done);
    }

    sync = false;

    if (isDone) {
      // This means the loop finished synchronously.
      callback.apply(this, doneArgs);
      return;
    }

    if (currentTurn >= turns && hasNext) {
      isDone = true;
      callback();
    }
  }

  next();
}
},{}],10:[function(require,module,exports){
(function (process){
/*eslint-disable no-empty */
'use strict';

exports.__esModule = true;
exports.saveState = saveState;
exports.readState = readState;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var KeyPrefix = '@@History/';
var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];

var SecurityError = 'SecurityError';

function createKey(key) {
  return KeyPrefix + key;
}

function saveState(key, state) {
  try {
    if (state == null) {
      window.sessionStorage.removeItem(createKey(key));
    } else {
      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
    }
  } catch (error) {
    if (error.name === SecurityError) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;

      return;
    }

    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
      // Safari "private mode" throws QuotaExceededError.
      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;

      return;
    }

    throw error;
  }
}

function readState(key) {
  var json = undefined;
  try {
    json = window.sessionStorage.getItem(createKey(key));
  } catch (error) {
    if (error.name === SecurityError) {
      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
      // attempt to access window.sessionStorage.
      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;

      return null;
    }
  }

  if (json) {
    try {
      return JSON.parse(json);
    } catch (error) {
      // Ignore invalid JSON.
    }
  }

  return null;
}
}).call(this,require('_process'))

},{"_process":1,"warning":24}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.addEventListener = addEventListener;
exports.removeEventListener = removeEventListener;
exports.getHashPath = getHashPath;
exports.replaceHashPath = replaceHashPath;
exports.getWindowPath = getWindowPath;
exports.go = go;
exports.getUserConfirmation = getUserConfirmation;
exports.supportsHistory = supportsHistory;
exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;

function addEventListener(node, event, listener) {
  if (node.addEventListener) {
    node.addEventListener(event, listener, false);
  } else {
    node.attachEvent('on' + event, listener);
  }
}

function removeEventListener(node, event, listener) {
  if (node.removeEventListener) {
    node.removeEventListener(event, listener, false);
  } else {
    node.detachEvent('on' + event, listener);
  }
}

function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  return window.location.href.split('#')[1] || '';
}

function replaceHashPath(path) {
  window.location.replace(window.location.pathname + window.location.search + '#' + path);
}

function getWindowPath() {
  return window.location.pathname + window.location.search + window.location.hash;
}

function go(n) {
  if (n) window.history.go(n);
}

function getUserConfirmation(message, callback) {
  callback(window.confirm(message));
}

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
 */

function supportsHistory() {
  var ua = navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }
  return window.history && 'pushState' in window.history;
}

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */

function supportsGoWithoutReloadUsingHash() {
  var ua = navigator.userAgent;
  return ua.indexOf('Firefox') === -1;
}
},{}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
exports.canUseDOM = canUseDOM;
},{}],13:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;
exports.extractPath = extractPath;
exports.parsePath = parsePath;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function extractPath(string) {
  var match = string.match(/^https?:\/\/[^\/]*/);

  if (match == null) return string;

  return string.substring(match[0].length);
}

function parsePath(path) {
  var pathname = extractPath(path);
  var search = '';
  var hash = '';

  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substring(hashIndex);
    pathname = pathname.substring(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substring(searchIndex);
    pathname = pathname.substring(0, searchIndex);
  }

  if (pathname === '') pathname = '/';

  return {
    pathname: pathname,
    search: search,
    hash: hash
  };
}
}).call(this,require('_process'))

},{"_process":1,"warning":24}],14:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _Actions = require('./Actions');

var _PathUtils = require('./PathUtils');

var _ExecutionEnvironment = require('./ExecutionEnvironment');

var _DOMUtils = require('./DOMUtils');

var _DOMStateStorage = require('./DOMStateStorage');

var _createDOMHistory = require('./createDOMHistory');

var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);

/**
 * Creates and returns a history object that uses HTML5's history API
 * (pushState, replaceState, and the popstate event) to manage history.
 * This is the recommended method of managing history in browsers because
 * it provides the cleanest URLs.
 *
 * Note: In browsers that do not support the HTML5 history API full
 * page reloads will be used to preserve URLs.
 */
function createBrowserHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;

  var forceRefresh = options.forceRefresh;

  var isSupported = _DOMUtils.supportsHistory();
  var useRefresh = !isSupported || forceRefresh;

  function getCurrentLocation(historyState) {
    try {
      historyState = historyState || window.history.state || {};
    } catch (e) {
      historyState = {};
    }

    var path = _DOMUtils.getWindowPath();
    var _historyState = historyState;
    var key = _historyState.key;

    var state = undefined;
    if (key) {
      state = _DOMStateStorage.readState(key);
    } else {
      state = null;
      key = history.createKey();

      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
    }

    var location = _PathUtils.parsePath(path);

    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
  }

  function startPopStateListener(_ref) {
    var transitionTo = _ref.transitionTo;

    function popStateListener(event) {
      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.

      transitionTo(getCurrentLocation(event.state));
    }

    _DOMUtils.addEventListener(window, 'popstate', popStateListener);

    return function () {
      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
    };
  }

  function finishTransition(location) {
    var basename = location.basename;
    var pathname = location.pathname;
    var search = location.search;
    var hash = location.hash;
    var state = location.state;
    var action = location.action;
    var key = location.key;

    if (action === _Actions.POP) return; // Nothing to do.

    _DOMStateStorage.saveState(key, state);

    var path = (basename || '') + pathname + search + hash;
    var historyState = {
      key: key
    };

    if (action === _Actions.PUSH) {
      if (useRefresh) {
        window.location.href = path;
        return false; // Prevent location update.
      } else {
          window.history.pushState(historyState, null, path);
        }
    } else {
      // REPLACE
      if (useRefresh) {
        window.location.replace(path);
        return false; // Prevent location update.
      } else {
          window.history.replaceState(historyState, null, path);
        }
    }
  }

  var history = _createDOMHistory2['default'](_extends({}, options, {
    getCurrentLocation: getCurrentLocation,
    finishTransition: finishTransition,
    saveState: _DOMStateStorage.saveState
  }));

  var listenerCount = 0,
      stopPopStateListener = undefined;

  function listenBefore(listener) {
    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);

    var unlisten = history.listenBefore(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopPopStateListener();
    };
  }

  function listen(listener) {
    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);

    var unlisten = history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopPopStateListener();
    };
  }

  // deprecated
  function registerTransitionHook(hook) {
    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);

    history.registerTransitionHook(hook);
  }

  // deprecated
  function unregisterTransitionHook(hook) {
    history.unregisterTransitionHook(hook);

    if (--listenerCount === 0) stopPopStateListener();
  }

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen,
    registerTransitionHook: registerTransitionHook,
    unregisterTransitionHook: unregisterTransitionHook
  });
}

exports['default'] = createBrowserHistory;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"./Actions":8,"./DOMStateStorage":10,"./DOMUtils":11,"./ExecutionEnvironment":12,"./PathUtils":13,"./createDOMHistory":15,"_process":1,"invariant":26}],15:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _ExecutionEnvironment = require('./ExecutionEnvironment');

var _DOMUtils = require('./DOMUtils');

var _createHistory = require('./createHistory');

var _createHistory2 = _interopRequireDefault(_createHistory);

function createDOMHistory(options) {
  var history = _createHistory2['default'](_extends({
    getUserConfirmation: _DOMUtils.getUserConfirmation
  }, options, {
    go: _DOMUtils.go
  }));

  function listen(listener) {
    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;

    return history.listen(listener);
  }

  return _extends({}, history, {
    listen: listen
  });
}

exports['default'] = createDOMHistory;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"./DOMUtils":11,"./ExecutionEnvironment":12,"./createHistory":17,"_process":1,"invariant":26}],16:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _Actions = require('./Actions');

var _PathUtils = require('./PathUtils');

var _ExecutionEnvironment = require('./ExecutionEnvironment');

var _DOMUtils = require('./DOMUtils');

var _DOMStateStorage = require('./DOMStateStorage');

var _createDOMHistory = require('./createDOMHistory');

var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);

function isAbsolutePath(path) {
  return typeof path === 'string' && path.charAt(0) === '/';
}

function ensureSlash() {
  var path = _DOMUtils.getHashPath();

  if (isAbsolutePath(path)) return true;

  _DOMUtils.replaceHashPath('/' + path);

  return false;
}

function addQueryStringValueToPath(path, key, value) {
  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
}

function stripQueryStringValueFromPath(path, key) {
  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
}

function getQueryStringValueFromPath(path, key) {
  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
  return match && match[1];
}

var DefaultQueryKey = '_k';

function createHashHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;

  var queryKey = options.queryKey;

  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;

  function getCurrentLocation() {
    var path = _DOMUtils.getHashPath();

    var key = undefined,
        state = undefined;
    if (queryKey) {
      key = getQueryStringValueFromPath(path, queryKey);
      path = stripQueryStringValueFromPath(path, queryKey);

      if (key) {
        state = _DOMStateStorage.readState(key);
      } else {
        state = null;
        key = history.createKey();
        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
      }
    } else {
      key = state = null;
    }

    var location = _PathUtils.parsePath(path);

    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
  }

  function startHashChangeListener(_ref) {
    var transitionTo = _ref.transitionTo;

    function hashChangeListener() {
      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.

      transitionTo(getCurrentLocation());
    }

    ensureSlash();
    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);

    return function () {
      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
    };
  }

  function finishTransition(location) {
    var basename = location.basename;
    var pathname = location.pathname;
    var search = location.search;
    var state = location.state;
    var action = location.action;
    var key = location.key;

    if (action === _Actions.POP) return; // Nothing to do.

    var path = (basename || '') + pathname + search;

    if (queryKey) {
      path = addQueryStringValueToPath(path, queryKey, key);
      _DOMStateStorage.saveState(key, state);
    } else {
      // Drop key and state.
      location.key = location.state = null;
    }

    var currentHash = _DOMUtils.getHashPath();

    if (action === _Actions.PUSH) {
      if (currentHash !== path) {
        window.location.hash = path;
      } else {
        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
      }
    } else if (currentHash !== path) {
      // REPLACE
      _DOMUtils.replaceHashPath(path);
    }
  }

  var history = _createDOMHistory2['default'](_extends({}, options, {
    getCurrentLocation: getCurrentLocation,
    finishTransition: finishTransition,
    saveState: _DOMStateStorage.saveState
  }));

  var listenerCount = 0,
      stopHashChangeListener = undefined;

  function listenBefore(listener) {
    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);

    var unlisten = history.listenBefore(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopHashChangeListener();
    };
  }

  function listen(listener) {
    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);

    var unlisten = history.listen(listener);

    return function () {
      unlisten();

      if (--listenerCount === 0) stopHashChangeListener();
    };
  }

  function push(location) {
    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;

    history.push(location);
  }

  function replace(location) {
    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;

    history.replace(location);
  }

  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();

  function go(n) {
    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;

    history.go(n);
  }

  function createHref(path) {
    return '#' + history.createHref(path);
  }

  // deprecated
  function registerTransitionHook(hook) {
    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);

    history.registerTransitionHook(hook);
  }

  // deprecated
  function unregisterTransitionHook(hook) {
    history.unregisterTransitionHook(hook);

    if (--listenerCount === 0) stopHashChangeListener();
  }

  // deprecated
  function pushState(state, path) {
    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;

    history.pushState(state, path);
  }

  // deprecated
  function replaceState(state, path) {
    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;

    history.replaceState(state, path);
  }

  return _extends({}, history, {
    listenBefore: listenBefore,
    listen: listen,
    push: push,
    replace: replace,
    go: go,
    createHref: createHref,

    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
    pushState: pushState, // deprecated - warning is in createHistory
    replaceState: replaceState // deprecated - warning is in createHistory
  });
}

exports['default'] = createHashHistory;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"./Actions":8,"./DOMStateStorage":10,"./DOMUtils":11,"./ExecutionEnvironment":12,"./PathUtils":13,"./createDOMHistory":15,"_process":1,"invariant":26,"warning":24}],17:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _PathUtils = require('./PathUtils');

var _AsyncUtils = require('./AsyncUtils');

var _Actions = require('./Actions');

var _createLocation2 = require('./createLocation');

var _createLocation3 = _interopRequireDefault(_createLocation2);

var _runTransitionHook = require('./runTransitionHook');

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _deprecate = require('./deprecate');

var _deprecate2 = _interopRequireDefault(_deprecate);

function createRandomKey(length) {
  return Math.random().toString(36).substr(2, length);
}

function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search &&
  //a.action === b.action && // Different action !== location change.
  a.key === b.key && _deepEqual2['default'](a.state, b.state);
}

var DefaultKeyLength = 6;

function createHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var getCurrentLocation = options.getCurrentLocation;
  var finishTransition = options.finishTransition;
  var saveState = options.saveState;
  var go = options.go;
  var getUserConfirmation = options.getUserConfirmation;
  var keyLength = options.keyLength;

  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;

  var transitionHooks = [];

  function listenBefore(hook) {
    transitionHooks.push(hook);

    return function () {
      transitionHooks = transitionHooks.filter(function (item) {
        return item !== hook;
      });
    };
  }

  var allKeys = [];
  var changeListeners = [];
  var location = undefined;

  function getCurrent() {
    if (pendingLocation && pendingLocation.action === _Actions.POP) {
      return allKeys.indexOf(pendingLocation.key);
    } else if (location) {
      return allKeys.indexOf(location.key);
    } else {
      return -1;
    }
  }

  function updateLocation(newLocation) {
    var current = getCurrent();

    location = newLocation;

    if (location.action === _Actions.PUSH) {
      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
    } else if (location.action === _Actions.REPLACE) {
      allKeys[current] = location.key;
    }

    changeListeners.forEach(function (listener) {
      listener(location);
    });
  }

  function listen(listener) {
    changeListeners.push(listener);

    if (location) {
      listener(location);
    } else {
      var _location = getCurrentLocation();
      allKeys = [_location.key];
      updateLocation(_location);
    }

    return function () {
      changeListeners = changeListeners.filter(function (item) {
        return item !== listener;
      });
    };
  }

  function confirmTransitionTo(location, callback) {
    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
        if (result != null) {
          done(result);
        } else {
          next();
        }
      });
    }, function (message) {
      if (getUserConfirmation && typeof message === 'string') {
        getUserConfirmation(message, function (ok) {
          callback(ok !== false);
        });
      } else {
        callback(message !== false);
      }
    });
  }

  var pendingLocation = undefined;

  function transitionTo(nextLocation) {
    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.

    pendingLocation = nextLocation;

    confirmTransitionTo(nextLocation, function (ok) {
      if (pendingLocation !== nextLocation) return; // Transition was interrupted.

      if (ok) {
        // treat PUSH to current path like REPLACE to be consistent with browsers
        if (nextLocation.action === _Actions.PUSH) {
          var prevPath = createPath(location);
          var nextPath = createPath(nextLocation);

          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
        }

        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
      } else if (location && nextLocation.action === _Actions.POP) {
        var prevIndex = allKeys.indexOf(location.key);
        var nextIndex = allKeys.indexOf(nextLocation.key);

        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
      }
    });
  }

  function push(location) {
    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
  }

  function replace(location) {
    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  function createKey() {
    return createRandomKey(keyLength);
  }

  function createPath(location) {
    if (location == null || typeof location === 'string') return location;

    var pathname = location.pathname;
    var search = location.search;
    var hash = location.hash;

    var result = pathname;

    if (search) result += search;

    if (hash) result += hash;

    return result;
  }

  function createHref(location) {
    return createPath(location);
  }

  function createLocation(location, action) {
    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];

    if (typeof action === 'object') {
      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;

      if (typeof location === 'string') location = _PathUtils.parsePath(location);

      location = _extends({}, location, { state: action });

      action = key;
      key = arguments[3] || createKey();
    }

    return _createLocation3['default'](location, action, key);
  }

  // deprecated
  function setState(state) {
    if (location) {
      updateLocationState(location, state);
      updateLocation(location);
    } else {
      updateLocationState(getCurrentLocation(), state);
    }
  }

  function updateLocationState(location, state) {
    location.state = _extends({}, location.state, state);
    saveState(location.key, location.state);
  }

  // deprecated
  function registerTransitionHook(hook) {
    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
  }

  // deprecated
  function unregisterTransitionHook(hook) {
    transitionHooks = transitionHooks.filter(function (item) {
      return item !== hook;
    });
  }

  // deprecated
  function pushState(state, path) {
    if (typeof path === 'string') path = _PathUtils.parsePath(path);

    push(_extends({ state: state }, path));
  }

  // deprecated
  function replaceState(state, path) {
    if (typeof path === 'string') path = _PathUtils.parsePath(path);

    replace(_extends({ state: state }, path));
  }

  return {
    listenBefore: listenBefore,
    listen: listen,
    transitionTo: transitionTo,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    createKey: createKey,
    createPath: createPath,
    createHref: createHref,
    createLocation: createLocation,

    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
  };
}

exports['default'] = createHistory;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"./Actions":8,"./AsyncUtils":9,"./PathUtils":13,"./createLocation":18,"./deprecate":20,"./runTransitionHook":21,"_process":1,"deep-equal":3,"warning":24}],18:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _Actions = require('./Actions');

var _PathUtils = require('./PathUtils');

function createLocation() {
  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

  if (typeof location === 'string') location = _PathUtils.parsePath(location);

  if (typeof action === 'object') {
    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;

    location = _extends({}, location, { state: action });

    action = key || _Actions.POP;
    key = _fourthArg;
  }

  var pathname = location.pathname || '/';
  var search = location.search || '';
  var hash = location.hash || '';
  var state = location.state || null;

  return {
    pathname: pathname,
    search: search,
    hash: hash,
    state: state,
    action: action,
    key: key
  };
}

exports['default'] = createLocation;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"./Actions":8,"./PathUtils":13,"_process":1,"warning":24}],19:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _PathUtils = require('./PathUtils');

var _Actions = require('./Actions');

var _createHistory = require('./createHistory');

var _createHistory2 = _interopRequireDefault(_createHistory);

function createStateStorage(entries) {
  return entries.filter(function (entry) {
    return entry.state;
  }).reduce(function (memo, entry) {
    memo[entry.key] = entry.state;
    return memo;
  }, {});
}

function createMemoryHistory() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  if (Array.isArray(options)) {
    options = { entries: options };
  } else if (typeof options === 'string') {
    options = { entries: [options] };
  }

  var history = _createHistory2['default'](_extends({}, options, {
    getCurrentLocation: getCurrentLocation,
    finishTransition: finishTransition,
    saveState: saveState,
    go: go
  }));

  var _options = options;
  var entries = _options.entries;
  var current = _options.current;

  if (typeof entries === 'string') {
    entries = [entries];
  } else if (!Array.isArray(entries)) {
    entries = ['/'];
  }

  entries = entries.map(function (entry) {
    var key = history.createKey();

    if (typeof entry === 'string') return { pathname: entry, key: key };

    if (typeof entry === 'object' && entry) return _extends({}, entry, { key: key });

    !false ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
  });

  if (current == null) {
    current = entries.length - 1;
  } else {
    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
  }

  var storage = createStateStorage(entries);

  function saveState(key, state) {
    storage[key] = state;
  }

  function readState(key) {
    return storage[key];
  }

  function getCurrentLocation() {
    var entry = entries[current];
    var basename = entry.basename;
    var pathname = entry.pathname;
    var search = entry.search;

    var path = (basename || '') + pathname + (search || '');

    var key = undefined,
        state = undefined;
    if (entry.key) {
      key = entry.key;
      state = readState(key);
    } else {
      key = history.createKey();
      state = null;
      entry.key = key;
    }

    var location = _PathUtils.parsePath(path);

    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
  }

  function canGo(n) {
    var index = current + n;
    return index >= 0 && index < entries.length;
  }

  function go(n) {
    if (n) {
      if (!canGo(n)) {
        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
        return;
      }

      current += n;

      var currentLocation = getCurrentLocation();

      // change action to POP
      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
    }
  }

  function finishTransition(location) {
    switch (location.action) {
      case _Actions.PUSH:
        current += 1;

        // if we are not on the top of stack
        // remove rest and push new
        if (current < entries.length) entries.splice(current);

        entries.push(location);
        saveState(location.key, location.state);
        break;
      case _Actions.REPLACE:
        entries[current] = location;
        saveState(location.key, location.state);
        break;
    }
  }

  return history;
}

exports['default'] = createMemoryHistory;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"./Actions":8,"./PathUtils":13,"./createHistory":17,"_process":1,"invariant":26,"warning":24}],20:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function deprecate(fn, message) {
  return function () {
    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
    return fn.apply(this, arguments);
  };
}

exports['default'] = deprecate;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"_process":1,"warning":24}],21:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function runTransitionHook(hook, location, callback) {
  var result = hook(location, callback);

  if (hook.length < 2) {
    // Assume the hook runs synchronously and automatically
    // call the callback with the return value.
    callback(result);
  } else {
    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
  }
}

exports['default'] = runTransitionHook;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"_process":1,"warning":24}],22:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _ExecutionEnvironment = require('./ExecutionEnvironment');

var _PathUtils = require('./PathUtils');

var _runTransitionHook = require('./runTransitionHook');

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _deprecate = require('./deprecate');

var _deprecate2 = _interopRequireDefault(_deprecate);

function useBasename(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);

    var basename = options.basename;

    var checkedBaseHref = false;

    function checkBaseHref() {
      if (checkedBaseHref) {
        return;
      }

      // Automatically use the value of <base href> in HTML
      // documents as basename if it's not explicitly given.
      if (basename == null && _ExecutionEnvironment.canUseDOM) {
        var base = document.getElementsByTagName('base')[0];
        var baseHref = base && base.getAttribute('href');

        if (baseHref != null) {
          basename = baseHref;

          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
        }
      }

      checkedBaseHref = true;
    }

    function addBasename(location) {
      checkBaseHref();

      if (basename && location.basename == null) {
        if (location.pathname.indexOf(basename) === 0) {
          location.pathname = location.pathname.substring(basename.length);
          location.basename = basename;

          if (location.pathname === '') location.pathname = '/';
        } else {
          location.basename = '';
        }
      }

      return location;
    }

    function prependBasename(location) {
      checkBaseHref();

      if (!basename) return location;

      if (typeof location === 'string') location = _PathUtils.parsePath(location);

      var pname = location.pathname;
      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
      var pathname = normalizedBasename + normalizedPathname;

      return _extends({}, location, {
        pathname: pathname
      });
    }

    // Override all read methods with basename-aware versions.
    function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        _runTransitionHook2['default'](hook, addBasename(location), callback);
      });
    }

    function listen(listener) {
      return history.listen(function (location) {
        listener(addBasename(location));
      });
    }

    // Override all write methods with basename-aware versions.
    function push(location) {
      history.push(prependBasename(location));
    }

    function replace(location) {
      history.replace(prependBasename(location));
    }

    function createPath(location) {
      return history.createPath(prependBasename(location));
    }

    function createHref(location) {
      return history.createHref(prependBasename(location));
    }

    function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
    }

    // deprecated
    function pushState(state, path) {
      if (typeof path === 'string') path = _PathUtils.parsePath(path);

      push(_extends({ state: state }, path));
    }

    // deprecated
    function replaceState(state, path) {
      if (typeof path === 'string') path = _PathUtils.parsePath(path);

      replace(_extends({ state: state }, path));
    }

    return _extends({}, history, {
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation,

      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
    });
  };
}

exports['default'] = useBasename;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"./ExecutionEnvironment":12,"./PathUtils":13,"./deprecate":20,"./runTransitionHook":21,"_process":1,"warning":24}],23:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _queryString = require('query-string');

var _runTransitionHook = require('./runTransitionHook');

var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);

var _PathUtils = require('./PathUtils');

var _deprecate = require('./deprecate');

var _deprecate2 = _interopRequireDefault(_deprecate);

var SEARCH_BASE_KEY = '$searchBase';

function defaultStringifyQuery(query) {
  return _queryString.stringify(query).replace(/%20/g, '+');
}

var defaultParseQueryString = _queryString.parse;

function isNestedObject(object) {
  for (var p in object) {
    if (Object.prototype.hasOwnProperty.call(object, p) && typeof object[p] === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
  }return false;
}

/**
 * Returns a new createHistory function that may be used to create
 * history objects that know how to handle URL queries.
 */
function useQueries(createHistory) {
  return function () {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var history = createHistory(options);

    var stringifyQuery = options.stringifyQuery;
    var parseQueryString = options.parseQueryString;

    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;

    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;

    function addQuery(location) {
      if (location.query == null) {
        var search = location.search;

        location.query = parseQueryString(search.substring(1));
        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
      }

      // TODO: Instead of all the book-keeping here, this should just strip the
      // stringified query from the search.

      return location;
    }

    function appendQuery(location, query) {
      var _extends2;

      var searchBaseSpec = location[SEARCH_BASE_KEY];
      var queryString = query ? stringifyQuery(query) : '';
      if (!searchBaseSpec && !queryString) {
        return location;
      }

      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;

      if (typeof location === 'string') location = _PathUtils.parsePath(location);

      var searchBase = undefined;
      if (searchBaseSpec && location.search === searchBaseSpec.search) {
        searchBase = searchBaseSpec.searchBase;
      } else {
        searchBase = location.search || '';
      }

      var search = searchBase;
      if (queryString) {
        search += (search ? '&' : '?') + queryString;
      }

      return _extends({}, location, (_extends2 = {
        search: search
      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
    }

    // Override all read methods with query-aware versions.
    function listenBefore(hook) {
      return history.listenBefore(function (location, callback) {
        _runTransitionHook2['default'](hook, addQuery(location), callback);
      });
    }

    function listen(listener) {
      return history.listen(function (location) {
        listener(addQuery(location));
      });
    }

    // Override all write methods with query-aware versions.
    function push(location) {
      history.push(appendQuery(location, location.query));
    }

    function replace(location) {
      history.replace(appendQuery(location, location.query));
    }

    function createPath(location, query) {
      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;

      return history.createPath(appendQuery(location, query || location.query));
    }

    function createHref(location, query) {
      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;

      return history.createHref(appendQuery(location, query || location.query));
    }

    function createLocation(location) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
      if (location.query) {
        fullLocation.query = location.query;
      }
      return addQuery(fullLocation);
    }

    // deprecated
    function pushState(state, path, query) {
      if (typeof path === 'string') path = _PathUtils.parsePath(path);

      push(_extends({ state: state }, path, { query: query }));
    }

    // deprecated
    function replaceState(state, path, query) {
      if (typeof path === 'string') path = _PathUtils.parsePath(path);

      replace(_extends({ state: state }, path, { query: query }));
    }

    return _extends({}, history, {
      listenBefore: listenBefore,
      listen: listen,
      push: push,
      replace: replace,
      createPath: createPath,
      createHref: createHref,
      createLocation: createLocation,

      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
    });
  };
}

exports['default'] = useQueries;
module.exports = exports['default'];
}).call(this,require('_process'))

},{"./PathUtils":13,"./deprecate":20,"./runTransitionHook":21,"_process":1,"query-string":39,"warning":24}],24:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if ("production" !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

},{}],25:[function(require,module,exports){
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
};

var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
        var keys = Object.getOwnPropertyNames(sourceComponent);

        /* istanbul ignore else */
        if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                } catch (error) {

                }
            }
        }
    }

    return targetComponent;
};

},{}],26:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

},{}],27:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],28:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":35}],29:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  value = Object(value);
  return (symToStringTag && symToStringTag in value)
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":28,"./_getRawTag":32,"./_objectToString":33}],30:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":34}],32:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":28}],33:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],34:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],35:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":30}],36:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],37:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":29,"./_getPrototype":31,"./isObjectLike":36}],38:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":6,"trim":97}],39:[function(require,module,exports){
'use strict';
var strictUriEncode = require('strict-uri-encode');

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str) {
	if (typeof str !== 'string') {
		return {};
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return {};
	}

	return str.split('&').reduce(function (ret, param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		key = decodeURIComponent(key);

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		if (!ret.hasOwnProperty(key)) {
			ret[key] = val;
		} else if (Array.isArray(ret[key])) {
			ret[key].push(val);
		} else {
			ret[key] = [ret[key], val];
		}

		return ret;
	}, {});
};

exports.stringify = function (obj) {
	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return key;
		}

		if (Array.isArray(val)) {
			return val.slice().sort().map(function (val2) {
				return strictUriEncode(key) + '=' + strictUriEncode(val2);
			}).join('&');
		}

		return strictUriEncode(key) + '=' + strictUriEncode(val);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

},{"strict-uri-encode":93}],40:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports["default"] = undefined;

var _react = require('react');

var _storeShape = require('../utils/storeShape');

var _storeShape2 = _interopRequireDefault(_storeShape);

var _warning = require('../utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

var Provider = function (_Component) {
  _inherits(Provider, _Component);

  Provider.prototype.getChildContext = function getChildContext() {
    return { store: this.store };
  };

  function Provider(props, context) {
    _classCallCheck(this, Provider);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

    _this.store = props.store;
    return _this;
  }

  Provider.prototype.render = function render() {
    return _react.Children.only(this.props.children);
  };

  return Provider;
}(_react.Component);

exports["default"] = Provider;


if ("production" !== 'production') {
  Provider.prototype.componentWillReceiveProps = function (nextProps) {
    var store = this.store;
    var nextStore = nextProps.store;


    if (store !== nextStore) {
      warnAboutReceivingStore();
    }
  };
}

Provider.propTypes = {
  store: _storeShape2["default"].isRequired,
  children: _react.PropTypes.element.isRequired
};
Provider.childContextTypes = {
  store: _storeShape2["default"].isRequired
};
},{"../utils/storeShape":44,"../utils/warning":45,"react":"react"}],41:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports["default"] = connect;

var _react = require('react');

var _storeShape = require('../utils/storeShape');

var _storeShape2 = _interopRequireDefault(_storeShape);

var _shallowEqual = require('../utils/shallowEqual');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _wrapActionCreators = require('../utils/wrapActionCreators');

var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);

var _warning = require('../utils/warning');

var _warning2 = _interopRequireDefault(_warning);

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var defaultMapStateToProps = function defaultMapStateToProps(state) {
  return {};
}; // eslint-disable-line no-unused-vars
var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
  return { dispatch: dispatch };
};
var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
  return _extends({}, parentProps, stateProps, dispatchProps);
};

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

var errorObject = { value: null };
function tryCatch(fn, ctx) {
  try {
    return fn.apply(ctx);
  } catch (e) {
    errorObject.value = e;
    return errorObject;
  }
}

// Helps track hot reloading.
var nextVersion = 0;

function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var shouldSubscribe = Boolean(mapStateToProps);
  var mapState = mapStateToProps || defaultMapStateToProps;

  var mapDispatch = void 0;
  if (typeof mapDispatchToProps === 'function') {
    mapDispatch = mapDispatchToProps;
  } else if (!mapDispatchToProps) {
    mapDispatch = defaultMapDispatchToProps;
  } else {
    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
  }

  var finalMergeProps = mergeProps || defaultMergeProps;
  var _options$pure = options.pure,
      pure = _options$pure === undefined ? true : _options$pure,
      _options$withRef = options.withRef,
      withRef = _options$withRef === undefined ? false : _options$withRef;

  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;

  // Helps track hot reloading.
  var version = nextVersion++;

  return function wrapWithConnect(WrappedComponent) {
    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';

    function checkStateShape(props, methodName) {
      if (!(0, _isPlainObject2["default"])(props)) {
        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
      }
    }

    function computeMergedProps(stateProps, dispatchProps, parentProps) {
      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
      if ("production" !== 'production') {
        checkStateShape(mergedProps, 'mergeProps');
      }
      return mergedProps;
    }

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
      };

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.store = props.store || context.store;

        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));

        var storeState = _this.store.getState();
        _this.state = { storeState: storeState };
        _this.clearCache();
        return _this;
      }

      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
        if (!this.finalMapStateToProps) {
          return this.configureFinalMapState(store, props);
        }

        var state = store.getState();
        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);

        if ("production" !== 'production') {
          checkStateShape(stateProps, 'mapStateToProps');
        }
        return stateProps;
      };

      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
        var mappedState = mapState(store.getState(), props);
        var isFactory = typeof mappedState === 'function';

        this.finalMapStateToProps = isFactory ? mappedState : mapState;
        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;

        if (isFactory) {
          return this.computeStateProps(store, props);
        }

        if ("production" !== 'production') {
          checkStateShape(mappedState, 'mapStateToProps');
        }
        return mappedState;
      };

      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
        if (!this.finalMapDispatchToProps) {
          return this.configureFinalMapDispatch(store, props);
        }

        var dispatch = store.dispatch;

        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);

        if ("production" !== 'production') {
          checkStateShape(dispatchProps, 'mapDispatchToProps');
        }
        return dispatchProps;
      };

      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
        var mappedDispatch = mapDispatch(store.dispatch, props);
        var isFactory = typeof mappedDispatch === 'function';

        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;

        if (isFactory) {
          return this.computeDispatchProps(store, props);
        }

        if ("production" !== 'production') {
          checkStateShape(mappedDispatch, 'mapDispatchToProps');
        }
        return mappedDispatch;
      };

      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
        var nextStateProps = this.computeStateProps(this.store, this.props);
        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
          return false;
        }

        this.stateProps = nextStateProps;
        return true;
      };

      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
          return false;
        }

        this.dispatchProps = nextDispatchProps;
        return true;
      };

      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
          return false;
        }

        this.mergedProps = nextMergedProps;
        return true;
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return typeof this.unsubscribe === 'function';
      };

      Connect.prototype.trySubscribe = function trySubscribe() {
        if (shouldSubscribe && !this.unsubscribe) {
          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
          this.handleChange();
        }
      };

      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
        if (this.unsubscribe) {
          this.unsubscribe();
          this.unsubscribe = null;
        }
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        this.trySubscribe();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
          this.haveOwnPropsChanged = true;
        }
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        this.tryUnsubscribe();
        this.clearCache();
      };

      Connect.prototype.clearCache = function clearCache() {
        this.dispatchProps = null;
        this.stateProps = null;
        this.mergedProps = null;
        this.haveOwnPropsChanged = true;
        this.hasStoreStateChanged = true;
        this.haveStatePropsBeenPrecalculated = false;
        this.statePropsPrecalculationError = null;
        this.renderedElement = null;
        this.finalMapDispatchToProps = null;
        this.finalMapStateToProps = null;
      };

      Connect.prototype.handleChange = function handleChange() {
        if (!this.unsubscribe) {
          return;
        }

        var storeState = this.store.getState();
        var prevStoreState = this.state.storeState;
        if (pure && prevStoreState === storeState) {
          return;
        }

        if (pure && !this.doStatePropsDependOnOwnProps) {
          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
          if (!haveStatePropsChanged) {
            return;
          }
          if (haveStatePropsChanged === errorObject) {
            this.statePropsPrecalculationError = errorObject.value;
          }
          this.haveStatePropsBeenPrecalculated = true;
        }

        this.hasStoreStateChanged = true;
        this.setState({ storeState: storeState });
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');

        return this.refs.wrappedInstance;
      };

      Connect.prototype.render = function render() {
        var haveOwnPropsChanged = this.haveOwnPropsChanged,
            hasStoreStateChanged = this.hasStoreStateChanged,
            haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated,
            statePropsPrecalculationError = this.statePropsPrecalculationError,
            renderedElement = this.renderedElement;


        this.haveOwnPropsChanged = false;
        this.hasStoreStateChanged = false;
        this.haveStatePropsBeenPrecalculated = false;
        this.statePropsPrecalculationError = null;

        if (statePropsPrecalculationError) {
          throw statePropsPrecalculationError;
        }

        var shouldUpdateStateProps = true;
        var shouldUpdateDispatchProps = true;
        if (pure && renderedElement) {
          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
        }

        var haveStatePropsChanged = false;
        var haveDispatchPropsChanged = false;
        if (haveStatePropsBeenPrecalculated) {
          haveStatePropsChanged = true;
        } else if (shouldUpdateStateProps) {
          haveStatePropsChanged = this.updateStatePropsIfNeeded();
        }
        if (shouldUpdateDispatchProps) {
          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
        }

        var haveMergedPropsChanged = true;
        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
        } else {
          haveMergedPropsChanged = false;
        }

        if (!haveMergedPropsChanged && renderedElement) {
          return renderedElement;
        }

        if (withRef) {
          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
            ref: 'wrappedInstance'
          }));
        } else {
          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
        }

        return this.renderedElement;
      };

      return Connect;
    }(_react.Component);

    Connect.displayName = connectDisplayName;
    Connect.WrappedComponent = WrappedComponent;
    Connect.contextTypes = {
      store: _storeShape2["default"]
    };
    Connect.propTypes = {
      store: _storeShape2["default"]
    };

    if ("production" !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        if (this.version === version) {
          return;
        }

        // We are hot reloading!
        this.version = version;
        this.trySubscribe();
        this.clearCache();
      };
    }

    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
  };
}
},{"../utils/shallowEqual":43,"../utils/storeShape":44,"../utils/warning":45,"../utils/wrapActionCreators":46,"hoist-non-react-statics":25,"invariant":26,"lodash/isPlainObject":37,"react":"react"}],42:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.connect = exports.Provider = undefined;

var _Provider = require('./components/Provider');

var _Provider2 = _interopRequireDefault(_Provider);

var _connect = require('./components/connect');

var _connect2 = _interopRequireDefault(_connect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports.Provider = _Provider2["default"];
exports.connect = _connect2["default"];
},{"./components/Provider":40,"./components/connect":41}],43:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = shallowEqual;
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var hasOwn = Object.prototype.hasOwnProperty;
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}
},{}],44:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

exports["default"] = _react.PropTypes.shape({
  subscribe: _react.PropTypes.func.isRequired,
  dispatch: _react.PropTypes.func.isRequired,
  getState: _react.PropTypes.func.isRequired
});
},{"react":"react"}],45:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports["default"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],46:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports["default"] = wrapActionCreators;

var _redux = require('redux');

function wrapActionCreators(actionCreators) {
  return function (dispatch) {
    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
  };
}
},{"redux":91}],47:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports.loopAsync = loopAsync;
exports.mapAsync = mapAsync;
function loopAsync(turns, work, callback) {
  var currentTurn = 0,
      isDone = false;
  var sync = false,
      hasNext = false,
      doneArgs = void 0;

  function done() {
    isDone = true;
    if (sync) {
      // Iterate instead of recursing if possible.
      doneArgs = [].concat(Array.prototype.slice.call(arguments));
      return;
    }

    callback.apply(this, arguments);
  }

  function next() {
    if (isDone) {
      return;
    }

    hasNext = true;
    if (sync) {
      // Iterate instead of recursing if possible.
      return;
    }

    sync = true;

    while (!isDone && currentTurn < turns && hasNext) {
      hasNext = false;
      work.call(this, currentTurn++, next, done);
    }

    sync = false;

    if (isDone) {
      // This means the loop finished synchronously.
      callback.apply(this, doneArgs);
      return;
    }

    if (currentTurn >= turns && hasNext) {
      isDone = true;
      callback();
    }
  }

  next();
}

function mapAsync(array, work, callback) {
  var length = array.length;
  var values = [];

  if (length === 0) return callback(null, values);

  var isDone = false,
      doneCount = 0;

  function done(index, error, value) {
    if (isDone) return;

    if (error) {
      isDone = true;
      callback(error);
    } else {
      values[index] = value;

      isDone = ++doneCount === length;

      if (isDone) callback(null, values);
    }
  }

  array.forEach(function (item, index) {
    work(item, index, function (error, value) {
      done(index, error, value);
    });
  });
}
},{}],48:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A mixin that adds the "history" instance variable to components.
 */
var History = {

  contextTypes: {
    history: _InternalPropTypes.history
  },

  componentWillMount: function componentWillMount() {
    "production" !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
    this.history = this.context.history;
  }
};

exports.default = History;
module.exports = exports['default'];
},{"./InternalPropTypes":52,"./routerWarning":81}],49:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Link = require('./Link');

var _Link2 = _interopRequireDefault(_Link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An <IndexLink> is used to link to an <IndexRoute>.
 */
var IndexLink = _react2.default.createClass({
  displayName: 'IndexLink',
  render: function render() {
    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
  }
});

exports.default = IndexLink;
module.exports = exports['default'];
},{"./Link":54,"react":"react"}],50:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _Redirect = require('./Redirect');

var _Redirect2 = _interopRequireDefault(_Redirect);

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _React$PropTypes = _react2.default.PropTypes;
var string = _React$PropTypes.string;
var object = _React$PropTypes.object;

/**
 * An <IndexRedirect> is used to redirect from an indexRoute.
 */

var IndexRedirect = _react2.default.createClass({
  displayName: 'IndexRedirect',


  statics: {
    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
      /* istanbul ignore else: sanity check */
      if (parentRoute) {
        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
      } else {
        "production" !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
      }
    }
  },

  propTypes: {
    to: string.isRequired,
    query: object,
    state: object,
    onEnter: _InternalPropTypes.falsy,
    children: _InternalPropTypes.falsy
  },

  /* istanbul ignore next: sanity check */
  render: function render() {
    !false ? "production" !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
  }
});

exports.default = IndexRedirect;
module.exports = exports['default'];
},{"./InternalPropTypes":52,"./Redirect":57,"./routerWarning":81,"invariant":26,"react":"react"}],51:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _RouteUtils = require('./RouteUtils');

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var func = _react2.default.PropTypes.func;

/**
 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
 * a JSX route config.
 */

var IndexRoute = _react2.default.createClass({
  displayName: 'IndexRoute',


  statics: {
    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
      /* istanbul ignore else: sanity check */
      if (parentRoute) {
        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
      } else {
        "production" !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
      }
    }
  },

  propTypes: {
    path: _InternalPropTypes.falsy,
    component: _InternalPropTypes.component,
    components: _InternalPropTypes.components,
    getComponent: func,
    getComponents: func
  },

  /* istanbul ignore next: sanity check */
  render: function render() {
    !false ? "production" !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
  }
});

exports.default = IndexRoute;
module.exports = exports['default'];
},{"./InternalPropTypes":52,"./RouteUtils":60,"./routerWarning":81,"invariant":26,"react":"react"}],52:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
exports.falsy = falsy;

var _react = require('react');

var func = _react.PropTypes.func;
var object = _react.PropTypes.object;
var arrayOf = _react.PropTypes.arrayOf;
var oneOfType = _react.PropTypes.oneOfType;
var element = _react.PropTypes.element;
var shape = _react.PropTypes.shape;
var string = _react.PropTypes.string;
function falsy(props, propName, componentName) {
  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
}

var history = exports.history = shape({
  listen: func.isRequired,
  push: func.isRequired,
  replace: func.isRequired,
  go: func.isRequired,
  goBack: func.isRequired,
  goForward: func.isRequired
});

var component = exports.component = oneOfType([func, string]);
var components = exports.components = oneOfType([component, object]);
var route = exports.route = oneOfType([object, element]);
var routes = exports.routes = oneOfType([route, arrayOf(route)]);
},{"react":"react"}],53:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var object = _react2.default.PropTypes.object;

/**
 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
 * component that may be used to cancel a transition or prompt the user
 * for confirmation.
 *
 * On standard transitions, routerWillLeave receives a single argument: the
 * location we're transitioning to. To cancel the transition, return false.
 * To prompt the user for confirmation, return a prompt message (string).
 *
 * During the beforeunload event (assuming you're using the useBeforeUnload
 * history enhancer), routerWillLeave does not receive a location object
 * because it isn't possible for us to know the location we're transitioning
 * to. In this case routerWillLeave must return a prompt message to prevent
 * the user from closing the window/tab.
 */

var Lifecycle = {

  contextTypes: {
    history: object.isRequired,
    // Nested children receive the route as context, either
    // set by the route component using the RouteContext mixin
    // or by some other ancestor.
    route: object
  },

  propTypes: {
    // Route components receive the route object as a prop.
    route: object
  },

  componentDidMount: function componentDidMount() {
    "production" !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
    !this.routerWillLeave ? "production" !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;

    var route = this.props.route || this.context.route;

    !route ? "production" !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;

    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
  },
  componentWillUnmount: function componentWillUnmount() {
    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
  }
};

exports.default = Lifecycle;
module.exports = exports['default'];
},{"./routerWarning":81,"invariant":26,"react":"react"}],54:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _PropTypes = require('./PropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _React$PropTypes = _react2.default.PropTypes;
var bool = _React$PropTypes.bool;
var object = _React$PropTypes.object;
var string = _React$PropTypes.string;
var func = _React$PropTypes.func;
var oneOfType = _React$PropTypes.oneOfType;


function isLeftClickEvent(event) {
  return event.button === 0;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
function isEmptyObject(object) {
  for (var p in object) {
    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
  }return true;
}

function createLocationDescriptor(to, _ref) {
  var query = _ref.query;
  var hash = _ref.hash;
  var state = _ref.state;

  if (query || hash || state) {
    return { pathname: to, query: query, hash: hash, state: state };
  }

  return to;
}

/**
 * A <Link> is used to create an <a> element that links to a route.
 * When that route is active, the link gets the value of its
 * activeClassName prop.
 *
 * For example, assuming you have the following route:
 *
 *   <Route path="/posts/:postID" component={Post} />
 *
 * You could use the following component to link to that route:
 *
 *   <Link to={`/posts/${post.id}`} />
 *
 * Links may pass along location state and/or query string parameters
 * in the state/query props, respectively.
 *
 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
 */
var Link = _react2.default.createClass({
  displayName: 'Link',


  contextTypes: {
    router: _PropTypes.routerShape
  },

  propTypes: {
    to: oneOfType([string, object]),
    query: object,
    hash: string,
    state: object,
    activeStyle: object,
    activeClassName: string,
    onlyActiveOnIndex: bool.isRequired,
    onClick: func,
    target: string
  },

  getDefaultProps: function getDefaultProps() {
    return {
      onlyActiveOnIndex: false,
      style: {}
    };
  },
  handleClick: function handleClick(event) {
    if (this.props.onClick) this.props.onClick(event);

    if (event.defaultPrevented) return;

    !this.context.router ? "production" !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;

    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;

    // If target prop is set (e.g. to "_blank"), let browser handle link.
    /* istanbul ignore if: untestable with Karma */
    if (this.props.target) return;

    event.preventDefault();

    var _props = this.props;
    var to = _props.to;
    var query = _props.query;
    var hash = _props.hash;
    var state = _props.state;

    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });

    this.context.router.push(location);
  },
  render: function render() {
    var _props2 = this.props;
    var to = _props2.to;
    var query = _props2.query;
    var hash = _props2.hash;
    var state = _props2.state;
    var activeClassName = _props2.activeClassName;
    var activeStyle = _props2.activeStyle;
    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;

    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);

    "production" !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;

    // Ignore if rendered outside the context of router, simplifies unit testing.
    var router = this.context.router;


    if (router) {
      // If user does not specify a `to` prop, return an empty anchor tag.
      if (to == null) {
        return _react2.default.createElement('a', props);
      }

      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
      props.href = router.createHref(location);

      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
        if (router.isActive(location, onlyActiveOnIndex)) {
          if (activeClassName) {
            if (props.className) {
              props.className += ' ' + activeClassName;
            } else {
              props.className = activeClassName;
            }
          }

          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
        }
      }
    }

    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
  }
});

exports.default = Link;
module.exports = exports['default'];
},{"./PropTypes":56,"./routerWarning":81,"invariant":26,"react":"react"}],55:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.compilePattern = compilePattern;
exports.matchPattern = matchPattern;
exports.getParamNames = getParamNames;
exports.getParams = getParams;
exports.formatPattern = formatPattern;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function _compilePattern(pattern) {
  var regexpSource = '';
  var paramNames = [];
  var tokens = [];

  var match = void 0,
      lastIndex = 0,
      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
  while (match = matcher.exec(pattern)) {
    if (match.index !== lastIndex) {
      tokens.push(pattern.slice(lastIndex, match.index));
      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
    }

    if (match[1]) {
      regexpSource += '([^/]+)';
      paramNames.push(match[1]);
    } else if (match[0] === '**') {
      regexpSource += '(.*)';
      paramNames.push('splat');
    } else if (match[0] === '*') {
      regexpSource += '(.*?)';
      paramNames.push('splat');
    } else if (match[0] === '(') {
      regexpSource += '(?:';
    } else if (match[0] === ')') {
      regexpSource += ')?';
    }

    tokens.push(match[0]);

    lastIndex = matcher.lastIndex;
  }

  if (lastIndex !== pattern.length) {
    tokens.push(pattern.slice(lastIndex, pattern.length));
    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
  }

  return {
    pattern: pattern,
    regexpSource: regexpSource,
    paramNames: paramNames,
    tokens: tokens
  };
}

var CompiledPatternsCache = Object.create(null);

function compilePattern(pattern) {
  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);

  return CompiledPatternsCache[pattern];
}

/**
 * Attempts to match a pattern on the given pathname. Patterns may use
 * the following special characters:
 *
 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
 *                  captured string is considered a "param"
 * - ()             Wraps a segment of the URL that is optional
 * - *              Consumes (non-greedy) all characters up to the next
 *                  character in the pattern, or to the end of the URL if
 *                  there is none
 * - **             Consumes (greedy) all characters up to the next character
 *                  in the pattern, or to the end of the URL if there is none
 *
 *  The function calls callback(error, matched) when finished.
 * The return value is an object with the following properties:
 *
 * - remainingPathname
 * - paramNames
 * - paramValues
 */
function matchPattern(pattern, pathname) {
  // Ensure pattern starts with leading slash for consistency with pathname.
  if (pattern.charAt(0) !== '/') {
    pattern = '/' + pattern;
  }

  var _compilePattern2 = compilePattern(pattern);

  var regexpSource = _compilePattern2.regexpSource;
  var paramNames = _compilePattern2.paramNames;
  var tokens = _compilePattern2.tokens;


  if (pattern.charAt(pattern.length - 1) !== '/') {
    regexpSource += '/?'; // Allow optional path separator at end.
  }

  // Special-case patterns like '*' for catch-all routes.
  if (tokens[tokens.length - 1] === '*') {
    regexpSource += '$';
  }

  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
  if (match == null) {
    return null;
  }

  var matchedPath = match[0];
  var remainingPathname = pathname.substr(matchedPath.length);

  if (remainingPathname) {
    // Require that the match ends at a path separator, if we didn't match
    // the full path, so any remaining pathname is a new path segment.
    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
      return null;
    }

    // If there is a remaining pathname, treat the path separator as part of
    // the remaining pathname for properly continuing the match.
    remainingPathname = '/' + remainingPathname;
  }

  return {
    remainingPathname: remainingPathname,
    paramNames: paramNames,
    paramValues: match.slice(1).map(function (v) {
      return v && decodeURIComponent(v);
    })
  };
}

function getParamNames(pattern) {
  return compilePattern(pattern).paramNames;
}

function getParams(pattern, pathname) {
  var match = matchPattern(pattern, pathname);
  if (!match) {
    return null;
  }

  var paramNames = match.paramNames;
  var paramValues = match.paramValues;

  var params = {};

  paramNames.forEach(function (paramName, index) {
    params[paramName] = paramValues[index];
  });

  return params;
}

/**
 * Returns a version of the given pattern with params interpolated. Throws
 * if there is a dynamic segment of the pattern for which there is no param.
 */
function formatPattern(pattern, params) {
  params = params || {};

  var _compilePattern3 = compilePattern(pattern);

  var tokens = _compilePattern3.tokens;

  var parenCount = 0,
      pathname = '',
      splatIndex = 0;

  var token = void 0,
      paramName = void 0,
      paramValue = void 0;
  for (var i = 0, len = tokens.length; i < len; ++i) {
    token = tokens[i];

    if (token === '*' || token === '**') {
      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;

      !(paramValue != null || parenCount > 0) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;

      if (paramValue != null) pathname += encodeURI(paramValue);
    } else if (token === '(') {
      parenCount += 1;
    } else if (token === ')') {
      parenCount -= 1;
    } else if (token.charAt(0) === ':') {
      paramName = token.substring(1);
      paramValue = params[paramName];

      !(paramValue != null || parenCount > 0) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;

      if (paramValue != null) pathname += encodeURIComponent(paramValue);
    } else {
      pathname += token;
    }
  }

  return pathname.replace(/\/+/g, '/');
}
},{"invariant":26}],56:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;

var _react = require('react');

var _deprecateObjectProperties = require('./deprecateObjectProperties');

var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);

var _InternalPropTypes = require('./InternalPropTypes');

var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var func = _react.PropTypes.func;
var object = _react.PropTypes.object;
var shape = _react.PropTypes.shape;
var string = _react.PropTypes.string;
var routerShape = exports.routerShape = shape({
  push: func.isRequired,
  replace: func.isRequired,
  go: func.isRequired,
  goBack: func.isRequired,
  goForward: func.isRequired,
  setRouteLeaveHook: func.isRequired,
  isActive: func.isRequired
});

var locationShape = exports.locationShape = shape({
  pathname: string.isRequired,
  search: string.isRequired,
  state: object,
  action: string.isRequired,
  key: string
});

// Deprecated stuff below:

var falsy = exports.falsy = InternalPropTypes.falsy;
var history = exports.history = InternalPropTypes.history;
var location = exports.location = locationShape;
var component = exports.component = InternalPropTypes.component;
var components = exports.components = InternalPropTypes.components;
var route = exports.route = InternalPropTypes.route;
var routes = exports.routes = InternalPropTypes.routes;
var router = exports.router = routerShape;

if ("production" !== 'production') {
  (function () {
    var deprecatePropType = function deprecatePropType(propType, message) {
      return function () {
        "production" !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
        return propType.apply(undefined, arguments);
      };
    };

    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
    };

    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
    };

    exports.falsy = falsy = deprecateInternalPropType(falsy);
    exports.history = history = deprecateInternalPropType(history);
    exports.component = component = deprecateInternalPropType(component);
    exports.components = components = deprecateInternalPropType(components);
    exports.route = route = deprecateInternalPropType(route);
    exports.routes = routes = deprecateInternalPropType(routes);

    exports.location = location = deprecateRenamedPropType(location, 'location');
    exports.router = router = deprecateRenamedPropType(router, 'router');
  })();
}

var defaultExport = {
  falsy: falsy,
  history: history,
  location: location,
  component: component,
  components: components,
  route: route,
  // For some reason, routes was never here.
  router: router
};

if ("production" !== 'production') {
  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
}

exports.default = defaultExport;
},{"./InternalPropTypes":52,"./deprecateObjectProperties":72,"./routerWarning":81,"react":"react"}],57:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _RouteUtils = require('./RouteUtils');

var _PatternUtils = require('./PatternUtils');

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _React$PropTypes = _react2.default.PropTypes;
var string = _React$PropTypes.string;
var object = _React$PropTypes.object;

/**
 * A <Redirect> is used to declare another URL path a client should
 * be sent to when they request a given URL.
 *
 * Redirects are placed alongside routes in the route configuration
 * and are traversed in the same manner.
 */

var Redirect = _react2.default.createClass({
  displayName: 'Redirect',


  statics: {
    createRouteFromReactElement: function createRouteFromReactElement(element) {
      var route = (0, _RouteUtils.createRouteFromReactElement)(element);

      if (route.from) route.path = route.from;

      route.onEnter = function (nextState, replace) {
        var location = nextState.location;
        var params = nextState.params;


        var pathname = void 0;
        if (route.to.charAt(0) === '/') {
          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
        } else if (!route.to) {
          pathname = location.pathname;
        } else {
          var routeIndex = nextState.routes.indexOf(route);
          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
        }

        replace({
          pathname: pathname,
          query: route.query || location.query,
          state: route.state || location.state
        });
      };

      return route;
    },
    getRoutePattern: function getRoutePattern(routes, routeIndex) {
      var parentPattern = '';

      for (var i = routeIndex; i >= 0; i--) {
        var route = routes[i];
        var pattern = route.path || '';

        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;

        if (pattern.indexOf('/') === 0) break;
      }

      return '/' + parentPattern;
    }
  },

  propTypes: {
    path: string,
    from: string, // Alias for path
    to: string.isRequired,
    query: object,
    state: object,
    onEnter: _InternalPropTypes.falsy,
    children: _InternalPropTypes.falsy
  },

  /* istanbul ignore next: sanity check */
  render: function render() {
    !false ? "production" !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
  }
});

exports.default = Redirect;
module.exports = exports['default'];
},{"./InternalPropTypes":52,"./PatternUtils":55,"./RouteUtils":60,"invariant":26,"react":"react"}],58:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _RouteUtils = require('./RouteUtils');

var _InternalPropTypes = require('./InternalPropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _React$PropTypes = _react2.default.PropTypes;
var string = _React$PropTypes.string;
var func = _React$PropTypes.func;

/**
 * A <Route> is used to declare which components are rendered to the
 * page when the URL matches a given pattern.
 *
 * Routes are arranged in a nested tree structure. When a new URL is
 * requested, the tree is searched depth-first to find a route whose
 * path matches the URL.  When one is found, all routes in the tree
 * that lead to it are considered "active" and their components are
 * rendered into the DOM, nested in the same order as in the tree.
 */

var Route = _react2.default.createClass({
  displayName: 'Route',


  statics: {
    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
  },

  propTypes: {
    path: string,
    component: _InternalPropTypes.component,
    components: _InternalPropTypes.components,
    getComponent: func,
    getComponents: func
  },

  /* istanbul ignore next: sanity check */
  render: function render() {
    !false ? "production" !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
  }
});

exports.default = Route;
module.exports = exports['default'];
},{"./InternalPropTypes":52,"./RouteUtils":60,"invariant":26,"react":"react"}],59:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var object = _react2.default.PropTypes.object;

/**
 * The RouteContext mixin provides a convenient way for route
 * components to set the route in context. This is needed for
 * routes that render elements that want to use the Lifecycle
 * mixin to prevent transitions.
 */

var RouteContext = {

  propTypes: {
    route: object.isRequired
  },

  childContextTypes: {
    route: object.isRequired
  },

  getChildContext: function getChildContext() {
    return {
      route: this.props.route
    };
  },
  componentWillMount: function componentWillMount() {
    "production" !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
  }
};

exports.default = RouteContext;
module.exports = exports['default'];
},{"./routerWarning":81,"react":"react"}],60:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.isReactChildren = isReactChildren;
exports.createRouteFromReactElement = createRouteFromReactElement;
exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
exports.createRoutes = createRoutes;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isValidChild(object) {
  return object == null || _react2.default.isValidElement(object);
}

function isReactChildren(object) {
  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
}

function createRoute(defaultProps, props) {
  return _extends({}, defaultProps, props);
}

function createRouteFromReactElement(element) {
  var type = element.type;
  var route = createRoute(type.defaultProps, element.props);

  if (route.children) {
    var childRoutes = createRoutesFromReactChildren(route.children, route);

    if (childRoutes.length) route.childRoutes = childRoutes;

    delete route.children;
  }

  return route;
}

/**
 * Creates and returns a routes object from the given ReactChildren. JSX
 * provides a convenient way to visualize how routes in the hierarchy are
 * nested.
 *
 *   import { Route, createRoutesFromReactChildren } from 'react-router'
 *
 *   const routes = createRoutesFromReactChildren(
 *     <Route component={App}>
 *       <Route path="home" component={Dashboard}/>
 *       <Route path="news" component={NewsFeed}/>
 *     </Route>
 *   )
 *
 * Note: This method is automatically used when you provide <Route> children
 * to a <Router> component.
 */
function createRoutesFromReactChildren(children, parentRoute) {
  var routes = [];

  _react2.default.Children.forEach(children, function (element) {
    if (_react2.default.isValidElement(element)) {
      // Component classes may have a static create* method.
      if (element.type.createRouteFromReactElement) {
        var route = element.type.createRouteFromReactElement(element, parentRoute);

        if (route) routes.push(route);
      } else {
        routes.push(createRouteFromReactElement(element));
      }
    }
  });

  return routes;
}

/**
 * Creates and returns an array of routes from the given object which
 * may be a JSX route, a plain object route, or an array of either.
 */
function createRoutes(routes) {
  if (isReactChildren(routes)) {
    routes = createRoutesFromReactChildren(routes);
  } else if (routes && !Array.isArray(routes)) {
    routes = [routes];
  }

  return routes;
}
},{"react":"react"}],61:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createHashHistory = require('history/lib/createHashHistory');

var _createHashHistory2 = _interopRequireDefault(_createHashHistory);

var _useQueries = require('history/lib/useQueries');

var _useQueries2 = _interopRequireDefault(_useQueries);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _createTransitionManager = require('./createTransitionManager');

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _InternalPropTypes = require('./InternalPropTypes');

var _RouterContext = require('./RouterContext');

var _RouterContext2 = _interopRequireDefault(_RouterContext);

var _RouteUtils = require('./RouteUtils');

var _RouterUtils = require('./RouterUtils');

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function isDeprecatedHistory(history) {
  return !history || !history.__v2_compatible__;
}

/* istanbul ignore next: sanity check */
function isUnsupportedHistory(history) {
  // v3 histories expose getCurrentLocation, but aren't currently supported.
  return history && history.getCurrentLocation;
}

var _React$PropTypes = _react2.default.PropTypes;
var func = _React$PropTypes.func;
var object = _React$PropTypes.object;

/**
 * A <Router> is a high-level API for automatically setting up
 * a router that renders a <RouterContext> with all the props
 * it needs each time the URL changes.
 */

var Router = _react2.default.createClass({
  displayName: 'Router',


  propTypes: {
    history: object,
    children: _InternalPropTypes.routes,
    routes: _InternalPropTypes.routes, // alias for children
    render: func,
    createElement: func,
    onError: func,
    onUpdate: func,

    // Deprecated:
    parseQueryString: func,
    stringifyQuery: func,

    // PRIVATE: For client-side rehydration of server match.
    matchContext: object
  },

  getDefaultProps: function getDefaultProps() {
    return {
      render: function render(props) {
        return _react2.default.createElement(_RouterContext2.default, props);
      }
    };
  },
  getInitialState: function getInitialState() {
    return {
      location: null,
      routes: null,
      params: null,
      components: null
    };
  },
  handleError: function handleError(error) {
    if (this.props.onError) {
      this.props.onError.call(this, error);
    } else {
      // Throw errors by default so we don't silently swallow them!
      throw error; // This error probably occurred in getChildRoutes or getComponents.
    }
  },
  componentWillMount: function componentWillMount() {
    var _this = this;

    var _props = this.props;
    var parseQueryString = _props.parseQueryString;
    var stringifyQuery = _props.stringifyQuery;

    "production" !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;

    var _createRouterObjects = this.createRouterObjects();

    var history = _createRouterObjects.history;
    var transitionManager = _createRouterObjects.transitionManager;
    var router = _createRouterObjects.router;


    this._unlisten = transitionManager.listen(function (error, state) {
      if (error) {
        _this.handleError(error);
      } else {
        _this.setState(state, _this.props.onUpdate);
      }
    });

    this.history = history;
    this.router = router;
  },
  createRouterObjects: function createRouterObjects() {
    var matchContext = this.props.matchContext;

    if (matchContext) {
      return matchContext;
    }

    var history = this.props.history;
    var _props2 = this.props;
    var routes = _props2.routes;
    var children = _props2.children;


    !!isUnsupportedHistory(history) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;

    if (isDeprecatedHistory(history)) {
      history = this.wrapDeprecatedHistory(history);
    }

    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);

    return { history: routingHistory, transitionManager: transitionManager, router: router };
  },
  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
    var _props3 = this.props;
    var parseQueryString = _props3.parseQueryString;
    var stringifyQuery = _props3.stringifyQuery;


    var createHistory = void 0;
    if (history) {
      "production" !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
      createHistory = function createHistory() {
        return history;
      };
    } else {
      "production" !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
      createHistory = _createHashHistory2.default;
    }

    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
  },


  /* istanbul ignore next: sanity check */
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    "production" !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;

    "production" !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
  },
  componentWillUnmount: function componentWillUnmount() {
    if (this._unlisten) this._unlisten();
  },
  render: function render() {
    var _state = this.state;
    var location = _state.location;
    var routes = _state.routes;
    var params = _state.params;
    var components = _state.components;
    var _props4 = this.props;
    var createElement = _props4.createElement;
    var render = _props4.render;

    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);

    if (location == null) return null; // Async match

    // Only forward non-Router-specific props to routing context, as those are
    // the only ones that might be custom routing context props.
    Object.keys(Router.propTypes).forEach(function (propType) {
      return delete props[propType];
    });

    return render(_extends({}, props, {
      history: this.history,
      router: this.router,
      location: location,
      routes: routes,
      params: params,
      components: components,
      createElement: createElement
    }));
  }
});

exports.default = Router;
module.exports = exports['default'];
},{"./InternalPropTypes":52,"./RouteUtils":60,"./RouterContext":62,"./RouterUtils":63,"./createTransitionManager":71,"./routerWarning":81,"history/lib/createHashHistory":16,"history/lib/useQueries":23,"invariant":26,"react":"react"}],62:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _deprecateObjectProperties = require('./deprecateObjectProperties');

var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);

var _getRouteParams = require('./getRouteParams');

var _getRouteParams2 = _interopRequireDefault(_getRouteParams);

var _RouteUtils = require('./RouteUtils');

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _React$PropTypes = _react2.default.PropTypes;
var array = _React$PropTypes.array;
var func = _React$PropTypes.func;
var object = _React$PropTypes.object;

/**
 * A <RouterContext> renders the component tree for a given router state
 * and sets the history object and the current location in context.
 */

var RouterContext = _react2.default.createClass({
  displayName: 'RouterContext',


  propTypes: {
    history: object,
    router: object.isRequired,
    location: object.isRequired,
    routes: array.isRequired,
    params: object.isRequired,
    components: array.isRequired,
    createElement: func.isRequired
  },

  getDefaultProps: function getDefaultProps() {
    return {
      createElement: _react2.default.createElement
    };
  },


  childContextTypes: {
    history: object,
    location: object.isRequired,
    router: object.isRequired
  },

  getChildContext: function getChildContext() {
    var _props = this.props;
    var router = _props.router;
    var history = _props.history;
    var location = _props.location;

    if (!router) {
      "production" !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;

      router = _extends({}, history, {
        setRouteLeaveHook: history.listenBeforeLeavingRoute
      });
      delete router.listenBeforeLeavingRoute;
    }

    if ("production" !== 'production') {
      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
    }

    return { history: history, location: location, router: router };
  },
  createElement: function createElement(component, props) {
    return component == null ? null : this.props.createElement(component, props);
  },
  render: function render() {
    var _this = this;

    var _props2 = this.props;
    var history = _props2.history;
    var location = _props2.location;
    var routes = _props2.routes;
    var params = _props2.params;
    var components = _props2.components;

    var element = null;

    if (components) {
      element = components.reduceRight(function (element, components, index) {
        if (components == null) return element; // Don't create new children; use the grandchildren.

        var route = routes[index];
        var routeParams = (0, _getRouteParams2.default)(route, params);
        var props = {
          history: history,
          location: location,
          params: params,
          route: route,
          routeParams: routeParams,
          routes: routes
        };

        if ((0, _RouteUtils.isReactChildren)(element)) {
          props.children = element;
        } else if (element) {
          for (var prop in element) {
            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
          }
        }

        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
          var elements = {};

          for (var key in components) {
            if (Object.prototype.hasOwnProperty.call(components, key)) {
              // Pass through the key as a prop to createElement to allow
              // custom createElement functions to know which named component
              // they're rendering, for e.g. matching up to fetched data.
              elements[key] = _this.createElement(components[key], _extends({
                key: key }, props));
            }
          }

          return elements;
        }

        return _this.createElement(components, props);
      }, element);
    }

    !(element === null || element === false || _react2.default.isValidElement(element)) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;

    return element;
  }
});

exports.default = RouterContext;
module.exports = exports['default'];
},{"./RouteUtils":60,"./deprecateObjectProperties":72,"./getRouteParams":74,"./routerWarning":81,"invariant":26,"react":"react"}],63:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createRouterObject = createRouterObject;
exports.createRoutingHistory = createRoutingHistory;

var _deprecateObjectProperties = require('./deprecateObjectProperties');

var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createRouterObject(history, transitionManager) {
  return _extends({}, history, {
    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
    isActive: transitionManager.isActive
  });
}

// deprecated
function createRoutingHistory(history, transitionManager) {
  history = _extends({}, history, transitionManager);

  if ("production" !== 'production') {
    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
  }

  return history;
}
},{"./deprecateObjectProperties":72}],64:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _RouterContext = require('./RouterContext');

var _RouterContext2 = _interopRequireDefault(_RouterContext);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RoutingContext = _react2.default.createClass({
  displayName: 'RoutingContext',
  componentWillMount: function componentWillMount() {
    "production" !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
  },
  render: function render() {
    return _react2.default.createElement(_RouterContext2.default, this.props);
  }
});

exports.default = RoutingContext;
module.exports = exports['default'];
},{"./RouterContext":62,"./routerWarning":81,"react":"react"}],65:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.runEnterHooks = runEnterHooks;
exports.runChangeHooks = runChangeHooks;
exports.runLeaveHooks = runLeaveHooks;

var _AsyncUtils = require('./AsyncUtils');

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createTransitionHook(hook, route, asyncArity) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    hook.apply(route, args);

    if (hook.length < asyncArity) {
      var callback = args[args.length - 1];
      // Assume hook executes synchronously and
      // automatically call the callback.
      callback();
    }
  };
}

function getEnterHooks(routes) {
  return routes.reduce(function (hooks, route) {
    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));

    return hooks;
  }, []);
}

function getChangeHooks(routes) {
  return routes.reduce(function (hooks, route) {
    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
    return hooks;
  }, []);
}

function runTransitionHooks(length, iter, callback) {
  if (!length) {
    callback();
    return;
  }

  var redirectInfo = void 0;
  function replace(location, deprecatedPathname, deprecatedQuery) {
    if (deprecatedPathname) {
      "production" !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
      redirectInfo = {
        pathname: deprecatedPathname,
        query: deprecatedQuery,
        state: location
      };

      return;
    }

    redirectInfo = location;
  }

  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
    iter(index, replace, function (error) {
      if (error || redirectInfo) {
        done(error, redirectInfo); // No need to continue.
      } else {
        next();
      }
    });
  }, callback);
}

/**
 * Runs all onEnter hooks in the given array of routes in order
 * with onEnter(nextState, replace, callback) and calls
 * callback(error, redirectInfo) when finished. The first hook
 * to use replace short-circuits the loop.
 *
 * If a hook needs to run asynchronously, it may use the callback
 * function. However, doing so will cause the transition to pause,
 * which could lead to a non-responsive UI if the hook is slow.
 */
function runEnterHooks(routes, nextState, callback) {
  var hooks = getEnterHooks(routes);
  return runTransitionHooks(hooks.length, function (index, replace, next) {
    hooks[index](nextState, replace, next);
  }, callback);
}

/**
 * Runs all onChange hooks in the given array of routes in order
 * with onChange(prevState, nextState, replace, callback) and calls
 * callback(error, redirectInfo) when finished. The first hook
 * to use replace short-circuits the loop.
 *
 * If a hook needs to run asynchronously, it may use the callback
 * function. However, doing so will cause the transition to pause,
 * which could lead to a non-responsive UI if the hook is slow.
 */
function runChangeHooks(routes, state, nextState, callback) {
  var hooks = getChangeHooks(routes);
  return runTransitionHooks(hooks.length, function (index, replace, next) {
    hooks[index](state, nextState, replace, next);
  }, callback);
}

/**
 * Runs all onLeave hooks in the given array of routes in order.
 */
function runLeaveHooks(routes, prevState) {
  for (var i = 0, len = routes.length; i < len; ++i) {
    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
  }
}
},{"./AsyncUtils":47,"./routerWarning":81}],66:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _RouterContext = require('./RouterContext');

var _RouterContext2 = _interopRequireDefault(_RouterContext);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  if ("production" !== 'production') {
    middlewares.forEach(function (middleware, index) {
      "production" !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
    });
  }

  var withContext = middlewares.map(function (middleware) {
    return middleware.renderRouterContext;
  }).filter(Boolean);
  var withComponent = middlewares.map(function (middleware) {
    return middleware.renderRouteComponent;
  }).filter(Boolean);

  var makeCreateElement = function makeCreateElement() {
    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
    return function (Component, props) {
      return withComponent.reduceRight(function (previous, renderRouteComponent) {
        return renderRouteComponent(previous, props);
      }, baseCreateElement(Component, props));
    };
  };

  return function (renderProps) {
    return withContext.reduceRight(function (previous, renderRouterContext) {
      return renderRouterContext(previous, renderProps);
    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
      createElement: makeCreateElement(renderProps.createElement)
    })));
  };
};

module.exports = exports['default'];
},{"./RouterContext":62,"./routerWarning":81,"react":"react"}],67:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createBrowserHistory = require('history/lib/createBrowserHistory');

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _createRouterHistory = require('./createRouterHistory');

var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
module.exports = exports['default'];
},{"./createRouterHistory":70,"history/lib/createBrowserHistory":14}],68:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _PatternUtils = require('./PatternUtils');

function routeParamsChanged(route, prevState, nextState) {
  if (!route.path) return false;

  var paramNames = (0, _PatternUtils.getParamNames)(route.path);

  return paramNames.some(function (paramName) {
    return prevState.params[paramName] !== nextState.params[paramName];
  });
}

/**
 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
 * the change from prevState to nextState. We leave routes if either
 * 1) they are not in the next state or 2) they are in the next state
 * but their params have changed (i.e. /users/123 => /users/456).
 *
 * leaveRoutes are ordered starting at the leaf route of the tree
 * we're leaving up to the common parent route. enterRoutes are ordered
 * from the top of the tree we're entering down to the leaf route.
 *
 * changeRoutes are any routes that didn't leave or enter during
 * the transition.
 */
function computeChangedRoutes(prevState, nextState) {
  var prevRoutes = prevState && prevState.routes;
  var nextRoutes = nextState.routes;

  var leaveRoutes = void 0,
      changeRoutes = void 0,
      enterRoutes = void 0;
  if (prevRoutes) {
    (function () {
      var parentIsLeaving = false;
      leaveRoutes = prevRoutes.filter(function (route) {
        if (parentIsLeaving) {
          return true;
        } else {
          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
          if (isLeaving) parentIsLeaving = true;
          return isLeaving;
        }
      });

      // onLeave hooks start at the leaf route.
      leaveRoutes.reverse();

      enterRoutes = [];
      changeRoutes = [];

      nextRoutes.forEach(function (route) {
        var isNew = prevRoutes.indexOf(route) === -1;
        var paramsChanged = leaveRoutes.indexOf(route) !== -1;

        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
      });
    })();
  } else {
    leaveRoutes = [];
    changeRoutes = [];
    enterRoutes = nextRoutes;
  }

  return {
    leaveRoutes: leaveRoutes,
    changeRoutes: changeRoutes,
    enterRoutes: enterRoutes
  };
}

exports.default = computeChangedRoutes;
module.exports = exports['default'];
},{"./PatternUtils":55}],69:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = createMemoryHistory;

var _useQueries = require('history/lib/useQueries');

var _useQueries2 = _interopRequireDefault(_useQueries);

var _useBasename = require('history/lib/useBasename');

var _useBasename2 = _interopRequireDefault(_useBasename);

var _createMemoryHistory = require('history/lib/createMemoryHistory');

var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createMemoryHistory(options) {
  // signatures and type checking differ between `useRoutes` and
  // `createMemoryHistory`, have to create `memoryHistory` first because
  // `useQueries` doesn't understand the signature
  var memoryHistory = (0, _createMemoryHistory2.default)(options);
  var createHistory = function createHistory() {
    return memoryHistory;
  };
  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
  history.__v2_compatible__ = true;
  return history;
}
module.exports = exports['default'];
},{"history/lib/createMemoryHistory":19,"history/lib/useBasename":22,"history/lib/useQueries":23}],70:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports.default = function (createHistory) {
  var history = void 0;
  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
  return history;
};

var _useRouterHistory = require('./useRouterHistory');

var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

module.exports = exports['default'];
},{"./useRouterHistory":82}],71:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = createTransitionManager;

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _computeChangedRoutes2 = require('./computeChangedRoutes');

var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);

var _TransitionUtils = require('./TransitionUtils');

var _isActive2 = require('./isActive');

var _isActive3 = _interopRequireDefault(_isActive2);

var _getComponents = require('./getComponents');

var _getComponents2 = _interopRequireDefault(_getComponents);

var _matchRoutes = require('./matchRoutes');

var _matchRoutes2 = _interopRequireDefault(_matchRoutes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hasAnyProperties(object) {
  for (var p in object) {
    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
  }return false;
}

function createTransitionManager(history, routes) {
  var state = {};

  // Signature should be (location, indexOnly), but needs to support (path,
  // query, indexOnly)
  function isActive(location) {
    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

    var indexOnly = void 0;
    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
      "production" !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
      indexOnly = deprecatedIndexOnly || false;
    } else {
      location = history.createLocation(location);
      indexOnly = indexOnlyOrDeprecatedQuery;
    }

    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
  }

  var partialNextState = void 0;

  function match(location, callback) {
    if (partialNextState && partialNextState.location === location) {
      // Continue from where we left off.
      finishMatch(partialNextState, callback);
    } else {
      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
        if (error) {
          callback(error);
        } else if (nextState) {
          finishMatch(_extends({}, nextState, { location: location }), callback);
        } else {
          callback();
        }
      });
    }
  }

  function finishMatch(nextState, callback) {
    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);

    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
    var changeRoutes = _computeChangedRoutes.changeRoutes;
    var enterRoutes = _computeChangedRoutes.enterRoutes;


    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);

    // Tear down confirmation hooks for left routes
    leaveRoutes.filter(function (route) {
      return enterRoutes.indexOf(route) === -1;
    }).forEach(removeListenBeforeHooksForRoute);

    // change and enter hooks are run in series
    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);

      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
    });

    function finishEnterHooks(error, redirectInfo) {
      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);

      // TODO: Fetch components after state is updated.
      (0, _getComponents2.default)(nextState, function (error, components) {
        if (error) {
          callback(error);
        } else {
          // TODO: Make match a pure function and have some other API
          // for "match and update state".
          callback(null, null, state = _extends({}, nextState, { components: components }));
        }
      });
    }

    function handleErrorOrRedirect(error, redirectInfo) {
      if (error) callback(error);else callback(null, redirectInfo);
    }
  }

  var RouteGuid = 1;

  function getRouteID(route) {
    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

    return route.__id__ || create && (route.__id__ = RouteGuid++);
  }

  var RouteHooks = Object.create(null);

  function getRouteHooksForRoutes(routes) {
    return routes.reduce(function (hooks, route) {
      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
      return hooks;
    }, []);
  }

  function transitionHook(location, callback) {
    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
      if (nextState == null) {
        // TODO: We didn't actually match anything, but hang
        // onto error/nextState so we don't have to matchRoutes
        // again in the listen callback.
        callback();
        return;
      }

      // Cache some state here so we don't have to
      // matchRoutes() again in the listen callback.
      partialNextState = _extends({}, nextState, { location: location });

      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);

      var result = void 0;
      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
        // Passing the location arg here indicates to
        // the user that this is a transition hook.
        result = hooks[i](location);
      }

      callback(result);
    });
  }

  /* istanbul ignore next: untestable with Karma */
  function beforeUnloadHook() {
    // Synchronously check to see if any route hooks want
    // to prevent the current window/tab from closing.
    if (state.routes) {
      var hooks = getRouteHooksForRoutes(state.routes);

      var message = void 0;
      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
        // Passing no args indicates to the user that this is a
        // beforeunload hook. We don't know the next location.
        message = hooks[i]();
      }

      return message;
    }
  }

  var unlistenBefore = void 0,
      unlistenBeforeUnload = void 0;

  function removeListenBeforeHooksForRoute(route) {
    var routeID = getRouteID(route, false);
    if (!routeID) {
      return;
    }

    delete RouteHooks[routeID];

    if (!hasAnyProperties(RouteHooks)) {
      // teardown transition & beforeunload hooks
      if (unlistenBefore) {
        unlistenBefore();
        unlistenBefore = null;
      }

      if (unlistenBeforeUnload) {
        unlistenBeforeUnload();
        unlistenBeforeUnload = null;
      }
    }
  }

  /**
   * Registers the given hook function to run before leaving the given route.
   *
   * During a normal transition, the hook function receives the next location
   * as its only argument and can return either a prompt message (string) to show the user,
   * to make sure they want to leave the page; or `false`, to prevent the transition.
   * Any other return value will have no effect.
   *
   * During the beforeunload event (in browsers) the hook receives no arguments.
   * In this case it must return a prompt message to prevent the transition.
   *
   * Returns a function that may be used to unbind the listener.
   */
  function listenBeforeLeavingRoute(route, hook) {
    // TODO: Warn if they register for a route that isn't currently
    // active. They're probably doing something wrong, like re-creating
    // route objects on every location change.
    var routeID = getRouteID(route);
    var hooks = RouteHooks[routeID];

    if (!hooks) {
      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);

      RouteHooks[routeID] = [hook];

      if (thereWereNoRouteHooks) {
        // setup transition & beforeunload hooks
        unlistenBefore = history.listenBefore(transitionHook);

        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
      }
    } else {
      if (hooks.indexOf(hook) === -1) {
        "production" !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;

        hooks.push(hook);
      }
    }

    return function () {
      var hooks = RouteHooks[routeID];

      if (hooks) {
        var newHooks = hooks.filter(function (item) {
          return item !== hook;
        });

        if (newHooks.length === 0) {
          removeListenBeforeHooksForRoute(route);
        } else {
          RouteHooks[routeID] = newHooks;
        }
      }
    };
  }

  /**
   * This is the API for stateful environments. As the location
   * changes, we update state and call the listener. We can also
   * gracefully handle errors and redirects.
   */
  function listen(listener) {
    // TODO: Only use a single history listener. Otherwise we'll
    // end up with multiple concurrent calls to match.
    return history.listen(function (location) {
      if (state.location === location) {
        listener(null, state);
      } else {
        match(location, function (error, redirectLocation, nextState) {
          if (error) {
            listener(error);
          } else if (redirectLocation) {
            history.replace(redirectLocation);
          } else if (nextState) {
            listener(null, nextState);
          } else {
            "production" !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
          }
        });
      }
    });
  }

  return {
    isActive: isActive,
    match: match,
    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
    listen: listen
  };
}

//export default useRoutes

module.exports = exports['default'];
},{"./TransitionUtils":65,"./computeChangedRoutes":68,"./getComponents":73,"./isActive":77,"./matchRoutes":80,"./routerWarning":81}],72:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.canUseMembrane = undefined;

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canUseMembrane = exports.canUseMembrane = false;

// No-op by default.
var deprecateObjectProperties = function deprecateObjectProperties(object) {
  return object;
};

if ("production" !== 'production') {
  try {
    if (Object.defineProperty({}, 'x', {
      get: function get() {
        return true;
      }
    }).x) {
      exports.canUseMembrane = canUseMembrane = true;
    }
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */

  if (canUseMembrane) {
    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
      // Wrap the deprecated object in a membrane to warn on property access.
      var membrane = {};

      var _loop = function _loop(prop) {
        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
          return 'continue';
        }

        if (typeof object[prop] === 'function') {
          // Can't use fat arrow here because of use of arguments below.
          membrane[prop] = function () {
            "production" !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
            return object[prop].apply(object, arguments);
          };
          return 'continue';
        }

        // These properties are non-enumerable to prevent React dev tools from
        // seeing them and causing spurious warnings when accessing them. In
        // principle this could be done with a proxy, but support for the
        // ownKeys trap on proxies is not universal, even among browsers that
        // otherwise support proxies.
        Object.defineProperty(membrane, prop, {
          get: function get() {
            "production" !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
            return object[prop];
          }
        });
      };

      for (var prop in object) {
        var _ret = _loop(prop);

        if (_ret === 'continue') continue;
      }

      return membrane;
    };
  }
}

exports.default = deprecateObjectProperties;
},{"./routerWarning":81}],73:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _AsyncUtils = require('./AsyncUtils');

var _makeStateWithLocation = require('./makeStateWithLocation');

var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getComponentsForRoute(nextState, route, callback) {
  if (route.component || route.components) {
    callback(null, route.component || route.components);
    return;
  }

  var getComponent = route.getComponent || route.getComponents;
  if (!getComponent) {
    callback();
    return;
  }

  var location = nextState.location;

  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);

  getComponent.call(route, nextStateWithLocation, callback);
}

/**
 * Asynchronously fetches all components needed for the given router
 * state and calls callback(error, components) when finished.
 *
 * Note: This operation may finish synchronously if no routes have an
 * asynchronous getComponents method.
 */
function getComponents(nextState, callback) {
  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
    getComponentsForRoute(nextState, route, callback);
  }, callback);
}

exports.default = getComponents;
module.exports = exports['default'];
},{"./AsyncUtils":47,"./makeStateWithLocation":78}],74:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _PatternUtils = require('./PatternUtils');

/**
 * Extracts an object of params the given route cares about from
 * the given params object.
 */
function getRouteParams(route, params) {
  var routeParams = {};

  if (!route.path) return routeParams;

  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
    if (Object.prototype.hasOwnProperty.call(params, p)) {
      routeParams[p] = params[p];
    }
  });

  return routeParams;
}

exports.default = getRouteParams;
module.exports = exports['default'];
},{"./PatternUtils":55}],75:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createHashHistory = require('history/lib/createHashHistory');

var _createHashHistory2 = _interopRequireDefault(_createHashHistory);

var _createRouterHistory = require('./createRouterHistory');

var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
module.exports = exports['default'];
},{"./createRouterHistory":70,"history/lib/createHashHistory":16}],76:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;

var _RouteUtils = require('./RouteUtils');

Object.defineProperty(exports, 'createRoutes', {
  enumerable: true,
  get: function get() {
    return _RouteUtils.createRoutes;
  }
});

var _PropTypes2 = require('./PropTypes');

Object.defineProperty(exports, 'locationShape', {
  enumerable: true,
  get: function get() {
    return _PropTypes2.locationShape;
  }
});
Object.defineProperty(exports, 'routerShape', {
  enumerable: true,
  get: function get() {
    return _PropTypes2.routerShape;
  }
});

var _PatternUtils = require('./PatternUtils');

Object.defineProperty(exports, 'formatPattern', {
  enumerable: true,
  get: function get() {
    return _PatternUtils.formatPattern;
  }
});

var _Router2 = require('./Router');

var _Router3 = _interopRequireDefault(_Router2);

var _Link2 = require('./Link');

var _Link3 = _interopRequireDefault(_Link2);

var _IndexLink2 = require('./IndexLink');

var _IndexLink3 = _interopRequireDefault(_IndexLink2);

var _withRouter2 = require('./withRouter');

var _withRouter3 = _interopRequireDefault(_withRouter2);

var _IndexRedirect2 = require('./IndexRedirect');

var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);

var _IndexRoute2 = require('./IndexRoute');

var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);

var _Redirect2 = require('./Redirect');

var _Redirect3 = _interopRequireDefault(_Redirect2);

var _Route2 = require('./Route');

var _Route3 = _interopRequireDefault(_Route2);

var _History2 = require('./History');

var _History3 = _interopRequireDefault(_History2);

var _Lifecycle2 = require('./Lifecycle');

var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);

var _RouteContext2 = require('./RouteContext');

var _RouteContext3 = _interopRequireDefault(_RouteContext2);

var _useRoutes2 = require('./useRoutes');

var _useRoutes3 = _interopRequireDefault(_useRoutes2);

var _RouterContext2 = require('./RouterContext');

var _RouterContext3 = _interopRequireDefault(_RouterContext2);

var _RoutingContext2 = require('./RoutingContext');

var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);

var _PropTypes3 = _interopRequireDefault(_PropTypes2);

var _match2 = require('./match');

var _match3 = _interopRequireDefault(_match2);

var _useRouterHistory2 = require('./useRouterHistory');

var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);

var _applyRouterMiddleware2 = require('./applyRouterMiddleware');

var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);

var _browserHistory2 = require('./browserHistory');

var _browserHistory3 = _interopRequireDefault(_browserHistory2);

var _hashHistory2 = require('./hashHistory');

var _hashHistory3 = _interopRequireDefault(_hashHistory2);

var _createMemoryHistory2 = require('./createMemoryHistory');

var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Router = _Router3.default; /* components */

exports.Link = _Link3.default;
exports.IndexLink = _IndexLink3.default;
exports.withRouter = _withRouter3.default;

/* components (configuration) */

exports.IndexRedirect = _IndexRedirect3.default;
exports.IndexRoute = _IndexRoute3.default;
exports.Redirect = _Redirect3.default;
exports.Route = _Route3.default;

/* mixins */

exports.History = _History3.default;
exports.Lifecycle = _Lifecycle3.default;
exports.RouteContext = _RouteContext3.default;

/* utils */

exports.useRoutes = _useRoutes3.default;
exports.RouterContext = _RouterContext3.default;
exports.RoutingContext = _RoutingContext3.default;
exports.PropTypes = _PropTypes3.default;
exports.match = _match3.default;
exports.useRouterHistory = _useRouterHistory3.default;
exports.applyRouterMiddleware = _applyRouterMiddleware3.default;

/* histories */

exports.browserHistory = _browserHistory3.default;
exports.hashHistory = _hashHistory3.default;
exports.createMemoryHistory = _createMemoryHistory3.default;
},{"./History":48,"./IndexLink":49,"./IndexRedirect":50,"./IndexRoute":51,"./Lifecycle":53,"./Link":54,"./PatternUtils":55,"./PropTypes":56,"./Redirect":57,"./Route":58,"./RouteContext":59,"./RouteUtils":60,"./Router":61,"./RouterContext":62,"./RoutingContext":64,"./applyRouterMiddleware":66,"./browserHistory":67,"./createMemoryHistory":69,"./hashHistory":75,"./match":79,"./useRouterHistory":82,"./useRoutes":83,"./withRouter":84}],77:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.default = isActive;

var _PatternUtils = require('./PatternUtils');

function deepEqual(a, b) {
  if (a == b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return deepEqual(item, b[index]);
    });
  }

  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
    for (var p in a) {
      if (!Object.prototype.hasOwnProperty.call(a, p)) {
        continue;
      }

      if (a[p] === undefined) {
        if (b[p] !== undefined) {
          return false;
        }
      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
        return false;
      } else if (!deepEqual(a[p], b[p])) {
        return false;
      }
    }

    return true;
  }

  return String(a) === String(b);
}

/**
 * Returns true if the current pathname matches the supplied one, net of
 * leading and trailing slash normalization. This is sufficient for an
 * indexOnly route match.
 */
function pathIsActive(pathname, currentPathname) {
  // Normalize leading slash for consistency. Leading slash on pathname has
  // already been normalized in isActive. See caveat there.
  if (currentPathname.charAt(0) !== '/') {
    currentPathname = '/' + currentPathname;
  }

  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
  // `/foo` as active, but in this case, we would already have failed the
  // match.
  if (pathname.charAt(pathname.length - 1) !== '/') {
    pathname += '/';
  }
  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
    currentPathname += '/';
  }

  return currentPathname === pathname;
}

/**
 * Returns true if the given pathname matches the active routes and params.
 */
function routeIsActive(pathname, routes, params) {
  var remainingPathname = pathname,
      paramNames = [],
      paramValues = [];

  // for...of would work here but it's probably slower post-transpilation.
  for (var i = 0, len = routes.length; i < len; ++i) {
    var route = routes[i];
    var pattern = route.path || '';

    if (pattern.charAt(0) === '/') {
      remainingPathname = pathname;
      paramNames = [];
      paramValues = [];
    }

    if (remainingPathname !== null && pattern) {
      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
      if (matched) {
        remainingPathname = matched.remainingPathname;
        paramNames = [].concat(paramNames, matched.paramNames);
        paramValues = [].concat(paramValues, matched.paramValues);
      } else {
        remainingPathname = null;
      }

      if (remainingPathname === '') {
        // We have an exact match on the route. Just check that all the params
        // match.
        // FIXME: This doesn't work on repeated params.
        return paramNames.every(function (paramName, index) {
          return String(paramValues[index]) === String(params[paramName]);
        });
      }
    }
  }

  return false;
}

/**
 * Returns true if all key/value pairs in the given query are
 * currently active.
 */
function queryIsActive(query, activeQuery) {
  if (activeQuery == null) return query == null;

  if (query == null) return true;

  return deepEqual(query, activeQuery);
}

/**
 * Returns true if a <Link> to the given pathname/query combination is
 * currently active.
 */
function isActive(_ref, indexOnly, currentLocation, routes, params) {
  var pathname = _ref.pathname;
  var query = _ref.query;

  if (currentLocation == null) return false;

  // TODO: This is a bit ugly. It keeps around support for treating pathnames
  // without preceding slashes as absolute paths, but possibly also works
  // around the same quirks with basenames as in matchRoutes.
  if (pathname.charAt(0) !== '/') {
    pathname = '/' + pathname;
  }

  if (!pathIsActive(pathname, currentLocation.pathname)) {
    // The path check is necessary and sufficient for indexOnly, but otherwise
    // we still need to check the routes.
    if (indexOnly || !routeIsActive(pathname, routes, params)) {
      return false;
    }
  }

  return queryIsActive(query, currentLocation.query);
}
module.exports = exports['default'];
},{"./PatternUtils":55}],78:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = makeStateWithLocation;

var _deprecateObjectProperties = require('./deprecateObjectProperties');

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function makeStateWithLocation(state, location) {
  if ("production" !== 'production' && _deprecateObjectProperties.canUseMembrane) {
    var stateWithLocation = _extends({}, state);

    // I don't use deprecateObjectProperties here because I want to keep the
    // same code path between development and production, in that we just
    // assign extra properties to the copy of the state object in both cases.

    var _loop = function _loop(prop) {
      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
        return 'continue';
      }

      Object.defineProperty(stateWithLocation, prop, {
        get: function get() {
          "production" !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
          return location[prop];
        }
      });
    };

    for (var prop in location) {
      var _ret = _loop(prop);

      if (_ret === 'continue') continue;
    }

    return stateWithLocation;
  }

  return _extends({}, state, location);
}
module.exports = exports['default'];
},{"./deprecateObjectProperties":72,"./routerWarning":81}],79:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _Actions = require('history/lib/Actions');

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _createMemoryHistory = require('./createMemoryHistory');

var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

var _createTransitionManager = require('./createTransitionManager');

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _RouteUtils = require('./RouteUtils');

var _RouterUtils = require('./RouterUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/**
 * A high-level API to be used for server-side rendering.
 *
 * This function matches a location to a set of routes and calls
 * callback(error, redirectLocation, renderProps) when finished.
 *
 * Note: You probably don't want to use this in a browser unless you're using
 * server-side rendering with async routes.
 */
function match(_ref, callback) {
  var history = _ref.history;
  var routes = _ref.routes;
  var location = _ref.location;

  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);

  !(history || location) ? "production" !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;

  history = history ? history : (0, _createMemoryHistory2.default)(options);
  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));

  var unlisten = void 0;

  if (location) {
    // Allow match({ location: '/the/path', ... })
    location = history.createLocation(location);
  } else {
    // Pick up the location from the history via synchronous history.listen
    // call if needed.
    unlisten = history.listen(function (historyLocation) {
      location = historyLocation;
    });
  }

  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);

  transitionManager.match(location, function (error, redirectLocation, nextState) {
    callback(error, redirectLocation && router.createLocation(redirectLocation, _Actions.REPLACE), nextState && _extends({}, nextState, {
      history: history,
      router: router,
      matchContext: { history: history, transitionManager: transitionManager, router: router }
    }));

    // Defer removing the listener to here to prevent DOM histories from having
    // to unwind DOM event listeners unnecessarily, in case callback renders a
    // <Router> and attaches another history listener.
    if (unlisten) {
      unlisten();
    }
  });
}

exports.default = match;
module.exports = exports['default'];
},{"./RouteUtils":60,"./RouterUtils":63,"./createMemoryHistory":69,"./createTransitionManager":71,"history/lib/Actions":8,"invariant":26}],80:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.default = matchRoutes;

var _AsyncUtils = require('./AsyncUtils');

var _makeStateWithLocation = require('./makeStateWithLocation');

var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);

var _PatternUtils = require('./PatternUtils');

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

var _RouteUtils = require('./RouteUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getChildRoutes(route, location, paramNames, paramValues, callback) {
  if (route.childRoutes) {
    return [null, route.childRoutes];
  }
  if (!route.getChildRoutes) {
    return [];
  }

  var sync = true,
      result = void 0;

  var partialNextState = {
    location: location,
    params: createParams(paramNames, paramValues)
  };

  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);

  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
    if (sync) {
      result = [error, childRoutes];
      return;
    }

    callback(error, childRoutes);
  });

  sync = false;
  return result; // Might be undefined.
}

function getIndexRoute(route, location, paramNames, paramValues, callback) {
  if (route.indexRoute) {
    callback(null, route.indexRoute);
  } else if (route.getIndexRoute) {
    var partialNextState = {
      location: location,
      params: createParams(paramNames, paramValues)
    };

    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);

    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
    });
  } else if (route.childRoutes) {
    (function () {
      var pathless = route.childRoutes.filter(function (childRoute) {
        return !childRoute.path;
      });

      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
          if (error || indexRoute) {
            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
            done(error, routes);
          } else {
            next();
          }
        });
      }, function (err, routes) {
        callback(null, routes);
      });
    })();
  } else {
    callback();
  }
}

function assignParams(params, paramNames, paramValues) {
  return paramNames.reduce(function (params, paramName, index) {
    var paramValue = paramValues && paramValues[index];

    if (Array.isArray(params[paramName])) {
      params[paramName].push(paramValue);
    } else if (paramName in params) {
      params[paramName] = [params[paramName], paramValue];
    } else {
      params[paramName] = paramValue;
    }

    return params;
  }, params);
}

function createParams(paramNames, paramValues) {
  return assignParams({}, paramNames, paramValues);
}

function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
  var pattern = route.path || '';

  if (pattern.charAt(0) === '/') {
    remainingPathname = location.pathname;
    paramNames = [];
    paramValues = [];
  }

  // Only try to match the path if the route actually has a pattern, and if
  // we're not just searching for potential nested absolute paths.
  if (remainingPathname !== null && pattern) {
    try {
      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
      if (matched) {
        remainingPathname = matched.remainingPathname;
        paramNames = [].concat(paramNames, matched.paramNames);
        paramValues = [].concat(paramValues, matched.paramValues);
      } else {
        remainingPathname = null;
      }
    } catch (error) {
      callback(error);
    }

    // By assumption, pattern is non-empty here, which is the prerequisite for
    // actually terminating a match.
    if (remainingPathname === '') {
      var _ret2 = function () {
        var match = {
          routes: [route],
          params: createParams(paramNames, paramValues)
        };

        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
          if (error) {
            callback(error);
          } else {
            if (Array.isArray(indexRoute)) {
              var _match$routes;

              "production" !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
                return !route.path;
              }), 'Index routes should not have paths') : void 0;
              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
            } else if (indexRoute) {
              "production" !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
              match.routes.push(indexRoute);
            }

            callback(null, match);
          }
        });

        return {
          v: void 0
        };
      }();

      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
    }
  }

  if (remainingPathname != null || route.childRoutes) {
    // Either a) this route matched at least some of the path or b)
    // we don't have to load this route's children asynchronously. In
    // either case continue checking for matches in the subtree.
    var onChildRoutes = function onChildRoutes(error, childRoutes) {
      if (error) {
        callback(error);
      } else if (childRoutes) {
        // Check the child routes to see if any of them match.
        matchRoutes(childRoutes, location, function (error, match) {
          if (error) {
            callback(error);
          } else if (match) {
            // A child route matched! Augment the match and pass it up the stack.
            match.routes.unshift(route);
            callback(null, match);
          } else {
            callback();
          }
        }, remainingPathname, paramNames, paramValues);
      } else {
        callback();
      }
    };

    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
    if (result) {
      onChildRoutes.apply(undefined, result);
    }
  } else {
    callback();
  }
}

/**
 * Asynchronously matches the given location to a set of routes and calls
 * callback(error, state) when finished. The state object will have the
 * following properties:
 *
 * - routes       An array of routes that matched, in hierarchical order
 * - params       An object of URL parameters
 *
 * Note: This operation may finish synchronously if no routes have an
 * asynchronous getChildRoutes method.
 */
function matchRoutes(routes, location, callback, remainingPathname) {
  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

  if (remainingPathname === undefined) {
    // TODO: This is a little bit ugly, but it works around a quirk in history
    // that strips the leading slash from pathnames when using basenames with
    // trailing slashes.
    if (location.pathname.charAt(0) !== '/') {
      location = _extends({}, location, {
        pathname: '/' + location.pathname
      });
    }
    remainingPathname = location.pathname;
  }

  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
      if (error || match) {
        done(error, match);
      } else {
        next();
      }
    });
  }, callback);
}
module.exports = exports['default'];
},{"./AsyncUtils":47,"./PatternUtils":55,"./RouteUtils":60,"./makeStateWithLocation":78,"./routerWarning":81}],81:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = routerWarning;
exports._resetWarned = _resetWarned;

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var warned = {};

function routerWarning(falseToWarn, message) {
  // Only issue deprecation warnings once.
  if (message.indexOf('deprecated') !== -1) {
    if (warned[message]) {
      return;
    }

    warned[message] = true;
  }

  message = '[react-router] ' + message;

  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
}

function _resetWarned() {
  warned = {};
}
},{"warning":98}],82:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = useRouterHistory;

var _useQueries = require('history/lib/useQueries');

var _useQueries2 = _interopRequireDefault(_useQueries);

var _useBasename = require('history/lib/useBasename');

var _useBasename2 = _interopRequireDefault(_useBasename);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function useRouterHistory(createHistory) {
  return function (options) {
    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
    history.__v2_compatible__ = true;
    return history;
  };
}
module.exports = exports['default'];
},{"history/lib/useBasename":22,"history/lib/useQueries":23}],83:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _useQueries = require('history/lib/useQueries');

var _useQueries2 = _interopRequireDefault(_useQueries);

var _createTransitionManager = require('./createTransitionManager');

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _routerWarning = require('./routerWarning');

var _routerWarning2 = _interopRequireDefault(_routerWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/**
 * Returns a new createHistory function that may be used to create
 * history objects that know about routing.
 *
 * Enhances history objects with the following methods:
 *
 * - listen((error, nextState) => {})
 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
 * - match(location, (error, redirectLocation, nextState) => {})
 * - isActive(pathname, query, indexOnly=false)
 */
function useRoutes(createHistory) {
  "production" !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;

  return function () {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var routes = _ref.routes;

    var options = _objectWithoutProperties(_ref, ['routes']);

    var history = (0, _useQueries2.default)(createHistory)(options);
    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
    return _extends({}, history, transitionManager);
  };
}

exports.default = useRoutes;
module.exports = exports['default'];
},{"./createTransitionManager":71,"./routerWarning":81,"history/lib/useQueries":23}],84:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = withRouter;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _PropTypes = require('./PropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

function withRouter(WrappedComponent, options) {
  var withRef = options && options.withRef;

  var WithRouter = _react2.default.createClass({
    displayName: 'WithRouter',

    contextTypes: { router: _PropTypes.routerShape },
    propTypes: { router: _PropTypes.routerShape },

    getWrappedInstance: function getWrappedInstance() {
      !withRef ? "production" !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;

      return this.wrappedInstance;
    },
    render: function render() {
      var _this = this;

      var router = this.props.router || this.context.router;
      var props = _extends({}, this.props, { router: router });

      if (withRef) {
        props.ref = function (c) {
          _this.wrappedInstance = c;
        };
      }

      return _react2.default.createElement(WrappedComponent, props);
    }
  });

  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
  WithRouter.WrappedComponent = WrappedComponent;

  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
}
module.exports = exports['default'];
},{"./PropTypes":56,"hoist-non-react-statics":25,"invariant":26,"react":"react"}],85:[function(require,module,exports){
'use strict';

function thunkMiddleware(_ref) {
  var dispatch = _ref.dispatch;
  var getState = _ref.getState;

  return function (next) {
    return function (action) {
      return typeof action === 'function' ? action(dispatch, getState) : next(action);
    };
  };
}

module.exports = thunkMiddleware;
},{}],86:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = applyMiddleware;

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}
},{"./compose":89}],87:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
},{}],88:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = combineReducers;

var _createStore = require('./createStore');

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0, _isPlainObject2['default'])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerSanity(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if ("production" !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  if ("production" !== 'production') {
    var unexpectedKeyCache = {};
  }

  var sanityError;
  try {
    assertReducerSanity(finalReducers);
  } catch (e) {
    sanityError = e;
  }

  return function combination() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var action = arguments[1];

    if (sanityError) {
      throw sanityError;
    }

    if ("production" !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        (0, _warning2['default'])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var i = 0; i < finalReducerKeys.length; i++) {
      var key = finalReducerKeys[i];
      var reducer = finalReducers[key];
      var previousStateForKey = state[key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(key, action);
        throw new Error(errorMessage);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
},{"./createStore":90,"./utils/warning":92,"lodash/isPlainObject":37}],89:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  var last = funcs[funcs.length - 1];
  var rest = funcs.slice(0, -1);
  return function () {
    return rest.reduceRight(function (composed, f) {
      return f(composed);
    }, last.apply(undefined, arguments));
  };
}
},{}],90:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ActionTypes = undefined;
exports['default'] = createStore;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} enhancer The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2['default'])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/zenparsing/es-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2['default']] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
}
},{"lodash/isPlainObject":37,"symbol-observable":94}],91:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _createStore = require('./createStore');

var _createStore2 = _interopRequireDefault(_createStore);

var _combineReducers = require('./combineReducers');

var _combineReducers2 = _interopRequireDefault(_combineReducers);

var _bindActionCreators = require('./bindActionCreators');

var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

var _applyMiddleware = require('./applyMiddleware');

var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if ("production" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = _createStore2['default'];
exports.combineReducers = _combineReducers2['default'];
exports.bindActionCreators = _bindActionCreators2['default'];
exports.applyMiddleware = _applyMiddleware2['default'];
exports.compose = _compose2['default'];
},{"./applyMiddleware":86,"./bindActionCreators":87,"./combineReducers":88,"./compose":89,"./createStore":90,"./utils/warning":92}],92:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],93:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};

},{}],94:[function(require,module,exports){
module.exports = require('./lib/index');

},{"./lib/index":95}],95:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill":96}],96:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],97:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],98:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],99:[function(require,module,exports){
var window              = require('global');
var MockXMLHttpRequest  = require('./lib/MockXMLHttpRequest');
var real                = window.XMLHttpRequest;
var mock                = MockXMLHttpRequest;

/**
 * Mock utility
 */
module.exports = {

	XMLHttpRequest: MockXMLHttpRequest,

	/**
	 * Replace the native XHR with the mocked XHR
	 * @returns {exports}
	 */
	setup: function() {
		window.XMLHttpRequest = mock;
		MockXMLHttpRequest.handlers = [];
		return this;
	},

	/**
	 * Replace the mocked XHR with the native XHR and remove any handlers
	 * @returns {exports}
	 */
	teardown: function() {
		MockXMLHttpRequest.handlers = [];
		window.XMLHttpRequest = real;
		return this;
	},

	/**
	 * Mock a request
	 * @param   {string}    [method]
	 * @param   {string}    [url]
	 * @param   {Function}  fn
	 * @returns {exports}
	 */
	mock: function(method, url, fn) {
		var handler;
		if (arguments.length === 3) {
			handler = function(req, res) {
				if (req.method() === method && req.url() === url) {
					return fn(req, res);
				}
				return false;
			};
		} else {
			handler = method;
		}

		MockXMLHttpRequest.addHandler(handler);

		return this;
	},

	/**
	 * Mock a GET request
	 * @param   {String}    url
	 * @param   {Function}  fn
	 * @returns {exports}
	 */
	get: function(url, fn) {
		return this.mock('GET', url, fn);
	},

	/**
	 * Mock a POST request
	 * @param   {String}    url
	 * @param   {Function}  fn
	 * @returns {exports}
	 */
	post: function(url, fn) {
		return this.mock('POST', url, fn);
	},

	/**
	 * Mock a PUT request
	 * @param   {String}    url
	 * @param   {Function}  fn
	 * @returns {exports}
	 */
	put: function(url, fn) {
		return this.mock('PUT', url, fn);
	},

	/**
	 * Mock a PATCH request
	 * @param   {String}    url
	 * @param   {Function}  fn
	 * @returns {exports}
	 */
	patch: function(url, fn) {
		return this.mock('PATCH', url, fn);
	},

	/**
	 * Mock a DELETE request
	 * @param   {String}    url
	 * @param   {Function}  fn
	 * @returns {exports}
	 */
	delete: function(url, fn) {
		return this.mock('DELETE', url, fn);
	}

};

},{"./lib/MockXMLHttpRequest":102,"global":7}],100:[function(require,module,exports){

/**
 * The mocked request data
 * @constructor
 */
function MockRequest(xhr) {
  this._xhr       = xhr
  this._method    = xhr.method;
  this._url       = xhr.url;
  this._headers   = {};
  this.headers(xhr._requestHeaders);
  this.body(xhr.data);
}

/**
 * Get/set the HTTP method
 * @returns {string}
 */
MockRequest.prototype.method = function() {
  return this._method;
};

/**
 * Get/set the HTTP URL
 * @returns {string}
 */
MockRequest.prototype.url = function() {
  return this._url;
};

/**
 * Get/set a HTTP header
 * @param   {string} name
 * @param   {string} [value]
 * @returns {string|undefined|MockRequest}
 */
MockRequest.prototype.header = function(name, value) {
  if (arguments.length === 2) {
    this._headers[name.toLowerCase()] = value;
    return this;
  } else {
    return this._headers[name.toLowerCase()] || null;
  }
};

/**
 * Get/set all of the HTTP headers
 * @param   {Object} [headers]
 * @returns {Object|MockRequest}
 */
MockRequest.prototype.headers = function(headers) {
  if (arguments.length) {
    for (var name in headers) {
      if (headers.hasOwnProperty(name)) {
        this.header(name, headers[name]);
      }
    }
    return this;
  } else {
    return this._headers;
  }
};

/**
 * Get/set the HTTP body
 * @param   {string} [body]
 * @returns {string|MockRequest}
 */
MockRequest.prototype.body = function(body) {
  if (arguments.length) {
    this._body = body;
    return this;
  } else {
    return this._body;
  }
};

/**
 * Trigger progress event
 * @param   {number} [loaded]
 * @param   {number} [total]
 * @param   {boolean} [lengthComputable]
 * @returns {}
 */
MockRequest.prototype.progress = function(loaded, total, lengthComputable) {
  this._xhr.trigger('progress', {
    lengthComputable: lengthComputable || true,
    loaded: loaded,
    total: total
  })
};

module.exports = MockRequest;

},{}],101:[function(require,module,exports){

/**
 * The mocked response data
 * @constructor
 */
function MockResponse() {
  this._status      = 200;
  this._headers     = {};
  this._body        = '';
  this._timeout     = false;
}

/**
 * Get/set the HTTP status
 * @param   {number} [code]
 * @returns {number|MockResponse}
 */
MockResponse.prototype.status = function(code) {
  if (arguments.length) {
    this._status = code;
    return this;
  } else {
    return this._status;
  }
};

/**
 * Get/set a HTTP header
 * @param   {string} name
 * @param   {string} [value]
 * @returns {string|undefined|MockResponse}
 */
MockResponse.prototype.header = function(name, value) {
  if (arguments.length === 2) {
    this._headers[name.toLowerCase()] = value;
    return this;
  } else {
    return this._headers[name.toLowerCase()] || null;
  }
};

/**
 * Get/set all of the HTTP headers
 * @param   {Object} [headers]
 * @returns {Object|MockResponse}
 */
MockResponse.prototype.headers = function(headers) {
  if (arguments.length) {
    for (var name in headers) {
      if (headers.hasOwnProperty(name)) {
        this.header(name, headers[name]);
      }
    }
    return this;
  } else {
    return this._headers;
  }
};

/**
 * Get/set the HTTP body
 * @param   {string} [body]
 * @returns {string|MockResponse}
 */
MockResponse.prototype.body = function(body) {
  if (arguments.length) {
    this._body = body;
    return this;
  } else {
    return this._body;
  }
};

/**
 * Get/set the HTTP timeout
 * @param   {boolean|number} [timeout]
 * @returns {boolean|number|MockResponse}
 */
MockResponse.prototype.timeout = function(timeout) {
  if (arguments.length) {
    this._timeout = timeout;
    return this;
  } else {
    return this._timeout;
  }
};

module.exports = MockResponse;

},{}],102:[function(require,module,exports){
var MockRequest   = require('./MockRequest');
var MockResponse  = require('./MockResponse');

var notImplementedError = new Error('This feature hasn\'t been implmented yet. Please submit an Issue or Pull Request on Github.');

//https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
//https://xhr.spec.whatwg.org/
//http://www.w3.org/TR/2006/WD-XMLHttpRequest-20060405/

MockXMLHttpRequest.STATE_UNSENT             = 0;
MockXMLHttpRequest.STATE_OPENED             = 1;
MockXMLHttpRequest.STATE_HEADERS_RECEIVED   = 2;
MockXMLHttpRequest.STATE_LOADING            = 3;
MockXMLHttpRequest.STATE_DONE               = 4;

/**
 * The request handlers
 * @private
 * @type {Array}
 */
MockXMLHttpRequest.handlers = [];

/**
 * Add a request handler
 * @param   {function(MockRequest, MockResponse)} fn
 * @returns {MockXMLHttpRequest}
 */
MockXMLHttpRequest.addHandler = function(fn) {
  MockXMLHttpRequest.handlers.push(fn);
  return this;
};

/**
 * Remove a request handler
 * @param   {function(MockRequest, MockResponse)} fn
 * @returns {MockXMLHttpRequest}
 */
MockXMLHttpRequest.removeHandler = function(fn) {
  throw notImplementedError;
};

/**
 * Handle a request
 * @param   {MockRequest} request
 * @returns {MockResponse|null}
 */
MockXMLHttpRequest.handle = function(request) {

  for (var i=0; i<MockXMLHttpRequest.handlers.length; ++i) {

    //get the generator to create a response to the request
    var response = MockXMLHttpRequest.handlers[i](request, new MockResponse());

    if (response) {
      return response;
    }

  }

  return null;
};

/**
 * Mock XMLHttpRequest
 * @constructor
 */
function MockXMLHttpRequest() {
  this.reset();
  this._eventListeners = [];
  this.timeout = 0;
}

/**
 * Reset the response values
 * @private
 */
MockXMLHttpRequest.prototype.reset = function() {

  this._requestHeaders  = {};
  this._responseHeaders = {};

  this.status       = 0;
  this.statusText   = '';

  this.response     = null;
  this.responseType = null;
  this.responseText = null;
  this.responseXML  = null;

  this.readyState   = MockXMLHttpRequest.STATE_UNSENT;
};

/**
 * Trigger an event
 * @param   {String} event
 * @returns {MockXMLHttpRequest}
 */
MockXMLHttpRequest.prototype.trigger = function(event, eventDetails) {

  if (this.onreadystatechange) {
    this.onreadystatechange();
  }

  if (this['on'+event]) {
    this['on'+event]();
  }

  for (var x = 0; x < this._eventListeners.length; x++) {
    var eventListener = this._eventListeners[x];

    if (eventListener.event === event) {
      var eventListenerDetails = eventDetails || {};
      eventListenerDetails.currentTarget = this;
      eventListenerDetails.type = event;
      eventListener.listener.call(this, eventListenerDetails);
    }
  }

  return this;
};

MockXMLHttpRequest.prototype.open = function(method, url, async, user, password) {
  this.reset();
  this.method   = method;
  this.url      = url;
  this.async    = async;
  this.user     = user;
  this.password = password;
  this.data     = null;
  this.readyState = MockXMLHttpRequest.STATE_OPENED;
};

MockXMLHttpRequest.prototype.setRequestHeader = function(name, value) {
  this._requestHeaders[name] = value;
};

MockXMLHttpRequest.prototype.overrideMimeType = function(mime) {
  throw notImplementedError;
};

MockXMLHttpRequest.prototype.send = function(data) {
  var self = this;
  this.data = data;

  self.readyState = MockXMLHttpRequest.STATE_LOADING;

  self._sendTimeout = setTimeout(function() {

    var response = MockXMLHttpRequest.handle(new MockRequest(self));

    if (response && response instanceof MockResponse) {

      var timeout = response.timeout();

      if (timeout) {

        //trigger a timeout event because the request timed out - wait for the timeout time because many libs like jquery and superagent use setTimeout to detect the error type
        self._sendTimeout = setTimeout(function() {
          self.readyState = MockXMLHttpRequest.STATE_DONE;
          self.trigger('timeout');
        }, typeof(timeout) === 'number' ? timeout : self.timeout+1);

      } else {

        //map the response to the XHR object
        self.status             = response.status();
        self._responseHeaders   = response.headers();
        self.responseType       = 'text';
        self.response           = response.body();
        self.responseText       = response.body(); //TODO: detect an object and return JSON, detect XML and return XML
        self.readyState         = MockXMLHttpRequest.STATE_DONE;

        //trigger a load event because the request was received
        self.trigger('load');

      }

    } else {

      //trigger an error because the request was not handled
      self.readyState = MockXMLHttpRequest.STATE_DONE;
      self.trigger('error');

    }

  }, 0);

};

MockXMLHttpRequest.prototype.abort = function() {
  clearTimeout(this._sendTimeout);

  if (this.readyState > MockXMLHttpRequest.STATE_UNSENT && this.readyState < MockXMLHttpRequest.STATE_DONE) {
    this.readyState = MockXMLHttpRequest.STATE_UNSENT;
    this.trigger('abort');
  }

};

MockXMLHttpRequest.prototype.getAllResponseHeaders = function() {

  if (this.readyState < MockXMLHttpRequest.STATE_HEADERS_RECEIVED) {
    return null;
  }

  var headers = '';
  for (var name in this._responseHeaders) {
    if (this._responseHeaders.hasOwnProperty(name)) {
      headers += name+': '+this._responseHeaders[name]+'\r\n';
    }
  }

  return headers;
};

MockXMLHttpRequest.prototype.getResponseHeader = function(name) {

  if (this.readyState < MockXMLHttpRequest.STATE_HEADERS_RECEIVED) {
    return null;
  }

  return this._responseHeaders[name.toLowerCase()] || null;
};

MockXMLHttpRequest.prototype.addEventListener = function(event, listener) {
  this._eventListeners.push({
    event: event,
    listener: listener
  });
};

MockXMLHttpRequest.prototype.removeEventListener = function(event, listener) {
  var currentIndex = 0;

  while (currentIndex < this._eventListeners.length) {
    var eventListener = this._eventListeners[currentIndex];
    if (eventListener.event === event && eventListener.listener === listener) {
      this._eventListeners.splice(currentIndex, 1);
    } else {
      currentIndex++;
    }
  }
};

module.exports = MockXMLHttpRequest;

},{"./MockRequest":100,"./MockResponse":101}],103:[function(require,module,exports){
"use strict";
var window = require("global/window")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data || null
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.status === 204 && xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}

},{"global/window":7,"is-function":27,"parse-headers":38,"xtend":104}],104:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var isBasicProperty = function isBasicProperty(predicateObjectMap) {
  return ["text", "select", "multiselect", "datable", "names", "sameAs"].indexOf(predicateObjectMap.propertyType) > -1;
};

var columnMapIsComplete = function columnMapIsComplete(predicateObjectMap) {
  return predicateObjectMap.objectMap && typeof predicateObjectMap.objectMap.column !== "undefined" && predicateObjectMap.objectMap.column !== null;
};

var joinConditionMapIsComplete = function joinConditionMapIsComplete(predicateObjectMap) {
  return predicateObjectMap.objectMap && predicateObjectMap.objectMap.parentTriplesMap && predicateObjectMap.objectMap.joinCondition && typeof predicateObjectMap.objectMap.joinCondition.parent !== "undefined" && typeof predicateObjectMap.objectMap.joinCondition.child !== "undefined";
};

var propertyMappingIsComplete = function propertyMappingIsComplete(predicateObjectMap) {
  if (typeof predicateObjectMap === "undefined") {
    return false;
  }

  if (isBasicProperty(predicateObjectMap)) {
    return columnMapIsComplete(predicateObjectMap);
  }

  if (predicateObjectMap.propertyType === "relation") {
    return joinConditionMapIsComplete(predicateObjectMap);
  }

  return false;
};

var getColumnValue = function getColumnValue(predicateObjectMap) {
  if (!predicateObjectMap) {
    return null;
  }

  if (isBasicProperty(predicateObjectMap)) {
    return predicateObjectMap.objectMap && predicateObjectMap.objectMap.column ? predicateObjectMap.objectMap.column : null;
  }

  if (predicateObjectMap.propertyType === "relation") {
    return predicateObjectMap.objectMap && predicateObjectMap.objectMap.joinCondition && predicateObjectMap.objectMap.joinCondition.child ? predicateObjectMap.objectMap.joinCondition.child : null;
  }

  return null;
};

exports.propertyMappingIsComplete = propertyMappingIsComplete;
exports.isBasicProperty = isBasicProperty;
exports.getColumnValue = getColumnValue;

},{}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = actionsMaker;

var _upload = require("./actions/upload");

var _fetchBulkuploadedMetadata = require("./actions/fetch-bulkuploaded-metadata");

var _selectCollection = require("./actions/select-collection");

var _predicateObjectMappings = require("./actions/predicate-object-mappings");

var _publishMappings = require("./actions/publish-mappings");

var _deleteVre = require("./actions/delete-vre");

function actionsMaker(navigateTo, dispatch) {
  return {

    // loading import data
    onUploadFileSelect: (0, _upload.onUploadFileSelect)(navigateTo, dispatch),

    onClearFormSettingData: function onClearFormSettingData() {
      return dispatch({ type: "CLEAR_DATASET_SETTINGS" });
    },
    onSetNewVreName: function onSetNewVreName(value) {
      return dispatch({ type: "SET_NEW_VRE_NAME", newVreName: value });
    },
    onSetNewDescription: function onSetNewDescription(value) {
      return dispatch({ type: "SET_DESCRIPTION", description: value });
    },
    onSetNewProvenance: function onSetNewProvenance(value) {
      return dispatch({ type: "SET_PROVENANCE", provenance: value });
    },
    onSetNewColorCode: function onSetNewColorCode(value) {
      return dispatch({ type: "SET_COLOR_CODE", colorCode: value });
    },
    onUploadImage: function onUploadImage(vreId, files) {
      return dispatch((0, _upload.uploadImage)(vreId, files));
    },
    onCloseImageError: function onCloseImageError() {
      return dispatch({ type: "DISMISS_IMAGE_ERROR" });
    },
    onSaveVreSettings: function onSaveVreSettings(vreId) {
      var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
      return dispatch((0, _upload.saveDatasetSettings)(vreId, next));
    },

    // Fetching raw data
    onSelectCollection: function onSelectCollection(collection) {
      return dispatch((0, _selectCollection.selectCollection)(collection));
    },

    onLoadMoreClick: function onLoadMoreClick(nextUrl, collection) {
      return dispatch((0, _selectCollection.selectCollection)(collection, nextUrl));
    },

    onFetchBulkUploadedMetadata: function onFetchBulkUploadedMetadata(vreId) {
      return dispatch((0, _fetchBulkuploadedMetadata.fetchBulkUploadedMetadata)(vreId));
    },

    // Closing informative messages
    onCloseMessage: function onCloseMessage(messageId) {
      return dispatch({ type: "TOGGLE_MESSAGE", messageId: messageId });
    },

    // Deleting own vres
    onDeleteVreClick: function onDeleteVreClick(vreId) {
      return dispatch({ type: "SHOW_DELETE_VRE_MODAL", vreId: vreId });
    },

    onComfirmDeleteVre: function onComfirmDeleteVre(vreId, userConfirmationInputValue) {
      return dispatch((0, _deleteVre.deleteVre)(vreId, userConfirmationInputValue));
    },

    // Mapping collections archetypes
    onMapCollectionArchetype: function onMapCollectionArchetype(collection, value) {
      return dispatch({ type: "MAP_COLLECTION_ARCHETYPE", collection: collection, value: value });
    },

    // Connecting data
    onContinueMapping: function onContinueMapping(vreId) {
      return dispatch((0, _fetchBulkuploadedMetadata.fetchBulkUploadedMetadata)(vreId, navigateTo));
    },

    onAddPredicateObjectMap: function onAddPredicateObjectMap(predicateName, objectName, propertyType) {
      return dispatch((0, _predicateObjectMappings.addPredicateObjectMap)(predicateName, objectName, propertyType));
    },

    onRemovePredicateObjectMap: function onRemovePredicateObjectMap(predicateName, objectName) {
      return dispatch((0, _predicateObjectMappings.removePredicateObjectMap)(predicateName, objectName));
    },

    onAddCustomProperty: function onAddCustomProperty(name, type) {
      var sourceColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var targetColumn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      return dispatch((0, _predicateObjectMappings.addCustomProperty)(name, type, sourceColumn, targetColumn));
    },

    onRemoveCustomProperty: function onRemoveCustomProperty(index) {
      return dispatch((0, _predicateObjectMappings.removeCustomProperty)(index));
    },

    onSaveMappingState: function onSaveMappingState() {
      return dispatch((0, _publishMappings.saveMappingState)());
    },

    onSaveNewMappingState: function onSaveNewMappingState() {
      return dispatch((0, _publishMappings.saveNewMappingState)(navigateTo));
    },

    onPublishData: function onPublishData() {
      return dispatch((0, _publishMappings.publishMappings)(navigateTo));
    }
  };
}

},{"./actions/delete-vre":107,"./actions/fetch-bulkuploaded-metadata":108,"./actions/predicate-object-mappings":110,"./actions/publish-mappings":111,"./actions/select-collection":112,"./actions/upload":113}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteVre = undefined;

var _xhr = require("xhr");

var _xhr2 = _interopRequireDefault(_xhr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var deleteVre = function deleteVre(vreId, confirmedVreId) {
  return function (dispatch, getState) {

    if (vreId !== confirmedVreId) {
      return;
    }

    var _getState = getState(),
        userId = _getState.userdata.userId;

    dispatch({ type: "BEFORE_DELETE_VRE", vreId: confirmedVreId });

    (0, _xhr2.default)({
      uri: "" + "/v2.1/bulk-upload/" + confirmedVreId,
      headers: {
        "Authorization": userId
      },
      method: "DELETE"
    }, function (err, resp, body) {
      if (err) {
        dispatch({ type: "DELETE_VRE_ERROR", err: err, vreId: confirmedVreId });
      } else {
        if (resp.statusCode == 200) {
          dispatch({ type: "DELETE_VRE_SUCCESS", vreId: confirmedVreId });
        } else {
          dispatch({ type: "DELETE_VRE_ERROR", vreId: confirmedVreId });
        }
      }
      dispatch({ type: "DELETE_VRE_DONE", vreId: confirmedVreId });
    });
  };
};

exports.deleteVre = deleteVre;

},{"xhr":103}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchBulkUploadedMetadata = undefined;

var _xhr = require("xhr");

var _xhr2 = _interopRequireDefault(_xhr);

var _selectCollection = require("./select-collection");

var _predicateObjectMappings = require("./predicate-object-mappings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fetchBulkUploadedMetadata = function fetchBulkUploadedMetadata(vreId, navigateTo) {
  return function (dispatch, getState) {
    var location = "" + "/v2.1/bulk-upload/" + vreId;
    _xhr2.default.get(location, { headers: { "Authorization": getState().userdata.userId } }, function (err, resp, body) {
      var responseData = JSON.parse(body);
      dispatch({ type: "FINISH_UPLOAD", data: responseData });

      if (responseData.collections && responseData.collections.length) {
        dispatch((0, _selectCollection.selectCollection)(responseData.collections[0].name));
      }

      if (responseData.savedMappingState) {
        dispatch((0, _predicateObjectMappings.deserializeSavedRmlMapping)(responseData.savedMappingState));
      }

      if (navigateTo) {
        if (responseData.savedMappingState) {
          navigateTo("mapData", [vreId]);
        } else {
          navigateTo("mapArchetypes", [vreId]);
        }
      }
    });
  };
};

exports.fetchBulkUploadedMetadata = fetchBulkUploadedMetadata;

},{"./predicate-object-mappings":110,"./select-collection":112,"xhr":103}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchMyVres = undefined;

var _xhr = require("xhr");

var _xhr2 = _interopRequireDefault(_xhr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fetchMyVres = function fetchMyVres(token, callback) {
  return function (dispatch) {
    (0, _xhr2.default)("" + "/v2.1/system/users/me/vres", {
      headers: {
        "Authorization": token
      }
    }, function (err, resp, body) {
      var vreData = JSON.parse(body);
      dispatch({ type: "RECEIVE_MY_VRES", data: token, vreData: vreData });
      callback(vreData);
    });
  };
};

exports.fetchMyVres = fetchMyVres;

},{"xhr":103}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deserializeSavedRmlMapping = exports.removeCustomProperty = exports.addCustomProperty = exports.removePredicateObjectMap = exports.addPredicateObjectMap = undefined;

var _propertyMappings = require("../accessors/property-mappings");

var _generateRmlMapping = require("../util/generate-rml-mapping");

var _addPredicateObjectMap = function _addPredicateObjectMap(subjectCollection, predicate, object, propertyType) {
  return function (dispatch) {
    dispatch({
      type: "SET_PREDICATE_OBJECT_MAPPING",
      subjectCollection: subjectCollection,
      predicate: predicate,
      object: object,
      propertyType: propertyType
    });
  };
};

var addPredicateObjectMap = function addPredicateObjectMap(predicate, object, propertyType) {
  return function (dispatch, getState) {
    var _getState = getState(),
        subjectCollection = _getState.activeCollection.name;

    dispatch(_addPredicateObjectMap(subjectCollection, predicate, object, propertyType));
  };
};

var removePredicateObjectMap = function removePredicateObjectMap(predicate, object) {
  return function (dispatch, getState) {
    var _getState2 = getState(),
        subjectCollection = _getState2.activeCollection.name;

    dispatch({
      type: "REMOVE_PREDICATE_OBJECT_MAPPING",
      subjectCollection: subjectCollection,
      predicate: predicate,
      object: object
    });
  };
};

var _addCustomProperty = function _addCustomProperty(collectionName, name, type) {
  var sourceColumn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var targetColumn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  return function (dispatch) {
    dispatch({
      type: "ADD_CUSTOM_PROPERTY",
      collection: collectionName,
      propertyName: name,
      propertyType: type
    });

    if (type === "relation" && sourceColumn && targetColumn) {
      dispatch({
        type: "SET_PREDICATE_OBJECT_MAPPING",
        subjectCollection: collectionName,
        predicate: name,
        object: {
          joinCondition: {
            child: sourceColumn,
            parent: targetColumn.split("!")[1]
          },
          parentTriplesMap: targetColumn.split("!")[0]
        },
        propertyType: "relation"
      });
    }
  };
};

var addCustomProperty = function addCustomProperty(name, type, sourceColumn, targetColumn) {
  return function (dispatch, getState) {
    var _getState3 = getState(),
        collectionName = _getState3.activeCollection.name;

    dispatch(_addCustomProperty(collectionName, name, type, sourceColumn, targetColumn));
  };
};

var removeCustomProperty = function removeCustomProperty(index) {
  return function (dispatch, getState) {
    var _getState4 = getState(),
        collectionName = _getState4.activeCollection.name,
        allPredicateObjectMappings = _getState4.predicateObjectMappings,
        customProperties = _getState4.customProperties;

    var predicateObjectMappings = allPredicateObjectMappings[collectionName] || [];
    var customProperty = customProperties[collectionName][index];

    var predicateObjectMapping = predicateObjectMappings.find(function (pom) {
      return pom.predicate === customProperty.propertyName;
    });

    if (predicateObjectMapping) {
      dispatch({
        type: "REMOVE_PREDICATE_OBJECT_MAPPING",
        subjectCollection: collectionName,
        predicate: customProperty.propertyName,
        object: (0, _propertyMappings.getColumnValue)(predicateObjectMapping)
      });
    }
    dispatch({
      type: "REMOVE_CUSTOM_PROPERTY",
      collection: collectionName,
      index: index
    });
  };
};

var stripNamespace = function stripNamespace(uri) {
  var nsList = Object.keys(_generateRmlMapping.nameSpaces).map(function (k) {
    return _generateRmlMapping.nameSpaces[k];
  }).concat(_generateRmlMapping.defaultNamespace);
  for (var i in nsList) {
    if (uri.indexOf(nsList[i]) > -1) {
      return uri.replace(nsList[i], "");
    }
  }
  return null;
};

var getPropertyType = function getPropertyType(predicate, knownProperties) {
  if (_generateRmlMapping.nameSpaces[predicate] === "http://www.tei-c.org/ns/1.0/") {
    return "names";
  }
  var knownProperty = knownProperties.find(function (prop) {
    return prop.name === predicate;
  });

  if (knownProperty) {
    return knownProperty.type;
  }
  return "text";
};

var deserializeSavedRmlMapping = function deserializeSavedRmlMapping(savedMappings) {
  return function (dispatch, getState) {
    var graph = savedMappings["@graph"];

    var _getState5 = getState(),
        archetypeProperties = _getState5.archetype;

    var _loop = function _loop(i) {
      var collectionMapping = graph[i];
      var collectionName = collectionMapping["rml:logicalSource"]["rml:source"]["tim:rawCollection"];
      var archetypeName = stripNamespace(collectionMapping["http://www.w3.org/2000/01/rdf-schema#subClassOf"]) + "s";

      dispatch({ type: "MAP_COLLECTION_ARCHETYPE", collection: collectionName, value: archetypeName });

      var knownProperties = archetypeProperties[archetypeName].filter(function (prop) {
        return prop.type !== "relation";
      }).concat({ name: "sameAs", type: "sameAs" });

      collectionMapping.predicateObjectMap.forEach(function (predicateObjectMapping) {
        if (typeof predicateObjectMapping.objectMap === "undefined") {
          return;
        }
        var predicate = stripNamespace(predicateObjectMapping.predicate);
        var objectMap = predicateObjectMapping.objectMap;


        if (objectMap.column) {
          dispatch(_addPredicateObjectMap(collectionName, predicate, objectMap.column, getPropertyType(predicate, knownProperties)));

          if (getPropertyType(predicate, knownProperties) !== "names" && knownProperties.map(function (prop) {
            return prop.name;
          }).indexOf(predicate) < 0) {
            dispatch(_addCustomProperty(collectionName, predicate, "text"));
          }
        } else if (objectMap.joinCondition && objectMap.parentTriplesMap) {
          var targetCollection = stripNamespace(objectMap.parentTriplesMap).replace(/.+\//, "");
          dispatch(_addCustomProperty(collectionName, predicate, "relation", objectMap.joinCondition.child, targetCollection + "!" + objectMap.joinCondition.parent));
        }
      });
    };

    for (var i in graph) {
      _loop(i);
    }
  };
};

exports.addPredicateObjectMap = addPredicateObjectMap;
exports.removePredicateObjectMap = removePredicateObjectMap;
exports.addCustomProperty = addCustomProperty;
exports.removeCustomProperty = removeCustomProperty;
exports.deserializeSavedRmlMapping = deserializeSavedRmlMapping;

},{"../accessors/property-mappings":105,"../util/generate-rml-mapping":166}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveNewMappingState = exports.saveMappingState = exports.publishMappings = undefined;

var _generateRmlMapping = require("../util/generate-rml-mapping");

var _generateRmlMapping2 = _interopRequireDefault(_generateRmlMapping);

var _fetchMyVres = require("./fetch-my-vres");

var _xhr = require("xhr");

var _xhr2 = _interopRequireDefault(_xhr);

var _selectCollection = require("./select-collection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var saveMappingState = function saveMappingState() {
  var navigateTo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var redirectTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (dispatch, getState) {
    var _getState = getState(),
        _getState$importData = _getState.importData,
        vre = _getState$importData.vre,
        saveMappingUrl = _getState$importData.saveMappingUrl,
        collections = _getState.mappings.collections,
        userId = _getState.userdata.userId,
        predicateObjectMappings = _getState.predicateObjectMappings;

    var jsonLd = (0, _generateRmlMapping2.default)(vre, collections, predicateObjectMappings);
    dispatch({ type: "SAVE_MAPPING_START" });
    (0, _xhr2.default)({
      url: saveMappingUrl,
      method: "POST",
      headers: {
        "Authorization": userId,
        "Content-type": "application/ld+json"
      },
      data: JSON.stringify(jsonLd)
    }, function (err, resp, body) {
      if (err) {
        dispatch({ type: "SAVE_HAD_ERROR" });
      } else {
        dispatch({ type: "SAVE_SUCCEEDED" });
        if (redirectTo) {
          navigateTo(redirectTo, [vre, "asd"]);
        }
      }
      dispatch({ type: "SAVE_FINISHED" });
    });
  };
};

var publishMappings = function publishMappings(navigateTo) {
  return function (dispatch, getState) {
    var _getState2 = getState(),
        _getState2$importData = _getState2.importData,
        vre = _getState2$importData.vre,
        executeMappingUrl = _getState2$importData.executeMappingUrl,
        collections = _getState2.mappings.collections,
        userId = _getState2.userdata.userId,
        predicateObjectMappings = _getState2.predicateObjectMappings,
        activeCollection = _getState2.activeCollection;

    var jsonLd = (0, _generateRmlMapping2.default)(vre, collections, predicateObjectMappings);

    console.log(JSON.stringify(jsonLd, null, 2));

    dispatch(saveMappingState());
    dispatch({ type: "PUBLISH_START" });
    var req = new XMLHttpRequest();
    req.open("POST", executeMappingUrl);
    req.setRequestHeader("Authorization", userId);
    req.setRequestHeader("Content-type", "application/ld+json");

    var pos = 0;
    req.onreadystatechange = function handleData() {
      if (req.readyState != null && (req.readyState < 3 || req.status != 200)) {
        return;
      }
      var newPart = req.responseText.substr(pos);
      pos = req.responseText.length;
      newPart.split("\n").forEach(function (line, idx) {
        if (idx % 125 === 0 && line.length > 0) {
          dispatch({ type: "PUBLISH_STATUS_UPDATE", data: line });
        }
      });
    };
    req.onload = function () {
      var parts = req.responseText.split("\n");
      if (parts[parts.length - 1] === "success") {
        dispatch({ type: "PUBLISH_SUCCEEDED" });
        dispatch((0, _fetchMyVres.fetchMyVres)(userId, function () {
          return navigateTo("root");
        }));
        _xhr2.default.get("" + "/v2.1/system/vres", function (err, resp, body) {
          dispatch({ type: "SET_PUBLIC_VRES", payload: JSON.parse(body) });
        });
      } else {
        dispatch({ type: "PUBLISH_HAD_ERROR" });
        dispatch((0, _selectCollection.selectCollection)(activeCollection.name, null, true));
      }

      dispatch({ type: "PUBLISH_FINISHED" });
    };
    req.send(JSON.stringify(jsonLd));
  };
};

var saveNewMappingState = function saveNewMappingState(navigateTo) {
  return function (dispatch) {
    dispatch({ type: "CLEAR_PREDICATE_OBJECT_MAPPINGS" });

    dispatch(saveMappingState(navigateTo, "mapData"));
  };
};

exports.publishMappings = publishMappings;
exports.saveMappingState = saveMappingState;
exports.saveNewMappingState = saveNewMappingState;

},{"../util/generate-rml-mapping":166,"./fetch-my-vres":109,"./select-collection":112,"xhr":103}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectCollection = undefined;

var _xhr = require("xhr");

var _xhr2 = _interopRequireDefault(_xhr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var selectCollection = function selectCollection(collection) {
  var altUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var onlyErrors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return function (dispatch, getState) {
    var _getState = getState(),
        collections = _getState.importData.collections,
        userId = _getState.userdata.userId;

    var selectedCollection = collections.find(function (col) {
      return col.name === collection;
    });

    if (userId && collections && selectedCollection && selectedCollection.dataUrl) {
      dispatch({ type: "ACTIVE_COLLECTION_PENDING" });
      _xhr2.default.get((altUrl || selectedCollection.dataUrl) + (onlyErrors ? "?onlyErrors=true" : ""), {
        headers: { "Authorization": userId }
      }, function (err, resp, body) {
        if (err) {
          dispatch({ type: "ACTIVE_COLLECTION_FETCH_ERROR", collection: collection, error: err });
        } else {
          try {
            dispatch({ type: "RECEIVE_ACTIVE_COLLECTION", collection: collection, data: JSON.parse(body) });
          } catch (e) {
            dispatch({ type: "ACTIVE_COLLECTION_FETCH_ERROR", collection: collection, error: e });
          }
        }
        dispatch({ type: "ACTIVE_COLLECTION_DONE" });
      });
    }
  };
};

exports.selectCollection = selectCollection;

},{"xhr":103}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uploadImage = exports.saveDatasetSettings = exports.onUploadFileSelect = undefined;

var _xhr = require("xhr");

var _xhr2 = _interopRequireDefault(_xhr);

var _selectCollection = require("./select-collection");

var _fetchMyVres = require("./fetch-my-vres");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var onUploadFileSelect = function onUploadFileSelect(navigateTo, dispatch) {
  return function (files, _ref) {
    var vreName = _ref.vreName,
        vreId = _ref.vreId,
        redirectTo = _ref.redirectTo;


    var file = files[0];
    var formData = new FormData();
    if (!vreId && vreName) {
      // Set a name on first upload
      formData.append("vreName", vreName);
    } else if (vreId) {
      // This is a reupload
      formData.append("vreId", vreId);
    }
    formData.append("file", file);

    dispatch({ type: "START_UPLOAD", uploadedFileName: file.name });
    dispatch(function (dispatch, getState) {
      var state = getState();
      var req = new XMLHttpRequest();
      if (vreId) {
        // This is a re-upload of the data
        req.open('PUT', "" + "/v2.1/bulk-upload", true);
      } else {
        req.open('POST', "" + "/v2.1/bulk-upload", true);
      }
      req.setRequestHeader("Authorization", state.userdata.userId);
      var pos = 0;
      var isRedirectedToSettings = false;
      req.onreadystatechange = function handleData() {
        if (!isRedirectedToSettings) {
          isRedirectedToSettings = true;
          dispatch((0, _fetchMyVres.fetchMyVres)(state.userdata.userId, function (vreData) {
            if (vreId) {
              navigateTo(redirectTo || "editDataset", [vreId]);
            } else if (vreName) {
              var vreIdFromLabel = Object.keys(vreData.mine).map(function (key) {
                return vreData.mine[key];
              }).find(function (vre) {
                return vre.label === vreName;
              }).name;
              navigateTo(redirectTo || "editDataset", [vreIdFromLabel]);
            }
          }));
        }
        if (req.readyState != null && (req.readyState < 3 || req.status != 200)) {
          return;
        }
        var newPart = req.responseText.substr(pos);
        pos = req.responseText.length;
        newPart.split("\n").forEach(function (line, idx) {
          if (idx % 21 === 0) {
            dispatch({ type: "UPLOAD_STATUS_UPDATE", data: line });
          }
        });
      };

      req.onload = function () {
        var location = req.getResponseHeader("location");
        _xhr2.default.get(location, { headers: { "Authorization": state.userdata.userId } }, function (err, resp, body) {
          var responseData = JSON.parse(body);
          dispatch({ type: "FINISH_UPLOAD", data: responseData, uploadedFileName: file.name });
          dispatch((0, _fetchMyVres.fetchMyVres)(state.userdata.userId, function () {}));
          _xhr2.default.get("" + "/v2.1/system/vres", function (err, resp, body) {
            dispatch({ type: "SET_PUBLIC_VRES", payload: JSON.parse(body) });
          });
          if (responseData.collections && responseData.collections.length) {
            dispatch((0, _selectCollection.selectCollection)(responseData.collections[0].name));
          }
        });
      };
      req.send(formData);
    });
  };
};

var uploadImage = function uploadImage(vreId, files) {
  return function (dispatch, getState) {
    var _getState = getState(),
        userId = _getState.userdata.userId;

    var file = files[0];
    var formData = new FormData();
    var req = new XMLHttpRequest();

    formData.append("file", file);

    req.open('POST', "" + "/v2.1/bulk-upload/" + vreId + "/image", true);
    req.setRequestHeader("Authorization", userId);
    dispatch({ type: "IMAGE_UPLOAD_STARTED" });
    req.onload = function () {
      if (this.status >= 300 || this.status < 200) {
        dispatch({ type: "IMAGE_UPLOAD_ERROR", message: this.responseText });
      } else {
        dispatch({ type: "IMAGE_UPLOAD_SUCCESS" });
        dispatch((0, _fetchMyVres.fetchMyVres)(userId, function () {}));
        _xhr2.default.get("" + "/v2.1/system/vres", function (err, resp, body) {
          dispatch({ type: "SET_PUBLIC_VRES", payload: JSON.parse(body) });
        });
      }
      dispatch({ type: "IMAGE_UPLOAD_FINISHED" });
    };

    req.send(formData);
  };
};

var saveDatasetSettings = function saveDatasetSettings(vreId) {
  var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
  return function (dispatch, getState) {
    var _getState2 = getState(),
        datasetSettings = _getState2.datasetSettings,
        userId = _getState2.userdata.userId;

    (0, _xhr2.default)({
      url: "" + "/v2.1/bulk-upload/" + vreId,
      method: "PUT",
      headers: {
        "Content-type": "application/json",
        "Authorization": userId
      },
      data: JSON.stringify({
        label: datasetSettings.newVreName,
        provenance: datasetSettings.provenance,
        colorCode: datasetSettings.colorCode,
        description: datasetSettings.description
      })
    }, function (err, resp, body) {
      dispatch((0, _fetchMyVres.fetchMyVres)(userId, function () {}));
      _xhr2.default.get("" + "/v2.1/system/vres", function (err, resp, body) {
        dispatch({ type: "SET_PUBLIC_VRES", payload: JSON.parse(body) });
      });
      next();
    });
  };
};

exports.onUploadFileSelect = onUploadFileSelect;
exports.saveDatasetSettings = saveDatasetSettings;
exports.uploadImage = uploadImage;

},{"./fetch-my-vres":109,"./select-collection":112,"xhr":103}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _selectField = require("../fields/select-field");

var _selectField2 = _interopRequireDefault(_selectField);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AddProperty = function (_React$Component) {
  _inherits(AddProperty, _React$Component);

  function AddProperty(props) {
    _classCallCheck(this, AddProperty);

    var _this = _possibleConstructorReturn(this, (AddProperty.__proto__ || Object.getPrototypeOf(AddProperty)).call(this, props));

    _this.state = {
      newName: "",
      newType: null
    };
    return _this;
  }

  _createClass(AddProperty, [{
    key: "onEnter",
    value: function onEnter(newName, newType) {
      if (newType !== null) {
        this.setState({ newName: null, newType: null });
        this.props.onAddCustomProperty(newName, newType);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _state = this.state,
          newName = _state.newName,
          newType = _state.newType;
      var onAddCustomProperty = this.props.onAddCustomProperty;


      return _react2.default.createElement(
        "div",
        { className: "row small-margin" },
        _react2.default.createElement(
          "div",
          { className: "col-sm-2 pad-6-12" },
          _react2.default.createElement(
            "strong",
            null,
            "Add a new property"
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-6" },
          _react2.default.createElement(
            "span",
            null,
            _react2.default.createElement(
              _selectField2.default,
              {
                value: newType,
                onChange: function onChange(value) {
                  return _this2.setState({ newType: value, newName: newName });
                },
                onClear: function onClear() {
                  return _this2.setState({ newType: null });
                } },
              _react2.default.createElement(
                "span",
                { type: "placeholder" },
                "Choose a type..."
              ),
              _react2.default.createElement(
                "span",
                { value: "text" },
                "Text"
              ),
              _react2.default.createElement(
                "span",
                { value: "datable" },
                "Datable"
              )
            )
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-2" },
          _react2.default.createElement("input", { className: "form-control",
            onChange: function onChange(ev) {
              return _this2.setState({ newName: ev.target.value });
            },
            onKeyPress: function onKeyPress(ev) {
              return ev.key === "Enter" ? _this2.onEnter(newName, newType) : false;
            },
            placeholder: "Property name",
            value: newName })
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-2" },
          _react2.default.createElement(
            "button",
            { className: "pull-right btn btn-default", disabled: !(newName && newType),
              onClick: function onClick() {
                _this2.setState({ newName: null, newType: null });
                onAddCustomProperty(newName, newType);
              } },
            "Add property"
          )
        )
      );
    }
  }]);

  return AddProperty;
}(_react2.default.Component);

exports.default = AddProperty;

},{"../fields/select-field":131,"react":"react"}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _selectField = require("../fields/select-field");

var _selectField2 = _interopRequireDefault(_selectField);

var _columnSelect = require("./column-select");

var _columnSelect2 = _interopRequireDefault(_columnSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AddRelation = function (_React$Component) {
  _inherits(AddRelation, _React$Component);

  function AddRelation(props) {
    _classCallCheck(this, AddRelation);

    var _this = _possibleConstructorReturn(this, (AddRelation.__proto__ || Object.getPrototypeOf(AddRelation)).call(this, props));

    _this.state = {
      newRelation: null,
      selectedSourceColumn: null,
      selectedTargetColumn: null
    };
    return _this;
  }

  _createClass(AddRelation, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _state = this.state,
          newRelation = _state.newRelation,
          selectedSourceColumn = _state.selectedSourceColumn,
          selectedTargetColumn = _state.selectedTargetColumn;
      var _props = this.props,
          onAddCustomProperty = _props.onAddCustomProperty,
          archetypeFields = _props.archetypeFields,
          availableArchetypes = _props.availableArchetypes,
          columns = _props.columns,
          availableCollectionColumnsPerArchetype = _props.availableCollectionColumnsPerArchetype;


      var relationTypeOptions = archetypeFields.filter(function (prop) {
        return prop.type === "relation";
      }).filter(function (prop) {
        return availableArchetypes.indexOf(prop.relation.targetCollection) > -1;
      }).map(function (prop) {
        return _react2.default.createElement(
          "span",
          { key: prop.name, value: prop.name },
          prop.name
        );
      });

      var relationTypeInfo = newRelation ? archetypeFields.find(function (af) {
        return af.name === newRelation;
      }) : null;

      var targetCollectionColumns = relationTypeInfo ? availableCollectionColumnsPerArchetype[relationTypeInfo.relation.targetCollection].map(function (targetCollectionCols) {
        return targetCollectionCols.columns.map(function (column) {
          return targetCollectionCols.collectionName + "!" + column;
        });
      }).reduce(function (a, b) {
        return a.concat(b);
      }) : null;

      var targetColumnSelect = targetCollectionColumns ? _react2.default.createElement(_columnSelect2.default, { columns: targetCollectionColumns, selectedColumn: selectedTargetColumn,
        valuePrefix: "(target) ",
        placeholder: "Select a target column...",
        onClearColumn: function onClearColumn() {
          return _this2.setState({ selectedTargetColumn: null });
        },
        onColumnSelect: function onColumnSelect(column) {
          return _this2.setState({ selectedTargetColumn: column });
        } }) : null;

      return _react2.default.createElement(
        "div",
        { className: "row small-margin" },
        _react2.default.createElement(
          "div",
          { className: "col-sm-2 pad-6-12" },
          _react2.default.createElement(
            "strong",
            null,
            "Add a relation"
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-3" },
          _react2.default.createElement(_columnSelect2.default, { columns: columns, selectedColumn: selectedSourceColumn,
            valuePrefix: "(source) ",
            placeholder: "Select a source column...",
            onClearColumn: function onClearColumn() {
              return _this2.setState({ selectedSourceColumn: null });
            },
            onColumnSelect: function onColumnSelect(column) {
              return _this2.setState({ selectedSourceColumn: column });
            } })
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-3" },
          _react2.default.createElement(
            _selectField2.default,
            {
              value: newRelation,
              onChange: function onChange(value) {
                return _this2.setState({ newRelation: value });
              },
              onClear: function onClear() {
                return _this2.setState({ newRelation: null });
              } },
            _react2.default.createElement(
              "span",
              { type: "placeholder" },
              "Choose a relation type..."
            ),
            relationTypeOptions
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-3" },
          targetColumnSelect
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-1" },
          _react2.default.createElement(
            "button",
            { className: "pull-right btn btn-default", disabled: !(newRelation && selectedSourceColumn && selectedTargetColumn),
              onClick: function onClick() {
                _this2.setState({ newRelation: null, selectedSourceColumn: null, selectedTargetColumn: null });
                onAddCustomProperty(newRelation, "relation", selectedSourceColumn, selectedTargetColumn);
              } },
            "Add relation"
          )
        )
      );
    }
  }]);

  return AddRelation;
}(_react2.default.Component);

exports.default = AddRelation;

},{"../fields/select-field":131,"./column-select":117,"react":"react"}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propertyForm = require("./property-form");

var _propertyForm2 = _interopRequireDefault(_propertyForm);

var _addProperty = require("./add-property");

var _addProperty2 = _interopRequireDefault(_addProperty);

var _addRelation = require("./add-relation");

var _addRelation2 = _interopRequireDefault(_addRelation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CollectionForm = function (_React$Component) {
  _inherits(CollectionForm, _React$Component);

  function CollectionForm() {
    _classCallCheck(this, CollectionForm);

    return _possibleConstructorReturn(this, (CollectionForm.__proto__ || Object.getPrototypeOf(CollectionForm)).apply(this, arguments));
  }

  _createClass(CollectionForm, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          onAddPredicateObjectMap = _props.onAddPredicateObjectMap,
          onRemovePredicateObjectMap = _props.onRemovePredicateObjectMap,
          onAddCustomProperty = _props.onAddCustomProperty,
          onRemoveCustomProperty = _props.onRemoveCustomProperty;
      var _props2 = this.props,
          archetypeFields = _props2.archetypeFields,
          availableArchetypes = _props2.availableArchetypes,
          columns = _props2.columns,
          availableCollectionColumnsPerArchetype = _props2.availableCollectionColumnsPerArchetype,
          targetableVres = _props2.targetableVres;


      if (!columns) {
        return null;
      }
      var _props3 = this.props,
          predicateObjectMappings = _props3.predicateObjectMappings,
          customProperties = _props3.customProperties;


      var archeTypePropFields = archetypeFields.filter(function (af) {
        return af.type !== "relation";
      });

      var propertyForms = archeTypePropFields.map(function (af, i) {
        return _react2.default.createElement(_propertyForm2.default, { key: i, name: af.name, type: af.type, custom: false,
          columns: columns,
          predicateObjectMap: predicateObjectMappings.find(function (pom) {
            return pom.predicate === af.name;
          }),
          predicateObjectMappings: predicateObjectMappings,
          onAddPredicateObjectMap: onAddPredicateObjectMap,
          onRemovePredicateObjectMap: onRemovePredicateObjectMap });
      });

      var customPropertyForms = customProperties.map(function (customProp, i) {
        return _react2.default.createElement(_propertyForm2.default, { key: i, name: customProp.propertyName, type: customProp.propertyType, custom: true, customIndex: i,
          columns: columns,
          predicateObjectMap: predicateObjectMappings.find(function (pom) {
            return pom.predicate === customProp.propertyName;
          }),
          predicateObjectMappings: predicateObjectMappings,
          onAddPredicateObjectMap: onAddPredicateObjectMap,
          onRemovePredicateObjectMap: onRemovePredicateObjectMap,
          onRemoveCustomProperty: onRemoveCustomProperty,
          availableCollectionColumnsPerArchetype: availableCollectionColumnsPerArchetype,
          relationTypeInfo: archetypeFields.find(function (af) {
            return af.name === customProp.propertyName;
          }),
          targetableVres: targetableVres
        });
      });
      return _react2.default.createElement(
        "div",
        { className: "container basic-margin" },
        _react2.default.createElement(_propertyForm2.default, { name: "sameAs", type: "sameAs", custom: false,
          columns: columns,
          predicateObjectMap: predicateObjectMappings.find(function (pom) {
            return pom.predicate === "sameAs";
          }),
          predicateObjectMappings: predicateObjectMappings,
          onAddPredicateObjectMap: onAddPredicateObjectMap,
          onRemovePredicateObjectMap: onRemovePredicateObjectMap
        }),
        propertyForms,
        customPropertyForms,
        _react2.default.createElement(_addProperty2.default, { onAddCustomProperty: onAddCustomProperty }),
        _react2.default.createElement(_addRelation2.default, {
          archetypeFields: archetypeFields,
          columns: columns,
          availableArchetypes: availableArchetypes,
          onAddCustomProperty: onAddCustomProperty,
          availableCollectionColumnsPerArchetype: availableCollectionColumnsPerArchetype

        })
      );
    }
  }]);

  return CollectionForm;
}(_react2.default.Component);

exports.default = CollectionForm;

},{"./add-property":114,"./add-relation":115,"./property-form":119,"react":"react"}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _selectField = require("../fields/select-field");

var _selectField2 = _interopRequireDefault(_selectField);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColumnSelect = function (_React$Component) {
  _inherits(ColumnSelect, _React$Component);

  function ColumnSelect() {
    _classCallCheck(this, ColumnSelect);

    return _possibleConstructorReturn(this, (ColumnSelect.__proto__ || Object.getPrototypeOf(ColumnSelect)).apply(this, arguments));
  }

  _createClass(ColumnSelect, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          columns = _props.columns,
          selectedColumn = _props.selectedColumn,
          onColumnSelect = _props.onColumnSelect,
          onClearColumn = _props.onClearColumn,
          placeholder = _props.placeholder,
          valuePrefix = _props.valuePrefix;


      return _react2.default.createElement(
        _selectField2.default,
        { value: selectedColumn, style: { display: "inline-block" },
          valuePrefix: valuePrefix,
          onChange: function onChange(column) {
            return onColumnSelect(column);
          },
          onClear: function onClear() {
            return onClearColumn(selectedColumn);
          } },
        _react2.default.createElement(
          "span",
          { type: "placeholder", className: "from-excel" },
          _react2.default.createElement("img", { src: "images/icon-excel.svg", alt: "" }),
          " ",
          placeholder || "Select an excel column"
        ),
        columns.map(function (column) {
          return _react2.default.createElement(
            "span",
            { key: column, value: column, className: "from-excel" },
            _react2.default.createElement("img", { src: "images/icon-excel.svg", alt: "" }),
            " ",
            valuePrefix && column === selectedColumn ? valuePrefix : "",
            column
          );
        })
      );
    }
  }]);

  return ColumnSelect;
}(_react2.default.Component);

exports.default = ColumnSelect;

},{"../fields/select-field":131,"react":"react"}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _columnSelect = require("./column-select");

var _columnSelect2 = _interopRequireDefault(_columnSelect);

var _camel2label = require("../../util/camel2label");

var _camel2label2 = _interopRequireDefault(_camel2label);

var _propertyMappings = require("../../accessors/property-mappings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var getObjectForPredicate = function getObjectForPredicate(predicateObjectMappings, predicate) {
  return predicateObjectMappings.filter(function (pom) {
    return pom.predicate === predicate;
  }).map(function (pom) {
    return (0, _propertyMappings.getColumnValue)(pom);
  })[0];
};

var NamesForm = function (_React$Component) {
  _inherits(NamesForm, _React$Component);

  function NamesForm() {
    _classCallCheck(this, NamesForm);

    return _possibleConstructorReturn(this, (NamesForm.__proto__ || Object.getPrototypeOf(NamesForm)).apply(this, arguments));
  }

  _createClass(NamesForm, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          columns = _props.columns,
          predicateObjectMappings = _props.predicateObjectMappings,
          _onColumnSelect = _props.onColumnSelect,
          _onClearColumn = _props.onClearColumn;


      var formRows = ["forename", "surname", "nameLink", "genName", "roleName"].map(function (predicate) {
        return _react2.default.createElement(
          "div",
          { key: predicate, className: "row" },
          _react2.default.createElement(
            "span",
            { style: { display: "inline-block", paddingLeft: "12px", width: "92px" } },
            (0, _camel2label2.default)(predicate)
          ),
          _react2.default.createElement(_columnSelect2.default, { columns: columns,
            selectedColumn: getObjectForPredicate(predicateObjectMappings, predicate),
            onColumnSelect: function onColumnSelect(value) {
              return _onColumnSelect(value, predicate);
            },
            onClearColumn: function onClearColumn(value) {
              return _onClearColumn(value, predicate);
            }
          })
        );
      });

      return _react2.default.createElement(
        "div",
        null,
        formRows
      );
    }
  }]);

  return NamesForm;
}(_react2.default.Component);

exports.default = NamesForm;

},{"../../accessors/property-mappings":105,"../../util/camel2label":163,"./column-select":117,"react":"react"}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _columnSelect = require("./column-select");

var _columnSelect2 = _interopRequireDefault(_columnSelect);

var _namesForm = require("./names-form");

var _namesForm2 = _interopRequireDefault(_namesForm);

var _relationForm = require("./relation-form");

var _relationForm2 = _interopRequireDefault(_relationForm);

var _propertyMappings = require("../../accessors/property-mappings");

var _camel2label = require("../../util/camel2label");

var _camel2label2 = _interopRequireDefault(_camel2label);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var typeMap = {
  text: function text(props) {
    return _react2.default.createElement(_columnSelect2.default, props);
  },
  datable: function datable(props) {
    return _react2.default.createElement(_columnSelect2.default, props);
  },
  select: function select(props) {
    return _react2.default.createElement(_columnSelect2.default, props);
  },
  sameAs: function sameAs(props) {
    return _react2.default.createElement(_columnSelect2.default, props);
  },
  names: function names(props) {
    return _react2.default.createElement(_namesForm2.default, props);
  },
  relation: function relation(props) {
    return _react2.default.createElement(_relationForm2.default, props);
  },
  "relation-to-existing": function relationToExisting(props) {
    return _react2.default.createElement(RelationToExistingForm, props);
  },
  multiselect: function multiselect(props) {
    return _react2.default.createElement(_columnSelect2.default, props);
  }
};

var isCompleteForNames = function isCompleteForNames(type, predicateObjectMappings) {
  return type === "names" && predicateObjectMappings.filter(function (pom) {
    return ["forename", "surname", "nameLink", "genName", "roleName"].indexOf(pom.predicate) > -1;
  }).filter(function (pom) {
    return (0, _propertyMappings.propertyMappingIsComplete)(pom);
  }).length > 0;
};

var PropertyForm = function (_React$Component) {
  _inherits(PropertyForm, _React$Component);

  function PropertyForm() {
    _classCallCheck(this, PropertyForm);

    return _possibleConstructorReturn(this, (PropertyForm.__proto__ || Object.getPrototypeOf(PropertyForm)).apply(this, arguments));
  }

  _createClass(PropertyForm, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          onAddPredicateObjectMap = _props.onAddPredicateObjectMap,
          onRemovePredicateObjectMap = _props.onRemovePredicateObjectMap,
          onRemoveCustomProperty = _props.onRemoveCustomProperty,
          availableCollectionColumnsPerArchetype = _props.availableCollectionColumnsPerArchetype,
          relationTypeInfo = _props.relationTypeInfo,
          targetableVres = _props.targetableVres;
      var _props2 = this.props,
          predicateName = _props2.name,
          type = _props2.type,
          custom = _props2.custom,
          customIndex = _props2.customIndex,
          columns = _props2.columns,
          predicateObjectMap = _props2.predicateObjectMap,
          predicateObjectMappings = _props2.predicateObjectMappings;


      var formComponent = typeMap[type] ? typeMap[type]({
        columns: columns,
        selectedColumn: (0, _propertyMappings.getColumnValue)(predicateObjectMap),
        predicateObjectMap: predicateObjectMap,
        predicateObjectMappings: predicateObjectMappings,
        availableCollectionColumnsPerArchetype: availableCollectionColumnsPerArchetype,
        relationTypeInfo: relationTypeInfo,
        targetableVres: targetableVres,
        onColumnSelect: function onColumnSelect(value, predicate) {
          return onAddPredicateObjectMap(predicate || predicateName, value, type);
        },
        onClearColumn: function onClearColumn(value, predicate) {
          return onRemovePredicateObjectMap(predicate || predicateName, value);
        }
      }) : _react2.default.createElement(
        "span",
        null,
        "type not yet supported: ",
        _react2.default.createElement(
          "span",
          { style: { color: "red" } },
          type
        )
      );

      var unConfirmButton = (0, _propertyMappings.propertyMappingIsComplete)(predicateObjectMap) || isCompleteForNames(type, predicateObjectMappings) ? _react2.default.createElement(
        "button",
        { className: "btn btn-blank", onClick: function onClick() {
            return onRemovePredicateObjectMap(predicateName, (0, _propertyMappings.getColumnValue)(predicateObjectMap));
          } },
        _react2.default.createElement("span", { className: "hi-success glyphicon glyphicon-ok" })
      ) : null;

      return _react2.default.createElement(
        "div",
        { className: "row small-margin" },
        _react2.default.createElement(
          "div",
          { className: "col-sm-2 pad-6-12" },
          _react2.default.createElement(
            "strong",
            null,
            (0, _camel2label2.default)(predicateName)
          ),
          _react2.default.createElement(
            "span",
            { className: "pull-right", style: { fontSize: "0.7em" } },
            "(",
            type,
            ")"
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-8" },
          formComponent
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-1" },
          custom ? _react2.default.createElement(
            "button",
            { className: "btn btn-blank pull-right", type: "button", onClick: function onClick() {
                return onRemoveCustomProperty(customIndex);
              } },
            _react2.default.createElement("span", { className: "glyphicon glyphicon-remove" })
          ) : null
        ),
        _react2.default.createElement(
          "div",
          { className: "col-sm-1 hi-success" },
          unConfirmButton
        )
      );
    }
  }]);

  return PropertyForm;
}(_react2.default.Component);

exports.default = PropertyForm;

},{"../../accessors/property-mappings":105,"../../util/camel2label":163,"./column-select":117,"./names-form":118,"./relation-form":120,"react":"react"}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _columnSelect = require("./column-select");

var _columnSelect2 = _interopRequireDefault(_columnSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var getSelectedTargetColumn = function getSelectedTargetColumn(objectMap) {
  return objectMap.joinCondition && objectMap.joinCondition.parent && objectMap.parentTriplesMap ? objectMap.parentTriplesMap + "!" + objectMap.joinCondition.parent : null;
};

var RelationForm = function (_React$Component) {
  _inherits(RelationForm, _React$Component);

  function RelationForm() {
    _classCallCheck(this, RelationForm);

    return _possibleConstructorReturn(this, (RelationForm.__proto__ || Object.getPrototypeOf(RelationForm)).apply(this, arguments));
  }

  _createClass(RelationForm, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          _onColumnSelect = _props.onColumnSelect,
          optionalPredicateObjectMap = _props.predicateObjectMap,
          availableCollectionColumnsPerArchetype = _props.availableCollectionColumnsPerArchetype,
          relationTypeInfo = _props.relationTypeInfo;


      var objectMap = (optionalPredicateObjectMap || {}).objectMap || {};

      var sourceColumnProps = _extends({}, this.props, {
        valuePrefix: "(source) ",
        placeholder: "Select a source column...",
        onColumnSelect: function onColumnSelect(value) {
          return _onColumnSelect(_extends({}, objectMap || {}, {
            joinCondition: _extends({}, (objectMap || {}).joinCondition || {}, {
              child: value
            })
          }));
        }
      });

      var targetCollectionColumns = availableCollectionColumnsPerArchetype[relationTypeInfo.relation.targetCollection].map(function (targetCollectionCols) {
        return targetCollectionCols.columns.map(function (column) {
          return targetCollectionCols.collectionName + "!" + column;
        });
      }).reduce(function (a, b) {
        return a.concat(b);
      });

      var targetColumnProps = {
        valuePrefix: "(target) ",
        columns: targetCollectionColumns,
        selectedColumn: getSelectedTargetColumn(objectMap),
        placeholder: "Select a target column...",
        onColumnSelect: function onColumnSelect(value) {
          return _onColumnSelect(_extends({}, objectMap || {}, {
            joinCondition: _extends({}, (objectMap || {}).joinCondition || {}, {
              parent: value.split("!")[1]
            }),
            parentTriplesMap: value.split("!")[0]
          }));
        }
      };

      return _react2.default.createElement(
        "div",
        null,
        _react2.default.createElement(_columnSelect2.default, sourceColumnProps),
        _react2.default.createElement(_columnSelect2.default, targetColumnProps)
      );
    }
  }]);

  return RelationForm;
}(_react2.default.Component);

exports.default = RelationForm;

},{"./column-select":117,"react":"react"}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _datasetCards = require("./dataset-cards");

var _datasetCards2 = _interopRequireDefault(_datasetCards);

var _firstUpload = require("./firstUpload");

var _firstUpload2 = _interopRequireDefault(_firstUpload);

var _deleteVreConfirmationForm = require("./delete-vre-confirmation-form");

var _deleteVreConfirmationForm2 = _interopRequireDefault(_deleteVreConfirmationForm);

var _modal = require("./fields/modal");

var _modal2 = _interopRequireDefault(_modal);

var _message = require("./message");

var _message2 = _interopRequireDefault(_message);

var _router = require("../router");

var _reactRouter = require("react-router");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CollectionOverview(props) {
  var onContinueMapping = props.onContinueMapping,
      onDeleteVreClick = props.onDeleteVreClick,
      onComfirmDeleteVre = props.onComfirmDeleteVre,
      _onCloseMessage = props.onCloseMessage;
  var userId = props.userId,
      vres = props.vres,
      searchGuiUrl = props.searchGuiUrl,
      showDeleteVreModalFor = props.showDeleteVreModalFor,
      showDeleteVreFailedMessage = props.showDeleteVreFailedMessage;


  var hasOwnVres = (vres && Object.keys(vres).length > 0) > 0;

  var uploadButton = _react2.default.createElement(
    _reactRouter.Link,
    { to: _router.urls.newDataset(), className: "btn btn-lg btn-primary " + (hasOwnVres ? "pull-right" : "") },
    _react2.default.createElement("span", { className: "glyphicon glyphicon-cloud-upload" }),
    " ",
    hasOwnVres ? "Upload new dataset" : "Upload your first dataset"
  );

  var deleteVreFailedMessage = showDeleteVreFailedMessage ? _react2.default.createElement(
    _message2.default,
    { alertLevel: "danger", dismissible: true, onCloseMessage: function onCloseMessage() {
        return _onCloseMessage("showDeleteVreFailedMessage");
      } },
    "Failed to delete dataset"
  ) : null;

  var deleteVreModal = showDeleteVreModalFor ? _react2.default.createElement(
    _modal2.default,
    { onClose: function onClose() {
        return onDeleteVreClick(null);
      }, header: "Delete dataset" },
    _react2.default.createElement(_deleteVreConfirmationForm2.default, { vreId: showDeleteVreModalFor, onComfirmDeleteVre: onComfirmDeleteVre, onClose: function onClose() {
        return onDeleteVreClick(null);
      } })
  ) : null;

  return hasOwnVres ? _react2.default.createElement(
    "div",
    null,
    deleteVreModal,
    _react2.default.createElement(
      "div",
      { className: "container" },
      deleteVreFailedMessage,
      _react2.default.createElement(
        _datasetCards2.default,
        { userId: userId, caption: "My datasets", vres: vres, mine: true, searchGuiUrl: searchGuiUrl,
          onDeleteVreClick: onDeleteVreClick, onContinueMapping: onContinueMapping },
        uploadButton
      )
    )
  ) : _react2.default.createElement(
    _firstUpload2.default,
    props,
    uploadButton
  );
}

exports.default = CollectionOverview;

},{"../router":159,"./dataset-cards":126,"./delete-vre-confirmation-form":129,"./fields/modal":130,"./firstUpload":132,"./message":134,"react":"react","react-router":76}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _headerCell = require("./table/header-cell");

var _headerCell2 = _interopRequireDefault(_headerCell);

var _dataRow = require("./table/data-row");

var _dataRow2 = _interopRequireDefault(_dataRow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CollectionTable = function (_React$Component) {
  _inherits(CollectionTable, _React$Component);

  function CollectionTable() {
    _classCallCheck(this, CollectionTable);

    return _possibleConstructorReturn(this, (CollectionTable.__proto__ || Object.getPrototypeOf(CollectionTable)).apply(this, arguments));
  }

  _createClass(CollectionTable, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          rows = _props.rows,
          headers = _props.headers,
          nextUrl = _props.nextUrl;


      return _react2.default.createElement(
        "div",
        { className: "table-responsive" },
        _react2.default.createElement(
          "table",
          { className: "table table-bordered table-obtrusive" },
          _react2.default.createElement(
            "thead",
            null,
            _react2.default.createElement(
              "tr",
              null,
              headers.map(function (header) {
                return _react2.default.createElement(_headerCell2.default, { key: header.name, header: header.name, isConfirmed: header.isConfirmed });
              })
            )
          ),
          _react2.default.createElement(
            "tbody",
            null,
            rows.map(function (row, i) {
              return _react2.default.createElement(_dataRow2.default, { key: i, row: row });
            })
          )
        ),
        _react2.default.createElement(
          "button",
          { onClick: function onClick() {
              return _this2.props.onLoadMoreClick && _this2.props.onLoadMoreClick(nextUrl);
            },
            disabled: !nextUrl,
            className: "btn btn-default pull-right" },
          "more..."
        )
      );
    }
  }]);

  return CollectionTable;
}(_react2.default.Component);

exports.default = CollectionTable;

},{"./table/data-row":136,"./table/header-cell":137,"react":"react"}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CollectionTabs = function (_React$Component) {
  _inherits(CollectionTabs, _React$Component);

  function CollectionTabs() {
    _classCallCheck(this, CollectionTabs);

    return _possibleConstructorReturn(this, (CollectionTabs.__proto__ || Object.getPrototypeOf(CollectionTabs)).apply(this, arguments));
  }

  _createClass(CollectionTabs, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          collectionTabs = _props.collectionTabs,
          onSelectCollection = _props.onSelectCollection;


      return _react2.default.createElement(
        "div",
        { className: "container basic-margin" },
        _react2.default.createElement(
          "ul",
          { className: "nav nav-tabs", role: "tablist" },
          collectionTabs.map(function (collectionTab) {
            return _react2.default.createElement(
              "li",
              { key: collectionTab.collectionName, className: (0, _classnames2.default)({ active: collectionTab.active }) },
              _react2.default.createElement(
                "a",
                { onClick: function onClick() {
                    return collectionTab.active ? false : onSelectCollection(collectionTab.collectionName);
                  },
                  style: { cursor: collectionTab.active ? "default" : "pointer" } },
                collectionTab.archetypeName,
                " ",
                collectionTab.complete ? _react2.default.createElement("span", { className: "glyphicon glyphicon-ok" }) : null,
                _react2.default.createElement(
                  "span",
                  { className: "excel-tab" },
                  _react2.default.createElement("img", { src: "images/icon-excel.svg", className: "excel-icon", alt: "" }),
                  " ",
                  collectionTab.collectionName
                )
              )
            );
          })
        )
      );
    }
  }]);

  return CollectionTabs;
}(_react2.default.Component);

exports.default = CollectionTabs;

},{"classnames":2,"react":"react"}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _collectionTabs = require("./collection-tabs");

var _collectionTabs2 = _interopRequireDefault(_collectionTabs);

var _message = require("./message");

var _message2 = _interopRequireDefault(_message);

var _collectionTable = require("./collection-table");

var _collectionTable2 = _interopRequireDefault(_collectionTable);

var _collectionForm = require("./collection-form/collection-form");

var _collectionForm2 = _interopRequireDefault(_collectionForm);

var _uploadButton = require("./upload-button");

var _uploadButton2 = _interopRequireDefault(_uploadButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ConnectData = function (_React$Component) {
  _inherits(ConnectData, _React$Component);

  function ConnectData() {
    _classCallCheck(this, ConnectData);

    return _possibleConstructorReturn(this, (ConnectData.__proto__ || Object.getPrototypeOf(ConnectData)).apply(this, arguments));
  }

  _createClass(ConnectData, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _props = this.props,
          onFetchBulkUploadedMetadata = _props.onFetchBulkUploadedMetadata,
          onSelectCollection = _props.onSelectCollection;
      var firstMappedCollection = nextProps.firstMappedCollection;


      if (this.props.params.vreId !== nextProps.params.vreId) {
        // Triggers fetch data from server based on vreId from route.
        onFetchBulkUploadedMetadata(nextProps.params.vreId);
      } else if (firstMappedCollection) {
        // If the currently active collection is not mapped, show the first one that _is_ mapped
        onSelectCollection(firstMappedCollection);
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _props2 = this.props,
          onFetchBulkUploadedMetadata = _props2.onFetchBulkUploadedMetadata,
          tabs = _props2.tabs,
          vre = _props2.vre,
          vreId = _props2.vreId,
          firstMappedCollection = _props2.firstMappedCollection,
          onSelectCollection = _props2.onSelectCollection;


      if (tabs.length === 0 || vre !== vreId) {
        // Triggers fetch data from server based on vreId from route.
        onFetchBulkUploadedMetadata(vreId);
      } else if (firstMappedCollection) {
        // If the currently active collection is not mapped, show the first one that _is_ mapped
        onSelectCollection(firstMappedCollection);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _props3 = this.props,
          _onCloseMessage = _props3.onCloseMessage,
          onSelectCollection = _props3.onSelectCollection,
          _onLoadMoreClick = _props3.onLoadMoreClick,
          onPublishData = _props3.onPublishData,
          onUploadFileSelect = _props3.onUploadFileSelect,
          onSaveMappingState = _props3.onSaveMappingState;
      var _props4 = this.props,
          onAddPredicateObjectMap = _props4.onAddPredicateObjectMap,
          onRemovePredicateObjectMap = _props4.onRemovePredicateObjectMap,
          onAddCustomProperty = _props4.onAddCustomProperty,
          onRemoveCustomProperty = _props4.onRemoveCustomProperty;
      var _props5 = this.props,
          vreId = _props5.params.vreId,
          vre = _props5.vre,
          tabs = _props5.tabs,
          showCollectionsAreConnectedMessage = _props5.showCollectionsAreConnectedMessage,
          uploadedFilename = _props5.uploadedFilename,
          publishEnabled = _props5.publishEnabled,
          publishStatus = _props5.publishStatus,
          publishErrors = _props5.publishErrors,
          hasMappingErrors = _props5.hasMappingErrors,
          uploadStatus = _props5.uploadStatus,
          availableArchetypes = _props5.availableArchetypes,
          customProperties = _props5.customProperties,
          availableCollectionColumnsPerArchetype = _props5.availableCollectionColumnsPerArchetype,
          rmlPreviewData = _props5.rmlPreviewData,
          targetableVres = _props5.targetableVres;

      // table view properties

      var _props6 = this.props,
          rows = _props6.rows,
          headers = _props6.headers,
          nextUrl = _props6.nextUrl,
          activeCollection = _props6.activeCollection;

      // form view properties

      var _props7 = this.props,
          archetypeFields = _props7.archetypeFields,
          columns = _props7.columns,
          predicateObjectMappings = _props7.predicateObjectMappings;


      if (!archetypeFields || tabs.length === 0 || vre !== vreId) {
        return null;
      }

      var rmlPreviewBlock = rmlPreviewData ? _react2.default.createElement(
        "div",
        { style: { position: "absolute", zIndex: "10", width: "100%", top: "90px" } },
        _react2.default.createElement(
          "pre",
          { style: { width: "80%", margin: "0 auto", backgroundColor: "#ddd" } },
          JSON.stringify(rmlPreviewData, null, 2)
        )
      ) : null;

      var publishFailedMessage = publishErrors || hasMappingErrors ? _react2.default.createElement(
        _message2.default,
        { alertLevel: "danger", dismissible: false },
        _react2.default.createElement(_uploadButton2.default, { classNames: ["btn", "btn-danger", "pull-right", "btn-xs"], label: "Re-upload",
          redirectPath: "mapArchetypes",
          onUploadFileSelect: onUploadFileSelect, uploadStatus: uploadStatus,
          vreId: vre
        }),
        _react2.default.createElement("span", { className: "glyphicon glyphicon-exclamation-sign" }),
        " ",
        "Publish failed. Please fix the mappings or re-upload the data."
      ) : null;

      var collectionsAreConnectedMessage = showCollectionsAreConnectedMessage && uploadedFilename ? _react2.default.createElement(
        _message2.default,
        { alertLevel: "info", dismissible: true, onCloseMessage: function onCloseMessage() {
            return _onCloseMessage("showCollectionsAreConnectedMessage");
          } },
        tabs.map(function (tab) {
          return _react2.default.createElement(
            "em",
            { key: tab.collectionName },
            tab.collectionName
          );
        }).reduce(function (accu, elem) {
          return accu === null ? [elem] : [].concat(_toConsumableArray(accu), [' and ', elem]);
        }, null),
        " from ",
        _react2.default.createElement(
          "em",
          null,
          uploadedFilename
        ),
        " ",
        tabs.length === 1 ? "is" : "are",
        " connected to the Timbuctoo Archetypes."
      ) : null;

      return _react2.default.createElement(
        "div",
        null,
        rmlPreviewBlock,
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "h2",
            { className: "small-margin" },
            "Upload and connect your dataset"
          ),
          collectionsAreConnectedMessage,
          publishFailedMessage,
          _react2.default.createElement(
            "p",
            null,
            "Connect the excel columns to the properties of the Archetypes"
          )
        ),
        _react2.default.createElement(_collectionTabs2.default, { collectionTabs: tabs, onSelectCollection: onSelectCollection }),
        _react2.default.createElement(_collectionForm2.default, { archetypeFields: archetypeFields, columns: columns,
          availableArchetypes: availableArchetypes,
          availableCollectionColumnsPerArchetype: availableCollectionColumnsPerArchetype,
          customProperties: customProperties,
          onAddCustomProperty: onAddCustomProperty,
          onRemoveCustomProperty: onRemoveCustomProperty,
          predicateObjectMappings: predicateObjectMappings,
          onAddPredicateObjectMap: onAddPredicateObjectMap,
          onRemovePredicateObjectMap: onRemovePredicateObjectMap,
          targetableVres: targetableVres }),
        _react2.default.createElement(
          "div",
          { className: "container big-margin" },
          _react2.default.createElement(
            "button",
            { onClick: onPublishData, className: "btn btn-warning btn-lg pull-right", type: "button", disabled: !publishEnabled },
            publishStatus
          ),
          _react2.default.createElement(
            "button",
            { onClick: onSaveMappingState, className: "btn btn-default btn-lg pull-right", style: { marginRight: "4px" }, disabled: !publishEnabled },
            "Save"
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "container big-margin" },
          _react2.default.createElement(
            "p",
            { className: "from-excel" },
            _react2.default.createElement("img", { src: "images/icon-excel.svg", alt: "" }),
            " ",
            _react2.default.createElement(
              "em",
              null,
              activeCollection
            ),
            " ",
            uploadedFilename ? "from " + uploadedFilename : ""
          ),
          _react2.default.createElement(_collectionTable2.default, {
            rows: rows,
            headers: headers,
            nextUrl: nextUrl,
            onLoadMoreClick: function onLoadMoreClick(url) {
              return _onLoadMoreClick(url, activeCollection);
            } })
        )
      );
    }
  }]);

  return ConnectData;
}(_react2.default.Component);

exports.default = ConnectData;

},{"./collection-form/collection-form":116,"./collection-table":122,"./collection-tabs":123,"./message":134,"./upload-button":138,"react":"react"}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _selectField = require("./fields/select-field");

var _selectField2 = _interopRequireDefault(_selectField);

var _message = require("./message");

var _message2 = _interopRequireDefault(_message);

var _router = require("../router");

var _reactRouter = require("react-router");

var _collectionTable = require("./collection-table");

var _collectionTable2 = _interopRequireDefault(_collectionTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ConnectToArchetype = function (_React$Component) {
  _inherits(ConnectToArchetype, _React$Component);

  function ConnectToArchetype() {
    _classCallCheck(this, ConnectToArchetype);

    return _possibleConstructorReturn(this, (ConnectToArchetype.__proto__ || Object.getPrototypeOf(ConnectToArchetype)).apply(this, arguments));
  }

  _createClass(ConnectToArchetype, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var onFetchBulkUploadedMetadata = this.props.onFetchBulkUploadedMetadata;
      // Triggers fetch data from server based on vreId from route.

      if (this.props.params.vreId !== nextProps.params.vreId) {
        onFetchBulkUploadedMetadata(nextProps.params.vreId);
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _props = this.props,
          onFetchBulkUploadedMetadata = _props.onFetchBulkUploadedMetadata,
          collections = _props.collections,
          vre = _props.vre,
          vreId = _props.vreId;

      if (!collections || vre !== vreId) {
        onFetchBulkUploadedMetadata(vreId);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _props2 = this.props,
          vreId = _props2.vreId,
          vre = _props2.vre,
          archetype = _props2.archetype,
          collections = _props2.collections,
          mappings = _props2.mappings,
          rmlPreviewData = _props2.rmlPreviewData;

      // actions

      var _props3 = this.props,
          _onCloseMessage = _props3.onCloseMessage,
          onMapCollectionArchetype = _props3.onMapCollectionArchetype,
          onSelectCollection = _props3.onSelectCollection,
          _onLoadMoreClick = _props3.onLoadMoreClick,
          onSaveNewMappingState = _props3.onSaveNewMappingState;
      // messages

      var _props4 = this.props,
          showFileIsUploadedMessage = _props4.showFileIsUploadedMessage,
          uploadedFileName = _props4.uploadedFileName;
      // table view properties

      var _props5 = this.props,
          rows = _props5.rows,
          headers = _props5.headers,
          nextUrl = _props5.nextUrl,
          activeCollection = _props5.activeCollection;


      if (!collections || vre !== vreId) {
        return null;
      }

      var collectionsAreMapped = Object.keys(mappings.collections).length > 0 && Object.keys(mappings.collections).map(function (key) {
        return mappings.collections[key].archetypeName;
      }).filter(function (val) {
        return val !== null;
      }).length > 0;

      var fileIsUploadedMessage = showFileIsUploadedMessage && uploadedFileName ? _react2.default.createElement(
        _message2.default,
        { alertLevel: "info", dismissible: true, onCloseMessage: function onCloseMessage() {
            return _onCloseMessage("showFileIsUploadedMessage");
          } },
        _react2.default.createElement(
          "em",
          null,
          uploadedFileName
        ),
        " is uploaded."
      ) : null;

      var rmlPreviewBlock = rmlPreviewData ? _react2.default.createElement(
        "div",
        { style: { position: "absolute", zIndex: "10", width: "100%", top: "90px" } },
        _react2.default.createElement(
          "pre",
          { style: { width: "80%", margin: "0 auto", backgroundColor: "#ddd" } },
          JSON.stringify(rmlPreviewData, null, 2)
        )
      ) : null;

      return _react2.default.createElement(
        "div",
        null,
        rmlPreviewBlock,
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "h2",
            { className: "small-margin" },
            "Upload and connect your dataset"
          ),
          fileIsUploadedMessage,
          _react2.default.createElement(
            "p",
            null,
            "We found ",
            collections.length,
            " collections in the file. Connect the tabs to the Timbuctoo Archetypes."
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          collections.map(function (sheet) {
            return _react2.default.createElement(
              "div",
              { className: "row", key: sheet.name },
              _react2.default.createElement(
                "div",
                { className: "col-md-2" },
                _react2.default.createElement(
                  "a",
                  { className: "from-excel", style: { cursor: "pointer" },
                    onClick: function onClick() {
                      return sheet.name === activeCollection ? false : onSelectCollection(sheet.name);
                    } },
                  _react2.default.createElement("img", { src: "images/icon-excel.svg", alt: "" }),
                  " ",
                  sheet.name,
                  " ",
                  sheet.name === activeCollection ? "*" : ""
                )
              ),
              _react2.default.createElement(
                "div",
                { className: "col-md-8" },
                _react2.default.createElement(
                  _selectField2.default,
                  {
                    onChange: function onChange(value) {
                      return onMapCollectionArchetype(sheet.name, value);
                    },
                    onClear: function onClear() {
                      return onMapCollectionArchetype(sheet.name, null);
                    },
                    value: mappings.collections[sheet.name].archetypeName },
                  _react2.default.createElement(
                    "span",
                    { type: "placeholder" },
                    "Connect ",
                    _react2.default.createElement(
                      "em",
                      null,
                      sheet.name
                    ),
                    " to a Timbuctoo archetype."
                  ),
                  Object.keys(archetype).filter(function (domain) {
                    return domain !== "relations";
                  }).sort().map(function (option) {
                    return _react2.default.createElement(
                      "span",
                      { key: option, value: option },
                      option,
                      _react2.default.createElement("br", null),
                      _react2.default.createElement(
                        "span",
                        { style: { color: "#666", fontSize: "0.6em" } },
                        "Properties: ",
                        archetype[option].filter(function (prop) {
                          return prop.type !== "relation";
                        }).map(function (prop) {
                          return prop.name + " (" + prop.type + ")";
                        }).join(", ")
                      )
                    );
                  })
                )
              ),
              mappings.collections[sheet.name].archetypeName ? _react2.default.createElement(
                "div",
                { className: "col-sm-1 hi-success", key: sheet.name },
                _react2.default.createElement("span", { className: "glyphicon glyphicon-ok pull-right" })
              ) : null
            );
          })
        ),
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "button",
            { disabled: !collectionsAreMapped, onClick: onSaveNewMappingState, className: "btn btn-success" },
            "Connect"
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "container big-margin" },
          _react2.default.createElement(
            "p",
            { className: "from-excel" },
            _react2.default.createElement("img", { src: "images/icon-excel.svg", alt: "" }),
            " ",
            _react2.default.createElement(
              "em",
              null,
              activeCollection
            ),
            " ",
            uploadedFileName ? "from " + uploadedFileName : ""
          ),
          _react2.default.createElement(_collectionTable2.default, {
            rows: rows,
            headers: headers,
            nextUrl: nextUrl,
            onLoadMoreClick: function onLoadMoreClick(url) {
              return _onLoadMoreClick(url, activeCollection);
            } })
        )
      );
    }
  }]);

  return ConnectToArchetype;
}(_react2.default.Component);

exports.default = ConnectToArchetype;

},{"../router":159,"./collection-table":122,"./fields/select-field":131,"./message":134,"react":"react","react-router":76}],126:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (props) {
  var vres = props.vres,
      caption = props.caption,
      userId = props.userId,
      searchGuiUrl = props.searchGuiUrl,
      mine = props.mine,
      onContinueMapping = props.onContinueMapping,
      onDeleteVreClick = props.onDeleteVreClick;


  return _react2.default.createElement(
    'div',
    { className: 'container' },
    _react2.default.createElement(
      'div',
      { className: 'basic-margin' },
      props.children,
      _react2.default.createElement(
        'h3',
        null,
        caption
      )
    ),
    _react2.default.createElement(
      'div',
      { className: 'big-margin' },
      Object.keys(vres).filter(function (vre) {
        return !vres[vre].deletePending;
      }).map(function (vre) {
        return _react2.default.createElement(_datasetCard2.default, { key: vre, mine: mine, published: vres[vre].published,
          publishState: vres[vre].publishState,
          vreMetadata: vres[vre].vreMetadata,
          searchGuiUrl: searchGuiUrl,
          onContinueMapping: onContinueMapping, onDeleteVreClick: onDeleteVreClick,
          userId: userId, vreId: vres[vre].name, caption: vres[vre].label });
      })
    )
  );
};

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _datasetCard = require('./datasetCard.jsx');

var _datasetCard2 = _interopRequireDefault(_datasetCard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;

},{"./datasetCard.jsx":128,"react":"react"}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _uploadButton = require("./upload-button");

var _uploadButton2 = _interopRequireDefault(_uploadButton);

var _publishState = require("../util/publish-state");

var _publishState2 = _interopRequireDefault(_publishState);

var _message = require("./message");

var _message2 = _interopRequireDefault(_message);

var _colorCodes = require("../util/color-codes");

var _colorCodes2 = _interopRequireDefault(_colorCodes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var getMappingState = function getMappingState(publishState, uploadStatus) {
  switch (publishState) {
    case _publishState2.default.MAPPING_CREATION:
    case _publishState2.default.MAPPING_CREATION_AFTER_ERRORS:
      return {
        nameEditDisabled: false,
        continueDisabled: false,
        editDisabled: false,
        editPlaceHolder: null,
        statusMessage: "Upload is finished. Please enter some basic information about your project",
        title: "Dataset settings",
        uploadButtonStatus: uploadStatus || null,
        uploadButtonLabel: "Upload a new file"
      };
    case _publishState2.default.UPLOADING:
      return {
        nameEditDisabled: false,
        continueDisabled: true,
        editDisabled: false,
        editPlaceHolder: null,
        statusMessage: "Uploading data",
        title: "Dataset settings",
        uploadButtonStatus: uploadStatus || "Uploading please wait..."
      };
    case _publishState2.default.MAPPING_EXECUTION:
      return {
        nameEditDisabled: true,
        continueDisabled: true,
        editDisabled: true,
        editPlaceHolder: "This dataset is currently being published an may not be edited",
        statusMessage: "This dataset is currently being published an may not be edited",
        title: "Dataset settings",
        uploadButtonStatus: "This dataset is currently being published an may not be edited"
      };
    case _publishState2.default.AVAILABLE:
      return {
        nameEditDisabled: false,
        continueDisabled: true,
        editDisabled: false,
        editPlaceHolder: null,
        statusMessage: uploadStatus || "This dataset is already published. You can edit the settings from here.",
        title: "Dataset settings",
        uploadButtonStatus: "This dataset is already published",
        uploadButtonLabel: "Re-Upload (deletes currently published data)"
      };
  }
  return {
    nameEditDisabled: false,
    continueDisabled: true,
    editDisabled: true,
    editPlaceholder: "Please upload a dataset first...",
    uploadButtonStatus: uploadStatus || null,
    statusMessage: "To create e new dataset, please enter some basic information about your project",
    title: "Create a new dataset",
    uploadButtonLabel: "Browse..."
  };
};

var DatasetSettings = function (_React$Component) {
  _inherits(DatasetSettings, _React$Component);

  function DatasetSettings() {
    _classCallCheck(this, DatasetSettings);

    return _possibleConstructorReturn(this, (DatasetSettings.__proto__ || Object.getPrototypeOf(DatasetSettings)).apply(this, arguments));
  }

  _createClass(DatasetSettings, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.vreId !== this.props.vreId) {
        this.props.onClearFormSettingData();
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.props.onClearFormSettingData();
    }
  }, {
    key: "onChange",
    value: function onChange(ev) {
      var sanitized = ev.target.value.replace(/[^a-zA-Z\s\-]+/, "").replace(/^\s*/, "");

      this.props.onSetNewVreName(sanitized);
    }
  }, {
    key: "render",
    value: function render() {
      var _props = this.props,
          newVreName = _props.newVreName,
          newDescription = _props.newDescription,
          newProvenance = _props.newProvenance,
          newColorCode = _props.newColorCode,
          onUploadFileSelect = _props.onUploadFileSelect,
          uploadStatus = _props.uploadStatus,
          publishState = _props.publishState,
          vreId = _props.vreId,
          uploadedFileName = _props.uploadedFileName,
          onContinueMapping = _props.onContinueMapping,
          onSaveVreSettings = _props.onSaveVreSettings,
          onSetNewDescription = _props.onSetNewDescription,
          onSetNewProvenance = _props.onSetNewProvenance,
          onSetNewColorCode = _props.onSetNewColorCode,
          onUploadImage = _props.onUploadImage,
          onCloseImageError = _props.onCloseImageError,
          imageUploadStatus = _props.imageUploadStatus,
          imageUploadErrorMessage = _props.imageUploadErrorMessage,
          imageUrl = _props.imageUrl,
          uploadedFilenameFromVre = _props.uploadedFilenameFromVre;


      var finalVreName = newVreName ? newVreName.replace(/\s*$/, "") : null;

      var _getMappingState = getMappingState(publishState, uploadStatus),
          nameEditDisabled = _getMappingState.nameEditDisabled,
          continueDisabled = _getMappingState.continueDisabled,
          editPlaceholder = _getMappingState.editPlaceholder,
          editDisabled = _getMappingState.editDisabled,
          statusMessage = _getMappingState.statusMessage,
          title = _getMappingState.title,
          uploadButtonStatus = _getMappingState.uploadButtonStatus,
          uploadButtonLabel = _getMappingState.uploadButtonLabel;

      var imageError = imageUploadErrorMessage ? _react2.default.createElement(
        _message2.default,
        { alertLevel: "danger", onCloseMessage: onCloseImageError, dismissible: true },
        imageUploadErrorMessage
      ) : null;

      var imageTag = imageUrl ? _react2.default.createElement("img", { src: imageUrl, style: { maxWidth: "100%" } }) : null;

      var imageStyle = imageUrl ? {
        backgroundImage: "url(" + imageUrl + ")",
        backgroundPosition: "center center",
        backgroundRepeat: "no-repeat",
        backgroundBlendMode: "multiply",
        backgroundSize: "125% auto",
        color: "white"
      } : {};

      return _react2.default.createElement(
        "div",
        null,
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "h2",
            { className: "small-margin" },
            title
          ),
          _react2.default.createElement(
            "div",
            { className: "col-md-9" },
            statusMessage
          ),
          _react2.default.createElement(
            "div",
            { className: "col-md-3 alert alert-info alert-dismissible", role: "alert" },
            _react2.default.createElement("span", { className: "glyphicon glyphicon-play-circle" }),
            " Watch a 3 min video to create a new dataset."
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "h4",
            null,
            "Title"
          ),
          _react2.default.createElement("input", { className: "form-control", type: "text", disabled: nameEditDisabled, placeholder: "Enter dataset name", value: newVreName || "", onChange: this.onChange.bind(this) })
        ),
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "h4",
            null,
            "Upload Excel file"
          ),
          _react2.default.createElement(_uploadButton2.default, {
            classNames: ["btn", "btn-primary"],
            uploadStatus: finalVreName === null ? "Please enter a title first..." : uploadButtonStatus,
            vreName: vreId ? null : finalVreName,
            vreId: vreId,
            label: uploadButtonLabel,
            float: "left",
            onUploadFileSelect: onUploadFileSelect
          }),
          _react2.default.createElement("input", { type: "text", className: "form-control", disabled: true, value: uploadedFileName || uploadedFilenameFromVre, style: { maxWidth: "400px" } })
        ),
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "h4",
            null,
            "Description"
          ),
          _react2.default.createElement("textarea", { disabled: editDisabled, value: newDescription, onChange: function onChange(ev) {
              onSetNewDescription(ev.target.value);
            },
            placeholder: editPlaceholder || "Enter a description...", className: "form-control", rows: "3" })
        ),
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "h4",
            null,
            "Provenance"
          ),
          _react2.default.createElement("textarea", { disabled: editDisabled, value: newProvenance, onChange: function onChange(ev) {
              onSetNewProvenance(ev.target.value);
            },
            placeholder: editPlaceholder || "Enter provenance...", className: "form-control", rows: "3" })
        ),
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          imageError,
          _react2.default.createElement(
            "div",
            { className: "row" },
            _react2.default.createElement(
              "div",
              { className: "col-md-6" },
              _react2.default.createElement(
                "h4",
                null,
                "Color"
              ),
              editDisabled ? _react2.default.createElement(
                "div",
                null,
                editPlaceholder
              ) : _colorCodes2.default.map(function (colorCode) {
                return _react2.default.createElement(
                  "a",
                  { key: colorCode, style: { float: "left", width: "40px", cursor: "pointer", fontWeight: colorCode === newColorCode ? "500" : "300" }, onClick: function onClick() {
                      return onSetNewColorCode(colorCode);
                    } },
                  _react2.default.createElement("span", { style: { borderRadius: colorCode === newColorCode ? "8px" : "12px", display: "inline-block", border: "8px solid " + (colorCode === newColorCode ? "#" + colorCode : "white"), width: "40px", height: "40px", backgroundColor: "#" + colorCode } }),
                  " "
                );
              }),
              _react2.default.createElement(
                "div",
                { className: "card-dataset", style: { clear: "left", marginTop: "20px" } },
                _react2.default.createElement(
                  "button",
                  { title: finalVreName, style: _extends({}, imageStyle, { backgroundColor: newColorCode ? "#" + newColorCode : "#e6e6e6" }),
                    className: "card-dataset btn btn-default explore" },
                  _react2.default.createElement(
                    "strong",
                    { style: { display: "inline-block", overflow: "hidden", width: "90%", whiteSpace: "nowrap", textOverflow: "ellipsis" } },
                    finalVreName
                  )
                )
              )
            ),
            _react2.default.createElement(
              "div",
              { className: "col-md-6" },
              _react2.default.createElement(
                "h4",
                null,
                "Dataset illustration"
              ),
              _react2.default.createElement(
                "div",
                { className: "input-group" },
                _react2.default.createElement(_uploadButton2.default, {
                  classNames: ["btn", "btn-primary"],
                  vreId: vreId,
                  accept: "image/jpeg,image/gif,image/png",
                  uploadStatus: imageUploadStatus || editPlaceholder,
                  label: "Browse...",
                  float: "none",
                  onUploadFileSelect: function onUploadFileSelect(files) {
                    return onUploadImage(vreId, files);
                  }
                })
              ),
              imageTag
            )
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "container basic-margin" },
          _react2.default.createElement(
            "button",
            { className: "btn btn-default pull-right", disabled: continueDisabled, onClick: function onClick() {
                return onSaveVreSettings(vreId, function () {
                  return onContinueMapping(vreId);
                });
              } },
            "Save settings and continue to mapping"
          ),
          _react2.default.createElement(
            "button",
            { className: "btn btn-default pull-right", style: { marginRight: "4px" }, disabled: editDisabled, onClick: function onClick() {
                return onSaveVreSettings(vreId);
              } },
            "Save settings"
          )
        )
      );
    }
  }]);

  return DatasetSettings;
}(_react2.default.Component);

exports.default = DatasetSettings;

},{"../util/color-codes":165,"../util/publish-state":167,"./message":134,"./upload-button":138,"react":"react"}],128:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _publishState = require("../util/publish-state");

var _publishState2 = _interopRequireDefault(_publishState);

var _reactRouter = require("react-router");

var _router = require("../router");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getMappingState = function getMappingState(publishState) {
  switch (publishState) {
    case _publishState2.default.MAPPING_CREATION:
      return { text: "Finish mapping", disabled: false };
    case _publishState2.default.MAPPING_CREATION_AFTER_ERRORS:
      return { text: "Fix mappings", disabled: false };
    case _publishState2.default.UPLOADING:
      return { text: "Uploading...", disabled: true };
    case _publishState2.default.MAPPING_EXECUTION:
      return { text: "Publishing", disabled: true };
  }
  return { text: "", disabled: "" };
};

function DataSetCard(props) {
  var searchUrl = props.searchGuiUrl;

  var _props$vreMetadata = props.vreMetadata,
      colorCode = _props$vreMetadata.colorCode,
      image = _props$vreMetadata.image;


  var imageStyle = image ? {
    backgroundImage: "url(" + image + ")",
    backgroundPosition: "center center",
    backgroundRepeat: "no-repeat",
    backgroundBlendMode: "multiply",
    backgroundSize: "125% auto",
    color: "white"
  } : {};
  if (props.mine && !props.published) {
    var _getMappingState = getMappingState(props.publishState),
        text = _getMappingState.text,
        disabled = _getMappingState.disabled;

    return _react2.default.createElement(
      "div",
      { className: "card-dataset", style: { height: "280px" } },
      _react2.default.createElement(
        "button",
        { title: props.caption, disabled: disabled,
          style: _extends({}, imageStyle, { backgroundColor: colorCode ? "#" + colorCode : "#e6e6e6" }),
          className: "card-dataset btn btn-default explore", onClick: function onClick() {
            return props.onContinueMapping(props.vreId);
          } },
        text,
        _react2.default.createElement("br", null),
        _react2.default.createElement(
          "strong",
          { style: { display: "inline-block", overflow: "hidden", width: "90%", whiteSpace: "nowrap", textOverflow: "ellipsis" } },
          props.caption.replace(/^[^_]+_+/, "")
        )
      ),
      props.userId ? _react2.default.createElement(
        _reactRouter.Link,
        { className: "card-dataset btn btn-default", to: _router.urls.editDataset(props.vreId) },
        _react2.default.createElement("span", { className: "glyphicon glyphicon-wrench" }),
        " ",
        "Settings"
      ) : null,
      props.userId ? _react2.default.createElement(
        "button",
        { disabled: disabled, className: "card-dataset btn btn-default", onClick: function onClick() {
            return props.onDeleteVreClick(props.vreId);
          } },
        _react2.default.createElement("span", { className: "glyphicon glyphicon-trash" }),
        " ",
        "Delete"
      ) : null
    );
  }

  return _react2.default.createElement(
    "div",
    { className: "card-dataset" },
    _react2.default.createElement(
      "a",
      { className: "card-dataset btn btn-default explore",
        title: props.caption,
        style: _extends({}, imageStyle, { backgroundColor: colorCode ? "#" + colorCode : "#e6e6e6" }),
        href: searchUrl + "?vreId=" + props.vreId, target: "_blank" },
      _react2.default.createElement(
        "strong",
        { style: { display: "inline-block", overflow: "hidden", width: "90%", whiteSpace: "nowrap", textOverflow: "ellipsis" } },
        props.caption.replace(/^[^_]+_+/, "")
      )
    ),
    props.userId ? _react2.default.createElement(
      _reactRouter.Link,
      { className: "card-dataset btn btn-default", to: _router.urls.editDataset(props.vreId) },
      _react2.default.createElement("span", { className: "glyphicon glyphicon-wrench" }),
      " ",
      "Settings"
    ) : null,
    props.userId ? _react2.default.createElement(
      "a",
      { className: "card-dataset btn btn-default",
        href: "" + "/static/edit-gui/?vreId=" + props.vreId + "&hsid=" + props.userId, target: "_blank" },
      _react2.default.createElement("span", { className: "glyphicon glyphicon-pencil" }),
      " ",
      "Edit"
    ) : null,
    props.userId ? _react2.default.createElement(
      "a",
      { className: "card-dataset btn btn-default", onClick: function onClick() {
          return props.onDeleteVreClick(props.vreId);
        }, style: { cursor: "pointer" } },
      _react2.default.createElement("span", { className: "glyphicon glyphicon-trash" }),
      " ",
      "Delete"
    ) : null
  );
}

exports.default = DataSetCard;

},{"../router":159,"../util/publish-state":167,"react":"react","react-router":76}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DeleteVreConfirmationForm = function (_React$Component) {
  _inherits(DeleteVreConfirmationForm, _React$Component);

  function DeleteVreConfirmationForm(props) {
    _classCallCheck(this, DeleteVreConfirmationForm);

    var _this = _possibleConstructorReturn(this, (DeleteVreConfirmationForm.__proto__ || Object.getPrototypeOf(DeleteVreConfirmationForm)).call(this, props));

    _this.state = {
      confirmValue: ""
    };
    return _this;
  }

  _createClass(DeleteVreConfirmationForm, [{
    key: "onConfirmInputChange",
    value: function onConfirmInputChange(ev) {
      this.setState({ confirmValue: ev.target.value });
    }
  }, {
    key: "onKeyPress",
    value: function onKeyPress(ev) {
      var _props = this.props,
          vreId = _props.vreId,
          onComfirmDeleteVre = _props.onComfirmDeleteVre;
      var confirmValue = this.state.confirmValue;


      if (ev.key === "Enter" && vreId === confirmValue) {
        onComfirmDeleteVre(vreId, confirmValue);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _props2 = this.props,
          vreId = _props2.vreId,
          onComfirmDeleteVre = _props2.onComfirmDeleteVre,
          onClose = _props2.onClose;
      var confirmValue = this.state.confirmValue;


      return _react2.default.createElement(
        "div",
        null,
        _react2.default.createElement(
          "div",
          { className: "modal-body" },
          _react2.default.createElement(
            "p",
            null,
            "Are you sure you wish to delete the ",
            _react2.default.createElement(
              "strong",
              null,
              vreId.replace(/^[^_]+_+/, "")
            ),
            " dataset?"
          ),
          _react2.default.createElement(
            "p",
            null,
            "To confirm, please retype the fully qualified dataset ID in the input below."
          ),
          _react2.default.createElement(
            "p",
            { style: { width: "100%", backgroundColor: "#ddd", overflowX: "auto", whiteSpace: "nowrap" } },
            vreId
          ),
          _react2.default.createElement(
            "p",
            null,
            _react2.default.createElement("input", { type: "text", value: confirmValue, onChange: this.onConfirmInputChange.bind(this),
              onKeyPress: this.onKeyPress.bind(this),
              placeholder: "Enter dataset ID here" })
          )
        ),
        _react2.default.createElement(
          "div",
          { className: "modal-footer" },
          _react2.default.createElement(
            "button",
            { className: "btn btn-default btn-danger", onClick: function onClick() {
                return onComfirmDeleteVre(vreId, confirmValue);
              }, disabled: vreId !== confirmValue },
            "Delete"
          ),
          _react2.default.createElement(
            "button",
            { className: "btn btn-default", onClick: onClose },
            "Cancel"
          )
        )
      );
    }
  }]);

  return DeleteVreConfirmationForm;
}(_react2.default.Component);

exports.default = DeleteVreConfirmationForm;

},{"react":"react"}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = require("react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Modal = function (_React$Component) {
  _inherits(Modal, _React$Component);

  function Modal(props) {
    _classCallCheck(this, Modal);

    var _this = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, props));

    _this.documentClickListener = _this.handleDocumentClick.bind(_this);
    return _this;
  }

  _createClass(Modal, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      document.addEventListener("click", this.documentClickListener, false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener("click", this.documentClickListener, false);
    }
  }, {
    key: "handleDocumentClick",
    value: function handleDocumentClick(ev) {
      if (!_reactDom2.default.findDOMNode(this).firstChild.contains(ev.target)) {
        this.props.onClose();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _props = this.props,
          onClose = _props.onClose,
          header = _props.header;


      var headerBody = header ? _react2.default.createElement(
        "h5",
        { className: "modal-title" },
        header
      ) : null;

      return _react2.default.createElement(
        "div",
        { className: "modal", style: { display: "block", backgroundColor: "rgba(0,0,0,0.4)" } },
        _react2.default.createElement(
          "div",
          { className: "modal-dialog" },
          _react2.default.createElement(
            "div",
            { className: "modal-content" },
            _react2.default.createElement(
              "div",
              { className: "modal-header" },
              _react2.default.createElement(
                "button",
                { className: "close", onClick: onClose },
                "\xD7"
              ),
              headerBody
            ),
            this.props.children
          )
        )
      );
    }
  }]);

  return Modal;
}(_react2.default.Component);

exports.default = Modal;

},{"react":"react","react-dom":"react-dom"}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = require("react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SelectField = function (_React$Component) {
  _inherits(SelectField, _React$Component);

  function SelectField(props) {
    _classCallCheck(this, SelectField);

    var _this = _possibleConstructorReturn(this, (SelectField.__proto__ || Object.getPrototypeOf(SelectField)).call(this, props));

    _this.state = {
      isOpen: false
    };
    _this.documentClickListener = _this.handleDocumentClick.bind(_this);
    return _this;
  }

  _createClass(SelectField, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      document.addEventListener("click", this.documentClickListener, false);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      document.removeEventListener("click", this.documentClickListener, false);
    }
  }, {
    key: "toggleSelect",
    value: function toggleSelect() {
      if (this.state.isOpen) {
        this.setState({ isOpen: false });
      } else {
        this.setState({ isOpen: true });
      }
    }
  }, {
    key: "handleDocumentClick",
    value: function handleDocumentClick(ev) {
      var isOpen = this.state.isOpen;

      if (isOpen && !_reactDom2.default.findDOMNode(this).contains(ev.target)) {
        this.setState({
          isOpen: false
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          onChange = _props.onChange,
          onClear = _props.onClear,
          value = _props.value;


      var selectedOption = _react2.default.Children.toArray(this.props.children).filter(function (opt) {
        return opt.props.value === value;
      });
      var placeholder = _react2.default.Children.toArray(this.props.children).filter(function (opt) {
        return opt.props.type === "placeholder";
      });
      var otherOptions = _react2.default.Children.toArray(this.props.children).filter(function (opt) {
        return opt.props.value && opt.props.value !== value;
      });

      return _react2.default.createElement(
        "div",
        { className: (0, _classnames2.default)("dropdown", { open: this.state.isOpen }), style: this.props.style || {} },
        _react2.default.createElement(
          "button",
          { className: "btn btn-blank dropdown-toggle", onClick: this.toggleSelect.bind(this) },
          selectedOption.length ? selectedOption : placeholder,
          " ",
          _react2.default.createElement("span", { className: "caret" })
        ),
        _react2.default.createElement(
          "ul",
          { className: "dropdown-menu" },
          value ? _react2.default.createElement(
            "li",
            null,
            _react2.default.createElement(
              "a",
              { onClick: function onClick() {
                  onClear();_this2.toggleSelect();
                } },
              "- clear -"
            )
          ) : null,
          otherOptions.map(function (option, i) {
            return _react2.default.createElement(
              "li",
              { key: i },
              _react2.default.createElement(
                "a",
                { style: { cursor: "pointer" }, onClick: function onClick() {
                    onChange(option.props.value);_this2.toggleSelect();
                  } },
                option
              )
            );
          })
        )
      );
    }
  }]);

  return SelectField;
}(_react2.default.Component);

SelectField.propTypes = {
  onChange: _react2.default.PropTypes.func,
  onClear: _react2.default.PropTypes.func,
  value: _react2.default.PropTypes.string
};

exports.default = SelectField;

},{"classnames":2,"react":"react","react-dom":"react-dom"}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FirstUpload(props) {
  var userId = props.userId;


  var sampleSheet = props.exampleSheetUrl ? _react2.default.createElement(
    "p",
    null,
    "Don't have a dataset handy? Here\u2019s an ",
    _react2.default.createElement(
      "a",
      { href: props.exampleSheetUrl },
      "example excel sheet"
    ),
    "."
  ) : null;

  return _react2.default.createElement(
    "div",
    { className: "container" },
    _react2.default.createElement(
      "div",
      { className: "jumbotron first-upload upload-bg" },
      _react2.default.createElement(
        "h2",
        null,
        "Upload your first dataset"
      ),
      sampleSheet,
      userId ? props.children : _react2.default.createElement(
        "form",
        { action: "https://secure.huygens.knaw.nl/saml2/login", method: "POST" },
        _react2.default.createElement("input", { name: "hsurl", type: "hidden", value: window.location.href }),
        _react2.default.createElement(
          "p",
          null,
          "Most university accounts will work."
        ),
        _react2.default.createElement(
          "button",
          { className: "btn btn-primary btn-lg", type: "submit" },
          _react2.default.createElement("span", { className: "glyphicon glyphicon-log-in" }),
          " Log in to upload"
        )
      )
    )
  );
}

exports.default = FirstUpload;

},{"react":"react"}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Footer(props) {
  var hiLogo = _react2.default.createElement(
    "div",
    { className: "col-sm-1 col-md-1" },
    _react2.default.createElement("img", { className: "hi-logo", src: "images/logo-huygens-ing.svg" })
  );

  var clariahLogo = _react2.default.createElement(
    "div",
    { className: "col-sm-1 col-md-1" },
    _react2.default.createElement("img", { className: "logo", src: "images/logo-clariah.svg" })
  );

  var footerBody = _react2.default.Children.count(props.children) > 0 ? _react2.default.Children.map(props.children, function (child, i) {
    return _react2.default.createElement(
      "div",
      { className: "white-bar" },
      _react2.default.createElement(
        "div",
        { className: "container" },
        i === _react2.default.Children.count(props.children) - 1 ? _react2.default.createElement(
          "div",
          { className: "row" },
          hiLogo,
          _react2.default.createElement(
            "div",
            { className: "col-sm-10 col-md-10 text-center" },
            child
          ),
          clariahLogo
        ) : _react2.default.createElement(
          "div",
          { className: "row" },
          _react2.default.createElement(
            "div",
            { className: "col-sm-12 col-md-12 text-center" },
            child
          )
        )
      )
    );
  }) : _react2.default.createElement(
    "div",
    { className: "white-bar" },
    _react2.default.createElement(
      "div",
      { className: "container" },
      _react2.default.createElement(
        "div",
        { className: "row" },
        hiLogo,
        _react2.default.createElement("div", { className: "col-sm-10 col-md-10 text-center" }),
        clariahLogo
      )
    )
  );

  return _react2.default.createElement(
    "footer",
    { className: "footer" },
    footerBody
  );
}

exports.default = Footer;

},{"react":"react"}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (props) {
  var dismissible = props.dismissible,
      alertLevel = props.alertLevel,
      onCloseMessage = props.onCloseMessage;

  var dismissButton = dismissible ? _react2.default.createElement(
    "button",
    { type: "button", className: "close", onClick: onCloseMessage },
    _react2.default.createElement(
      "span",
      null,
      "\xD7"
    )
  ) : null;

  return _react2.default.createElement(
    "div",
    { className: (0, _classnames2.default)("alert", "alert-" + alertLevel, { "alert-dismissible": dismissible }), role: "alert" },
    dismissButton,
    props.children
  );
};

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;

},{"classnames":2,"react":"react"}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _datasetCards = require("./dataset-cards");

var _datasetCards2 = _interopRequireDefault(_datasetCards);

var _footer = require("./footer");

var _footer2 = _interopRequireDefault(_footer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FOOTER_HEIGHT = 81;

function Page(props) {
  return _react2.default.createElement(
    "div",
    { className: "page" },
    _react2.default.createElement(
      "div",
      { className: "basic-margin hi-Green container-fluid" },
      _react2.default.createElement(
        "nav",
        { className: "navbar " },
        _react2.default.createElement(
          "div",
          { className: "container" },
          _react2.default.createElement(
            "div",
            { className: "navbar-header" },
            " ",
            _react2.default.createElement(
              "a",
              { className: "navbar-brand", href: "#" },
              _react2.default.createElement("img", { src: "images/logo-timbuctoo.svg", className: "logo", alt: "timbuctoo" })
            ),
            " "
          ),
          _react2.default.createElement(
            "div",
            { id: "navbar", className: "navbar-collapse collapse" },
            _react2.default.createElement(
              "ul",
              { className: "nav navbar-nav navbar-right" },
              props.username ? _react2.default.createElement(
                "li",
                null,
                _react2.default.createElement(
                  "a",
                  { href: props.userlocation || '#' },
                  _react2.default.createElement("span", { className: "glyphicon glyphicon-user" }),
                  " ",
                  props.username
                )
              ) : null
            )
          )
        )
      )
    ),
    _react2.default.createElement(
      "div",
      { style: { marginBottom: FOOTER_HEIGHT + "px" } },
      props.children,
      props.vres && props.showDatasets ? _react2.default.createElement(
        "div",
        { className: "container" },
        _react2.default.createElement(_datasetCards2.default, { caption: "Explore all datasets", vres: props.vres, searchGuiUrl: props.searchGuiUrl, onDeleteVreClick: props.onDeleteVreClick })
      ) : null
    ),
    _react2.default.createElement(_footer2.default, null)
  );
}

exports.default = Page;

},{"./dataset-cards":126,"./footer":133,"react":"react"}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DataRow = function (_React$Component) {
  _inherits(DataRow, _React$Component);

  function DataRow() {
    _classCallCheck(this, DataRow);

    return _possibleConstructorReturn(this, (DataRow.__proto__ || Object.getPrototypeOf(DataRow)).apply(this, arguments));
  }

  _createClass(DataRow, [{
    key: "render",
    value: function render() {
      var row = this.props.row;

      return _react2.default.createElement(
        "tr",
        null,
        row.map(function (cell, i) {
          return _react2.default.createElement(
            "td",
            { className: (0, _classnames2.default)({
                danger: cell.error ? true : false
              }), key: i },
            cell.value,
            cell.error ? _react2.default.createElement("span", { className: "pull-right glyphicon glyphicon-exclamation-sign", style: { cursor: "pointer" }, title: cell.error }) : null
          );
        })
      );
    }
  }]);

  return DataRow;
}(_react2.default.Component);

DataRow.propTypes = {
  row: _react2.default.PropTypes.array
};

exports.default = DataRow;

},{"classnames":2,"react":"react"}],137:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HeaderCell = function (_React$Component) {
  _inherits(HeaderCell, _React$Component);

  function HeaderCell() {
    _classCallCheck(this, HeaderCell);

    return _possibleConstructorReturn(this, (HeaderCell.__proto__ || Object.getPrototypeOf(HeaderCell)).apply(this, arguments));
  }

  _createClass(HeaderCell, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          header = _props.header,
          isConfirmed = _props.isConfirmed;


      return _react2.default.createElement(
        "th",
        { className: (0, _classnames2.default)({
            success: isConfirmed,
            info: !isConfirmed
          }) },
        header,
        _react2.default.createElement("span", { className: (0, _classnames2.default)("pull-right", "glyphicon", {
            "glyphicon-ok-sign": isConfirmed,
            "glyphicon-question-sign": !isConfirmed
          }) })
      );
    }
  }]);

  return HeaderCell;
}(_react2.default.Component);

HeaderCell.propTypes = {
  header: _react2.default.PropTypes.string,
  isConfirmed: _react2.default.PropTypes.bool
};

exports.default = HeaderCell;

},{"classnames":2,"react":"react"}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UploadButton = function (_React$Component) {
  _inherits(UploadButton, _React$Component);

  function UploadButton() {
    _classCallCheck(this, UploadButton);

    return _possibleConstructorReturn(this, (UploadButton.__proto__ || Object.getPrototypeOf(UploadButton)).apply(this, arguments));
  }

  _createClass(UploadButton, [{
    key: "render",
    value: function render() {
      var _props = this.props,
          classNames = _props.classNames,
          redirectPath = _props.redirectPath,
          uploadStatus = _props.uploadStatus,
          onUploadFileSelect = _props.onUploadFileSelect,
          glyphicon = _props.glyphicon,
          label = _props.label,
          vreName = _props.vreName,
          vreId = _props.vreId,
          float = _props.float,
          accept = _props.accept;

      return _react2.default.createElement(
        "form",
        { style: { display: "inline-block", float: float || "right" } },
        _react2.default.createElement(
          "label",
          { className: _classnames2.default.apply(undefined, _toConsumableArray(classNames).concat([{ disabled: !!uploadStatus }])) },
          _react2.default.createElement("span", { className: glyphicon }),
          " ",
          uploadStatus || label,
          _react2.default.createElement("input", {
            disabled: !!uploadStatus,
            onChange: function onChange(e) {
              return onUploadFileSelect(e.target.files, {
                vreName: vreName,
                vreId: vreId,
                redirectTo: redirectPath || null
              });
            },
            accept: accept || "*",
            style: { display: "none" },
            type: "file" })
        )
      );
    }
  }]);

  return UploadButton;
}(_react2.default.Component);

exports.default = UploadButton;

},{"classnames":2,"react":"react"}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (appState) {
  return {
    userId: appState.userdata.userId,
    vres: appState.userdata.myVres || {},
    searchGuiUrl: appState.datasets.searchGuiUrl,
    showDeleteVreModalFor: appState.datasets.vreIdOfDeleteVreModal,
    showDeleteVreFailedMessage: appState.messages.showDeleteVreFailedMessage
  };
};

},{}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _table = require("./transformers/table");

var _tabs = require("./transformers/tabs");

var _generateRmlMapping = require("../util/generate-rml-mapping");

var _generateRmlMapping2 = _interopRequireDefault(_generateRmlMapping);

var _uniq = require("../util/uniq");

var _publishState = require("../util/publish-state");

var _publishState2 = _interopRequireDefault(_publishState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getTargetableVres(mine, vres, activeVre) {
  var myVres = Object.keys(mine || {}).map(function (key) {
    return mine[key];
  }).filter(function (vre) {
    return vre.published;
  }).map(function (vre) {
    return vre.name;
  });
  var publicVres = Object.keys(vres || {}).map(function (key) {
    return vres[key].name;
  });

  return myVres.concat(publicVres).reduce(_uniq.uniq, []).filter(function (vre) {
    return vre !== activeVre;
  });
}

exports.default = function (appState, routed) {
  var collections = appState.importData.collections;
  var mappings = appState.mappings,
      activeCollection = appState.activeCollection,
      archetype = appState.archetype,
      customProperties = appState.customProperties,
      allPredicateObjectMappings = appState.predicateObjectMappings;
  var myVres = appState.userdata.myVres,
      publicVres = appState.datasets.publicVres;


  var predicateObjectMappings = allPredicateObjectMappings[activeCollection.name] || [];

  var archetypeName = (mappings.collections[activeCollection.name] || {}).archetypeName;
  var archetypeFields = archetypeName !== null && mappings.collections[activeCollection.name] ? archetype[archetypeName] : [];

  var columnHeaders = (0, _table.transformCollectionColumns)(collections, activeCollection, mappings, predicateObjectMappings);

  var collectionTabs = (0, _tabs.transformCollectionTabs)(collections, mappings, activeCollection, allPredicateObjectMappings);

  var availableArchetypes = Object.keys(mappings.collections).map(function (key) {
    return mappings.collections[key].archetypeName;
  });

  var availableCollectionColumnsPerArchetype = availableArchetypes.map(function (archetypeName) {
    return {
      key: archetypeName,
      values: Object.keys(mappings.collections).filter(function (collectionName) {
        return mappings.collections[collectionName].archetypeName === archetypeName;
      }).map(function (collectionName) {
        return {
          collectionName: collectionName,
          columns: collections.find(function (coll) {
            return coll.name === collectionName;
          }).variables
        };
      })
    };
  }).reduce(function (accum, cur) {
    return _extends({}, accum, _defineProperty({}, cur.key, cur.values));
  }, {});

  return {
    // from router
    vreId: routed.params.vreId,
    // transformed for view
    tabs: collectionTabs,

    // messages
    showCollectionsAreConnectedMessage: appState.messages.showCollectionsAreConnectedMessage,

    // from active collection for table
    activeCollection: activeCollection.name,
    firstMappedCollection: archetypeName === null && collectionTabs.length > 0 ? collectionTabs[0].collectionName : null,
    rows: (0, _table.transformCollectionRows)(collections, activeCollection, mappings),
    headers: columnHeaders,
    nextUrl: activeCollection.nextUrl,

    // from import data
    uploadStatus: appState.importData.uploadStatus,
    uploadedFilename: appState.importData.uploadedFileName,
    vre: appState.importData.vre,

    // form data
    archetypeFields: archetypeFields,
    availableArchetypes: availableArchetypes,
    availableCollectionColumnsPerArchetype: availableCollectionColumnsPerArchetype,
    columns: (0, _table.getColumnInfo)(collections, activeCollection, mappings).columns,
    predicateObjectMappings: predicateObjectMappings,
    publishErrors: appState.importData.publishErrors,
    publishEnabled: !appState.importData.publishing && myVres[routed.params.vreId].publishState !== _publishState2.default.MAPPING_EXECUTION && collectionTabs.every(function (tab) {
      return tab.complete;
    }),
    publishStatus: appState.importData.publishStatus ? appState.importData.publishStatus : myVres[routed.params.vreId].publishState === _publishState2.default.MAPPING_EXECUTION ? "Publishing" : "Publish dataset",
    customProperties: customProperties[activeCollection.name] || [],
    targetableVres: getTargetableVres(myVres, publicVres, appState.importData.vre),
    hasMappingErrors: myVres[routed.params.vreId].publishState === _publishState2.default.MAPPING_CREATION_AFTER_ERRORS,

    // ctrl-shift-F4
    rmlPreviewData: appState.previewRml.showRMLPreview ? (0, _generateRmlMapping2.default)(appState.importData.vre, appState.mappings.collections, allPredicateObjectMappings) : null
  };
};

},{"../util/generate-rml-mapping":166,"../util/publish-state":167,"../util/uniq":169,"./transformers/table":144,"./transformers/tabs":145}],141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _table = require("./transformers/table");

var _generateRmlMapping = require("../util/generate-rml-mapping");

var _generateRmlMapping2 = _interopRequireDefault(_generateRmlMapping);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (appState, routed) {
  var collections = appState.importData.collections;
  var activeCollection = appState.activeCollection,
      mappings = appState.mappings;


  return {
    vreId: routed.params.vreId,
    collections: appState.importData.collections,
    uploadedFileName: appState.importData.uploadedFileName,
    archetype: appState.archetype,
    mappings: appState.mappings,
    showFileIsUploadedMessage: appState.messages.showFileIsUploadedMessage,
    vre: appState.importData.vre,

    // from active collection for table
    activeCollection: activeCollection.name,
    rows: (0, _table.transformCollectionRows)(collections, activeCollection),
    headers: (0, _table.transformCollectionColumns)(collections, activeCollection, mappings),
    nextUrl: activeCollection.nextUrl,

    // ctrl-shift-F4
    rmlPreviewData: appState.previewRml.showRMLPreview ? (0, _generateRmlMapping2.default)(appState.importData.vre, appState.mappings.collections, []) : null
  };
};

},{"../util/generate-rml-mapping":166,"./transformers/table":144}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (appState, routed) {
  var vreId = routed.params.vreId;
  var vreData = vreId ? appState.userdata.myVres[vreId] || {
    vreMetadata: {}
  } : {
    vreMetadata: {}
  };
  var vreLabel = vreData.label,
      _vreData$vreMetadata = vreData.vreMetadata,
      provenance = _vreData$vreMetadata.provenance,
      colorCode = _vreData$vreMetadata.colorCode,
      description = _vreData$vreMetadata.description,
      image = _vreData$vreMetadata.image,
      uploadedFilename = _vreData$vreMetadata.uploadedFilename;

  return {
    newVreName: appState.datasetSettings.newVreName || vreLabel,
    newDescription: appState.datasetSettings.description === null ? description : appState.datasetSettings.description,
    newProvenance: appState.datasetSettings.provenance === null ? provenance : appState.datasetSettings.provenance,
    newColorCode: appState.datasetSettings.colorCode === null ? colorCode : appState.datasetSettings.colorCode,
    uploadStatus: appState.importData.uploadStatus,
    publishState: vreData.publishState,
    vreId: vreId,
    uploadedFileName: appState.importData.uploadedFileName,
    uploadedFilenameFromVre: uploadedFilename,
    imageUploadStatus: appState.datasetSettings.imageUploadStatus,
    imageUploadErrorMessage: appState.datasetSettings.imageUploadErrorMessage,
    imageUrl: image
  };
};

},{}],143:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (state, routed) {
  var pathname = routed.location.pathname;


  return {
    username: state.userdata.userId,
    vres: state.datasets.publicVres.filter(function (vre) {
      return vre.name !== "Admin" && vre.name !== "Base";
    }),
    searchGuiUrl: state.datasets.searchGuiUrl,
    showDatasets: pathname === "/" /* || pathname === urls.collectionsOverview(),*/
  };
};

},{}],144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getColumnInfo = exports.transformCollectionRows = exports.transformCollectionColumns = undefined;

var _propertyMappings = require("../../accessors/property-mappings");

var sheetRowFromDictToArray = function sheetRowFromDictToArray(rowdict, arrayOfVariableNames, mappingErrors) {
  return arrayOfVariableNames.map(function (name) {
    return {
      value: rowdict[name],
      error: mappingErrors[name] || null
    };
  });
};

var getColumnInfo = function getColumnInfo(collections, activeCollection, mappings) {
  var collectionInfo = (collections || []).find(function (coll) {
    return coll.name === activeCollection.name;
  });
  var columns = collectionInfo ? collectionInfo.variables : null;

  return { columns: columns };
};

var transformCollectionRows = function transformCollectionRows(collections, activeCollection, mappings) {
  var _getColumnInfo = getColumnInfo(collections, activeCollection, mappings),
      columns = _getColumnInfo.columns;

  return activeCollection.name && columns ? activeCollection.rows.map(function (row) {
    return sheetRowFromDictToArray(row.values, columns, row.errors);
  }) : [];
};

var transformCollectionColumns = function transformCollectionColumns(collections, activeCollection, mappings) {
  var predicateObjectMappings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  var _getColumnInfo2 = getColumnInfo(collections, activeCollection, mappings),
      columns = _getColumnInfo2.columns;

  return (columns || []).map(function (column, i) {
    return {
      name: column,
      isConfirmed: (0, _propertyMappings.propertyMappingIsComplete)(predicateObjectMappings.find(function (pom) {
        return (0, _propertyMappings.getColumnValue)(pom) === column;
      }))
    };
  });
};

exports.transformCollectionColumns = transformCollectionColumns;
exports.transformCollectionRows = transformCollectionRows;
exports.getColumnInfo = getColumnInfo;

},{"../../accessors/property-mappings":105}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformCollectionTabs = undefined;

var _propertyMappings = require("../../accessors/property-mappings");

var _uniq = require("../../util/uniq");

var mappingsAreComplete = function mappingsAreComplete(predicateObjectMappings) {
  return predicateObjectMappings.length > 0 && predicateObjectMappings.filter(function (pom) {
    return !(0, _propertyMappings.propertyMappingIsComplete)(pom);
  }).length === 0;
};

var transformCollectionTabs = function transformCollectionTabs(collections, mappings, activeCollection, predicateObjectMappings) {
  return (collections || []).filter(function (collection) {
    return typeof mappings.collections[collection.name] !== "undefined";
  }).filter(function (collection) {
    return mappings.collections[collection.name].archetypeName !== null;
  }).map(function (collection) {
    return {
      collectionName: collection.name,
      archetypeName: mappings.collections[collection.name].archetypeName,
      active: activeCollection.name === collection.name,
      complete: mappingsAreComplete(predicateObjectMappings[collection.name] || [])
    };
  });
};

exports.transformCollectionTabs = transformCollectionTabs;

},{"../../accessors/property-mappings":105,"../../util/uniq":169}],146:[function(require,module,exports){
"use strict";

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = require("react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _store = require("./store");

var _store2 = _interopRequireDefault(_store);

var _xhr = require("xhr");

var _xhr2 = _interopRequireDefault(_xhr);

var _router = require("./router");

var _router2 = _interopRequireDefault(_router);

var _token = require("./token");

var _token2 = _interopRequireDefault(_token);

var _fetchMyVres = require("./actions/fetch-my-vres");

var _xhrMock = require("xhr-mock");

var _xhrMock2 = _interopRequireDefault(_xhrMock);

var _servermocks = require("./servermocks");

var _servermocks2 = _interopRequireDefault(_servermocks);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if ("" === "true") {
  console.log("Using mock server!");
  var orig = window.XMLHttpRequest;
  _xhrMock2.default.setup(); //mock window.XMLHttpRequest usages
  var mock = window.XMLHttpRequest;
  window.XMLHttpRequest = mock;
  _xhr2.default.XMLHttpRequest = mock;
  _xhr2.default.XDomainRequest = mock;
  (0, _servermocks2.default)(_xhrMock2.default, orig);
}

_xhr2.default.get("" + "/v2.1/javascript-globals", function (err, res) {
  var globals = JSON.parse(res.body);
  _store2.default.dispatch({ type: "SET_SEARCH_URL", data: globals.env.TIMBUCTOO_SEARCH_URL });
});

_xhr2.default.get("" + "/v2.1/system/vres", function (err, resp, body) {
  _store2.default.dispatch({ type: "SET_PUBLIC_VRES", payload: JSON.parse(body) });
});

var initialRender = function initialRender() {
  return _reactDom2.default.render(_router2.default, document.getElementById("app"));
};

document.addEventListener("DOMContentLoaded", function () {

  (0, _xhr2.default)("" + "/v2.1/metadata/Admin", function (err, resp) {

    _store2.default.dispatch({ type: "SET_ARCHETYPE_METADATA", data: JSON.parse(resp.body) });
    var token = (0, _token2.default)();
    if (token) {
      _store2.default.dispatch((0, _fetchMyVres.fetchMyVres)(token, function () {
        return initialRender();
      }));
    } else {
      initialRender();
    }
  });
});

var comboMap = {
  ctrl: false,
  shift: false,
  f4: false
};

var keyMap = {
  17: "ctrl",
  16: "shift",
  115: "f4"
};

document.addEventListener("keydown", function (ev) {
  if (keyMap[ev.keyCode]) {
    comboMap[keyMap[ev.keyCode]] = true;
  }

  if (Object.keys(comboMap).map(function (k) {
    return comboMap[k];
  }).filter(function (isPressed) {
    return isPressed;
  }).length === 3) {
    _store2.default.dispatch({ type: "PREVIEW_RML" });
  }

  if (ev.keyCode === 27) {
    _store2.default.dispatch({ type: "HIDE_RML_PREVIEW" });
  }
});

document.addEventListener("keyup", function (ev) {
  if (keyMap[ev.keyCode]) {
    comboMap[keyMap[ev.keyCode]] = false;
  }
});

},{"./actions/fetch-my-vres":109,"./router":159,"./servermocks":160,"./store":161,"./token":162,"react":"react","react-dom":"react-dom","xhr":103,"xhr-mock":99}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "FINISH_UPLOAD":
    case "PUBLISH_START":
      return _extends({}, initialState);
    case "RECEIVE_ACTIVE_COLLECTION":
      return _extends({}, state, {
        name: action.data.name,
        nextUrl: action.data._next,
        rows: action.data.name !== state.name ? action.data.items : state.rows.concat(action.data.items)
      });
  }

  return state;
};

var initialState = {
  name: null,
  nextUrl: null,
  rows: []
};

},{}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	var action = arguments[1];

	switch (action.type) {
		case "SET_ARCHETYPE_METADATA":
			return action.data;
	}

	return state;
};

var initialState = {};

},{}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "FINISH_UPLOAD":
    case "RECEIVE_MY_VRES":
      return initialState;
    case "ADD_CUSTOM_PROPERTY":
      return addCustomProperty(state, action);
    case "REMOVE_CUSTOM_PROPERTY":
      return removeCustomProperty(state, action);
  }

  return state;
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var initialState = {};

var addCustomProperty = function addCustomProperty(state, action) {
  var collectionCustomProperties = state[action.collection] || [];

  var customProperty = {
    propertyType: action.propertyType,
    propertyName: action.propertyName
  };

  return _extends({}, state, _defineProperty({}, action.collection, collectionCustomProperties.concat(customProperty)));
};

var removeCustomProperty = function removeCustomProperty(state, action) {
  var collectionCustomProperties = state[action.collection] || [];

  return _extends({}, state, _defineProperty({}, action.collection, collectionCustomProperties.filter(function (prop, idx) {
    return idx !== action.index;
  })));
};

},{}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "CLEAR_DATASET_SETTINGS":
      return _extends({}, initialState);
    case "FINISH_UPLOAD":
      return _extends({}, state, {
        newVreName: null
      });
    case "SET_NEW_VRE_NAME":
      return _extends({}, state, {
        newVreName: action.newVreName.length > 0 ? action.newVreName : null
      });
    case "SET_PROVENANCE":
      return _extends({}, state, {
        provenance: action.provenance
      });
    case "SET_DESCRIPTION":
      return _extends({}, state, {
        description: action.description
      });
    case "SET_COLOR_CODE":
      return _extends({}, state, {
        colorCode: action.colorCode
      });
    case "IMAGE_UPLOAD_STARTED":
      return _extends({}, state, {
        imageUploadStatus: "Uploading image..."
      });
    case "IMAGE_UPLOAD_ERROR":
      return _extends({}, state, {
        imageUploadErrorMessage: action.message
      });
    case "IMAGE_UPLOAD_SUCCESS":
    case "DISMISS_IMAGE_ERROR":
      return _extends({}, state, {
        imageUploadErrorMessage: null
      });
    case "IMAGE_UPLOAD_FINISHED":
      return _extends({}, state, {
        imageUploadStatus: null
      });
  }

  return state;
};

var initialState = {
  newVreName: null,
  provenance: null,
  description: null,
  colorCode: null,
  imageUploadStatus: null,
  imageUploadErrorMessage: null
};

},{}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "SET_SEARCH_URL":
      return _extends({}, state, {
        searchGuiUrl: action.data
      });
    case "SET_PUBLIC_VRES":
      return _extends({}, state, {
        publicVres: action.payload.filter(function (vre) {
          return vre.isPublished;
        })
      });
    case "SHOW_DELETE_VRE_MODAL":
      return _extends({}, state, {
        vreIdOfDeleteVreModal: action.vreId
      });
    case "BEFORE_DELETE_VRE":
      return _extends({}, state, {
        vreIdOfDeleteVreModal: null
      });
  }

  return state;
};

var initialState = {
  searchGuiUrl: undefined,
  publicVres: [],
  vreIdOfDeleteVreModal: null
};

},{}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "START_UPLOAD":
      return _extends({}, initialState, { uploadStatus: "transfering file", uploadedFileName: action.uploadedFileName });
    case "UPLOAD_STATUS_UPDATE":
      if (action.data) {
        var failures = state.failures || 0;
        var currentSheet = state.currentSheet || "";
        var rows = state.rows || 0;
        var prevRows = state.prevRows || 0;
        if (action.data.substr(0, "failure: ".length) === "failure: ") {
          failures += 1;
        } else if (action.data.substr(0, "sheet: ".length) === "sheet: ") {
          currentSheet = action.data.substr("sheet: ".length);
          prevRows = rows;
        } else {
          rows = action.data * 1 - prevRows;
        }
        var uploadStatus = "processing " + currentSheet + " (row " + rows + (failures > 0 ? ", " + failures + " failures" : "") + ")";
        return _extends({}, state, {
          failures: failures,
          rows: rows,
          currentSheet: currentSheet,
          uploadStatus: uploadStatus
        });
      }
      return state;
    case "FINISH_UPLOAD":
      return _extends({}, state, {
        uploadStatus: undefined,
        failures: 0,
        currentSheet: "",
        rows: undefined,
        publishErrors: false,
        uploadedFileName: action.uploadedFileName,
        vre: action.data.vre,
        saveMappingUrl: action.data.saveMapping,
        executeMappingUrl: action.data.executeMapping,
        collections: action.data.collections.map(function (col) {
          return _extends({}, col, {
            dataUrl: col.data,
            dataUrlWithErrors: col.dataWithErrors
          });
        })
      });

    case "PUBLISH_START":
      return _extends({}, state, {
        publishing: true
      });

    case "PUBLISH_STATUS_UPDATE":
      return _extends({}, state, {
        publishStatus: action.data
      });
    case "PUBLISH_HAD_ERROR":
      // clear the sheets to force reload
      return _extends({}, state, {
        publishErrors: true,
        collections: state.collections.map(function (col) {
          return _extends({}, col, {
            dataUrl: col.data,
            dataUrlWithErrors: col.dataWithErrors
          });
        })
      });
    case "PUBLISH_SUCCEEDED":
      // clear the sheets to force reload
      return _extends({}, state, {
        publishStatus: undefined,
        publishEnabled: true,
        publishErrors: false,
        collections: state.collections.map(function (col) {
          return _extends({}, col, {
            dataUrl: col.data,
            dataUrlWithErrors: col.dataWithErrors
          });
        })
      });
    case "PUBLISH_FINISHED":
      // clear the sheets to force reload
      return _extends({}, state, {
        publishStatus: undefined,
        publishEnabled: true,
        publishErrorCount: 0,
        tripleCount: 0,
        publishing: false
      });
  }

  return state;
};

var initialState = {
  isUploading: false,
  publishing: false,
  publishEnabled: true,
  publishStatus: undefined,
  publishErrorCount: 0,
  tripleCount: 0
};

},{}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = require("redux");

var _messages = require("./messages");

var _messages2 = _interopRequireDefault(_messages);

var _datasets = require("./datasets");

var _datasets2 = _interopRequireDefault(_datasets);

var _userdata = require("./userdata");

var _userdata2 = _interopRequireDefault(_userdata);

var _importData = require("./import-data");

var _importData2 = _interopRequireDefault(_importData);

var _archetype = require("./archetype");

var _archetype2 = _interopRequireDefault(_archetype);

var _mappings = require("./mappings");

var _mappings2 = _interopRequireDefault(_mappings);

var _activeCollection = require("./active-collection");

var _activeCollection2 = _interopRequireDefault(_activeCollection);

var _predicateObjectMappings = require("./predicate-object-mappings");

var _predicateObjectMappings2 = _interopRequireDefault(_predicateObjectMappings);

var _customProperties = require("./custom-properties");

var _customProperties2 = _interopRequireDefault(_customProperties);

var _previewRml = require("./preview-rml");

var _previewRml2 = _interopRequireDefault(_previewRml);

var _datasetSettings = require("./dataset-settings");

var _datasetSettings2 = _interopRequireDefault(_datasetSettings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _redux.combineReducers)({
  messages: _messages2.default,
  datasets: _datasets2.default,
  userdata: _userdata2.default,
  importData: _importData2.default,
  archetype: _archetype2.default,
  mappings: _mappings2.default,
  activeCollection: _activeCollection2.default,
  predicateObjectMappings: _predicateObjectMappings2.default,
  customProperties: _customProperties2.default,
  previewRml: _previewRml2.default,
  datasetSettings: _datasetSettings2.default
});

},{"./active-collection":147,"./archetype":148,"./custom-properties":149,"./dataset-settings":150,"./datasets":151,"./import-data":152,"./mappings":154,"./messages":155,"./predicate-object-mappings":156,"./preview-rml":157,"./userdata":158,"redux":91}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "START_UPLOAD":
      return initialState;

    case "FINISH_UPLOAD":
      return _extends({}, state, {
        collections: action.data.collections.reduce(scaffoldCollectionMappings, {})
      });

    case "MAP_COLLECTION_ARCHETYPE":
      return mapCollectionArchetype(state, action);

    case "MAP_COLLECTION_ARCHETYPES":
      return _extends({}, state, {
        collections: action.data
      });

  }
  return state;
};

var _setIn = require("../util/set-in");

var _setIn2 = _interopRequireDefault(_setIn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var initialState = {
  collections: {},
  confirmed: false,
  publishing: false
};

function scaffoldCollectionMappings(init, sheet) {
  return _extends(init, _defineProperty({}, sheet.name, {
    archetypeName: null
  }));
}

var mapCollectionArchetype = function mapCollectionArchetype(state, action) {
  var newCollections = (0, _setIn2.default)([action.collection, "archetypeName"], action.value, state.collections);

  return _extends({}, state, { collections: newCollections });
};

},{"../util/set-in":168}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "TOGGLE_MESSAGE":
      var newState = _extends({}, state);
      newState[action.messageId] = !state[action.messageId];
      return newState;
    case "FINISH_UPLOAD":
      return initialState;
    case "DELETE_VRE_ERROR":
      var newState1 = _extends({}, state);
      newState1.showDeleteVreFailedMessage = true;
      return newState1;
  }

  return state;
};

var initialState = {
  showFileIsUploadedMessage: true,
  showCollectionsAreConnectedMessage: true,
  showDeleteVreFailedMessage: false
};

},{}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "FINISH_UPLOAD":
    case "RECEIVE_MY_VRES":
    case "CLEAR_PREDICATE_OBJECT_MAPPINGS":
      return initialState;
    case "SET_PREDICATE_OBJECT_MAPPING":
      return setPredicateObjectMapping(state, action);
    case "REMOVE_PREDICATE_OBJECT_MAPPING":
      return removePredicateObjectMapping(state, action);
  }

  return state;
};

var _propertyMappings = require("../accessors/property-mappings");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var initialState = {};

function setBasicPredicateObjectMap(action, collectionPredicateObjectMappings) {
  var predicateObjectMap = {
    predicate: action.predicate,
    objectMap: {
      column: action.object
    },
    propertyType: action.propertyType
  };

  return collectionPredicateObjectMappings.filter(function (predObjMap) {
    return predObjMap.predicate !== action.predicate;
  }).concat(predicateObjectMap);
}

function setRelationPredicateObjectMap(action, collectionPredicateObjectMappings) {
  var predicateObjectMap = {
    predicate: action.predicate,
    objectMap: action.object,
    propertyType: action.propertyType,
    dataset: action.dataset
  };

  return collectionPredicateObjectMappings.filter(function (predObjMap) {
    return predObjMap.predicate !== action.predicate;
  }).concat(predicateObjectMap);
}

var setPredicateObjectMapping = function setPredicateObjectMapping(state, action) {
  var collectionPredicateObjectMappings = state[action.subjectCollection] || [];
  var newCollectionPredicateObjectMappings = action.propertyType === "relation" ? setRelationPredicateObjectMap(action, collectionPredicateObjectMappings) : setBasicPredicateObjectMap(action, collectionPredicateObjectMappings);

  return _extends({}, state, _defineProperty({}, action.subjectCollection, newCollectionPredicateObjectMappings));
};

var removePredicateObjectMapping = function removePredicateObjectMapping(state, action) {
  var collectionPredicateObjectMappings = state[action.subjectCollection] || [];

  return action.predicate === "names" ? _extends({}, state, _defineProperty({}, action.subjectCollection, collectionPredicateObjectMappings.filter(function (pom) {
    return !(pom.propertyType === "names" && ["forename", "surname", "nameLink", "genName", "roleName"].indexOf(pom.predicate) > -1);
  }))) : _extends({}, state, _defineProperty({}, action.subjectCollection, collectionPredicateObjectMappings.filter(function (pom) {
    return !(pom.predicate === action.predicate && (0, _propertyMappings.getColumnValue)(pom) === action.object);
  })));
};

},{"../accessors/property-mappings":105}],157:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case "PREVIEW_RML":
      return _extends({}, state, {
        showRMLPreview: true
      });
    case "HIDE_RML_PREVIEW":
      return _extends({}, state, {
        showRMLPreview: false
      });
  }

  return state;
};

var initialState = {
  showRMLPreview: false
};

},{}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  var newMyVres = void 0;

  switch (action.type) {
    case "RECEIVE_MY_VRES":
      return _extends({}, state, {
        userId: action.data,
        myVres: action.vreData ? action.vreData.mine : null
      });
    case "BEFORE_DELETE_VRE":
      newMyVres = _extends({}, state.myVres);
      if (newMyVres[action.vreId]) {
        newMyVres[action.vreId].deletePending = true;
      }
      return _extends({}, state, {
        myVres: newMyVres
      });
    case "DELETE_VRE_ERROR":
      newMyVres = _extends({}, state.myVres);
      if (newMyVres[action.vreId]) {
        newMyVres[action.vreId].deletePending = false;
      }
      return _extends({}, state, {
        myVres: newMyVres
      });
  }

  return state;
};

var initialState = {
  userId: undefined,
  myVres: undefined
};

},{}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.urls = undefined;
exports.navigateTo = navigateTo;

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactRouter = require("react-router");

var _reactRedux = require("react-redux");

var _store = require("./store");

var _store2 = _interopRequireDefault(_store);

var _actions = require("./actions");

var _actions2 = _interopRequireDefault(_actions);

var _token = require("./token");

var _token2 = _interopRequireDefault(_token);

var _pageConnector = require("./connectors/page-connector");

var _pageConnector2 = _interopRequireDefault(_pageConnector);

var _page = require("./components/page.jsx");

var _page2 = _interopRequireDefault(_page);

var _collectionOverview = require("./connectors/collection-overview");

var _collectionOverview2 = _interopRequireDefault(_collectionOverview);

var _collectionOverview3 = require("./components/collection-overview");

var _collectionOverview4 = _interopRequireDefault(_collectionOverview3);

var _connectToArchetype = require("./connectors/connect-to-archetype");

var _connectToArchetype2 = _interopRequireDefault(_connectToArchetype);

var _connectToArchetype3 = require("./components/connect-to-archetype");

var _connectToArchetype4 = _interopRequireDefault(_connectToArchetype3);

var _connectData = require("./connectors/connect-data");

var _connectData2 = _interopRequireDefault(_connectData);

var _connectData3 = require("./components/connect-data");

var _connectData4 = _interopRequireDefault(_connectData3);

var _datasetSettings = require("./connectors/dataset-settings");

var _datasetSettings2 = _interopRequireDefault(_datasetSettings);

var _datasetSettings3 = require("./components/dataset-settings");

var _datasetSettings4 = _interopRequireDefault(_datasetSettings3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var urls = {
  root: function root() {
    return "/";
  },
  newDataset: function newDataset() {
    return "/dataset-settings";
  },
  editDataset: function editDataset(vreId) {
    return vreId ? "/dataset-settings/" + vreId : "/dataset-settings/:vreId";
  },
  mapData: function mapData(vreId) {
    return vreId ? "/mapdata/" + vreId : "/mapdata/:vreId";
  },
  mapArchetypes: function mapArchetypes(vreId) {
    return vreId ? "/maparchetypes/" + vreId : "/maparchetypes/:vreId";
  }
};

function navigateTo(key, args) {
  _reactRouter.hashHistory.push(urls[key].apply(null, args));
}

var defaultConnect = (0, _reactRedux.connect)(function (state) {
  return state;
}, function (dispatch) {
  return (0, _actions2.default)(navigateTo, dispatch);
});

var connectComponent = function connectComponent(stateToProps) {
  return (0, _reactRedux.connect)(stateToProps, function (dispatch) {
    return (0, _actions2.default)(navigateTo, dispatch);
  });
};

var filterAuthorized = function filterAuthorized(redirectTo) {
  return function (nextState, replace) {
    if (!(0, _token2.default)()) {
      replace(redirectTo);
    }
  };
};

exports.default = _react2.default.createElement(
  _reactRedux.Provider,
  { store: _store2.default },
  _react2.default.createElement(
    _reactRouter.Router,
    { history: _reactRouter.hashHistory },
    _react2.default.createElement(
      _reactRouter.Route,
      { path: "/", component: connectComponent(_pageConnector2.default)(_page2.default) },
      _react2.default.createElement(_reactRouter.IndexRoute, { component: connectComponent(_collectionOverview2.default)(_collectionOverview4.default) }),
      _react2.default.createElement(_reactRouter.Route, { onEnter: filterAuthorized("/"),
        path: urls.editDataset(), component: connectComponent(_datasetSettings2.default)(_datasetSettings4.default) }),
      _react2.default.createElement(_reactRouter.Route, { onEnter: filterAuthorized("/"),
        path: urls.newDataset(), component: connectComponent(_datasetSettings2.default)(_datasetSettings4.default) }),
      _react2.default.createElement(_reactRouter.Route, { onEnter: filterAuthorized("/"),
        path: urls.mapArchetypes(), component: connectComponent(_connectToArchetype2.default)(_connectToArchetype4.default) }),
      _react2.default.createElement(_reactRouter.Route, { onEnter: filterAuthorized("/"),
        path: urls.mapData(), component: connectComponent(_connectData2.default)(_connectData4.default) })
    )
  )
);
exports.urls = urls;

},{"./actions":106,"./components/collection-overview":121,"./components/connect-data":124,"./components/connect-to-archetype":125,"./components/dataset-settings":127,"./components/page.jsx":135,"./connectors/collection-overview":139,"./connectors/connect-data":140,"./connectors/connect-to-archetype":141,"./connectors/dataset-settings":142,"./connectors/page-connector":143,"./store":161,"./token":162,"react":"react","react-redux":42,"react-router":76}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = setupMocks;

var _publishState = require("./util/publish-state");

var _publishState2 = _interopRequireDefault(_publishState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function setupMocks(xhrmock, orig) {
  xhrmock.get("" + "/v2.1/metadata/Admin", function (req, resp) {
    return resp.status(200).body("{\n          \"persons\": [\n            {\n              \"name\": \"names\",\n              \"type\": \"names\"\n            },\n            {\n              \"name\": \"birthDate\",\n              \"type\": \"datable\"\n            },\n            {\n              \"name\": \"floruit\",\n              \"type\": \"text\"\n            },\n            {\n              \"name\": \"hasWritten\",\n              \"type\": \"relation\",\n              \"quicksearch\": \"/v2.1/domain/documents/autocomplete\",\n              \"relation\": {\n                \"direction\": \"OUT\",\n                \"outName\": \"hasWritten\",\n                \"inName\": \"wasWrittenBy\",\n                \"targetCollection\": \"documents\",\n                \"relationCollection\": \"relations\",\n                \"relationTypeId\": \"bba10d37-86cc-4f1f-ba2d-016af2b21aa4\"\n              }\n            },\n            {\n              \"name\": \"isRelatedTo\",\n              \"type\": \"relation\",\n              \"quicksearch\": \"/v2.1/domain/persons/autocomplete\",\n              \"relation\": {\n                \"direction\": \"OUT\",\n                \"outName\": \"isRelatedTo\",\n                \"inName\": \"isRelatedTo\",\n                \"targetCollection\": \"persons\",\n                \"relationCollection\": \"relations\",\n                \"relationTypeId\": \"cba10d37-86cc-4f1f-ba2d-016af2b21aa5\"\n              }\n            }\n          ],\n          \"documents\": [\n            {\n              \"name\": \"title\",\n              \"type\": \"text\"\n            }\n          ]\n        }");
  }).get("" + "/v2.1/system/users/me/vres", function (req, resp) {
    console.log("fetch-my-vres");
    return resp.status(200).body("{\n          \"mine\": {\n            \"migrant_steekproef_masterdb (6).xlsx\": {\n              \"name\": \"migrant_steekproef_masterdb (6).xlsx\",\n              \"published\": true\n            },\n            \"thevrename\": {\n              \"name\": \"thevrename\",\n              \"published\": false,\n              \"publishState\": \"" + _publishState2.default.MAPPING_CREATION + "\",\n              \"rmlUri\": \"<<The get raw data url that the server provides>>\"\n            }\n          },\n          \"public\": {\n            \"WomenWriters\": {\n              \"name\": \"WomenWriters\"\n            }\n          }\n        }");
  }).post("" + "/v2.1/bulk-upload", function (req, resp) {
    console.log("bulk-upload");
    return resp.status(200).header("Location", "" + "/v2.1/bulk-upload/thevrename");
  }).post("<<The execute mapping url that the server provides>>", function (req, resp) {
    console.log("execute mapping with failures", req.body());
    return resp.status(200).body(JSON.stringify({
      success: false
    }));
  }).post("<<The save mapping url that the server provides>>", function (req, resp) {
    console.log("save mapping", req.body());
    localStorage.setItem("saved-mapping", req.body());
    return resp.status(200).body(JSON.stringify({
      success: true
    }));
  }).get("" + "/v2.1/bulk-upload/thevrename", function (req, resp) {
    console.log("Get VRE information, saved mapping: ", localStorage.getItem("saved-mapping"));
    return resp.status(200).body(JSON.stringify({
      vre: "thevrename",
      saveMapping: "<<The save mapping url that the server provides>>",
      executeMapping: "<<The execute mapping url that the server provides>>",
      savedMappingState: JSON.parse(localStorage.getItem("saved-mapping") || "null"),
      collections: [{
        name: "mockpersons",
        variables: ["ID", "Voornaam", "tussenvoegsel", "Achternaam", "GeschrevenDocument", "Genoemd in", "Is getrouwd met"],
        data: "<<url for person data>>",
        dataWithErrors: "<<url for person data with errors>>"
      }, {
        name: "mockdocuments",
        variables: ["titel", "datum", "referentie", "url"],
        data: "<<url for document data>>",
        dataWithErrors: "<<url for document data with errors>>"
      }]
    }));
  }).delete("" + "/v2.1/bulk-upload/thevrename", function (req, resp) {
    console.log("delete vre");
    return resp.status(403);
  }).get("<<url for person data>>", function (req, resp) {
    console.log("get person items data");
    return resp.status(200).body(JSON.stringify({
      "_next": "<<more data>>",
      "name": "mockpersons",
      "items": [{
        values: {
          "ID": "1",
          "Voornaam": "Voornaam",
          "tussenvoegsel": "tussenvoegsel",
          "Achternaam": "Achternaam",
          "GeschrevenDocument": "GeschrevenDocument",
          "Genoemd in": "Genoemd in",
          "Is getrouwd met": "Is getrouwd met"
        },
        errors: {}
      }, {
        values: {
          "ID": "2",
          "Voornaam": "Voornaam",
          "tussenvoegsel": "tussenvoegsel",
          "Achternaam": "Achternaam",
          "GeschrevenDocument": "GeschrevenDocument",
          "Genoemd in": "Genoemd in",
          "Is getrouwd met": "Is getrouwd met"
        },
        errors: {}
      }]
    }));
  }).get("<<url for person data>>?onlyErrors=true", function (req, resp) {
    console.log("get person items data with errors");
    return resp.status(200).body(JSON.stringify({
      "_next": "<<more data>>",
      "name": "mockpersons",
      "items": [{
        values: {
          "ID": "1",
          "Voornaam": "Voornaam",
          "tussenvoegsel": "tussenvoegsel",
          "Achternaam": "Achternaam",
          "GeschrevenDocument": "GeschrevenDocument",
          "Genoemd in": "Genoemd in",
          "Is getrouwd met": "Is getrouwd met"
        },
        errors: {
          "Voornaam": "will not do",
          "Achternaam": "also failed"
        }
      }]
    }));
  }).get("<<more data>>", function (req, resp) {
    console.log("get person items data");
    return resp.status(200).body(JSON.stringify({
      "name": "mockpersons",
      "items": [{
        values: {
          "ID": "3",
          "Voornaam": "Voornaam",
          "tussenvoegsel": "tussenvoegsel",
          "Achternaam": "Achternaam",
          "GeschrevenDocument": "GeschrevenDocument",
          "Genoemd in": "Genoemd in",
          "Is getrouwd met": "Is getrouwd met"
        },
        errors: {}
      }, {
        values: {
          "ID": "4",
          "Voornaam": "Voornaam",
          "tussenvoegsel": "tussenvoegsel",
          "Achternaam": "Achternaam",
          "GeschrevenDocument": "GeschrevenDocument",
          "Genoemd in": "Genoemd in",
          "Is getrouwd met": "Is getrouwd met"
        },
        errors: {}
      }]
    }));
  }).get("<<url for document data>>", function (req, resp) {
    console.log("get document items data");
    return resp.status(200).body(JSON.stringify({
      "name": "mockdocuments",
      "items": [{
        values: {
          "tim_id": "1",
          "titel": "titel",
          "datum": "datum",
          "referentie": "referentie",
          "url": "url"
        },
        errors: {}
      }, {
        values: {
          "tim_id": "2",
          "titel": "titel",
          "datum": "datum",
          "referentie": "referentie",
          "url": "url"
        },
        errors: {}
      }]
    }));
  }).get("<<url for document data>>?onlyErrors=true", function (req, resp) {
    console.log("get document items data with errors");
    return resp.status(200).body(JSON.stringify({
      "name": "mockdocuments",
      "items": []
    }));
  }).get("" + "/v2.1/javascript-globals", function (req, res) {
    console.log("get javascript globals");
    return res.status(200).body('{"env":{"TIMBUCTOO_SEARCH_URL":"http://example.com/"}}');
  }).get("" + "/v2.1/system/vres", function (req, res) {
    console.log("get public datasets");
    return res.status(200).body('[{"name":"CharterPortaal","metadata":"http://test.repository.huygens.knaw.nl/v2.1/metadata/CharterPortaal"},{"name":"EuropeseMigratie","metadata":"http://test.repository.huygens.knaw.nl/v2.1/metadata/EuropeseMigratie"}]');
  }).mock(function (req, resp) {
    if (req.url().match("browser-sync")) {
      console.warn("browser-sync disabled in mock mode");
    } else {
      console.error("unmocked request", req.url(), req, resp);
    }
  });
}

},{"./util/publish-state":167}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _redux = require("redux");

var _reduxThunk = require("redux-thunk");

var _reduxThunk2 = _interopRequireDefault(_reduxThunk);

var _reducers = require("./reducers");

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var logger = function logger() {
  return function (next) {
    return function (action) {
      if (action.hasOwnProperty("type")) {
        console.log("[REDUX]", action.type, action);
      }

      return next(action);
    };
  };
};

var createStoreWithMiddleware = (0, _redux.applyMiddleware)( /*logger,*/_reduxThunk2.default)(_redux.createStore);
exports.default = createStoreWithMiddleware(_reducers2.default);

},{"./reducers":153,"redux":91,"redux-thunk":85}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = function () {
  var path = window.location.search.substr(1);
  var params = path.split('&');

  for (var i in params) {
    var _params$i$split = params[i].split('='),
        _params$i$split2 = _slicedToArray(_params$i$split, 2),
        key = _params$i$split2[0],
        value = _params$i$split2[1];

    if (key === 'hsid') {
      return value;
    }
  }
  return null;
};

},{}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (camelCase) {
  return camelCase.replace(/([A-Z0-9])/g, function (match) {
    return " " + match.toLowerCase();
  }).trim().replace(/^./, function (match) {
    return match.toUpperCase();
  }).replace(/_/g, " ");
};

},{}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function deepClone9(obj) {
    var i, len, ret;

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object" || obj === null) {
        return obj;
    }

    if (Array.isArray(obj)) {
        ret = [];
        len = obj.length;
        for (i = 0; i < len; i++) {
            ret.push(_typeof(obj[i]) === "object" && obj[i] !== null ? deepClone9(obj[i]) : obj[i]);
        }
    } else {
        ret = {};
        for (i in obj) {
            if (obj.hasOwnProperty(i)) {
                ret[i] = _typeof(obj[i]) === "object" && obj[i] !== null ? deepClone9(obj[i]) : obj[i];
            }
        }
    }
    return ret;
}

exports.default = deepClone9;

},{}],165:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ["ce7060", "92e3fc", "fade8d", "9ce479", "e39061", "d3b2d6", "95cac4"];

},{}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultNamespace = exports.nameSpaces = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _propertyMappings = require("../accessors/property-mappings");

var defaultNamespace = "http://timbuctoo.huygens.knaw.nl/";

var nameSpaces = {
  surname: "http://www.tei-c.org/ns/1.0/",
  forename: "http://www.tei-c.org/ns/1.0/",
  roleName: "http://www.tei-c.org/ns/1.0/",
  nameLink: "http://www.tei-c.org/ns/1.0/",
  genName: "http://www.tei-c.org/ns/1.0/",
  sameAs: "http://www.w3.org/2002/07/owl#"
};

var rmlTemplate = {
  "@context": {
    "@vocab": "http://www.w3.org/ns/r2rml#",
    "rml": "http://semweb.mmlab.be/ns/rml#",
    "tim": "http://timbuctoo.huygens.knaw.nl/mapping#",
    "http://www.w3.org/2000/01/rdf-schema#subClassOf": {
      "@type": "@id"
    },
    "predicate": {
      "@type": "@id"
    },
    "termType": {
      "@type": "@id"
    },
    "parentTriplesMap": {
      "@type": "@id"
    },
    "class": {
      "@type": "@id"
    },
    "object": {
      "@type": "@id"
    }
  }
};

var getNameSpaceFor = function getNameSpaceFor(predicate) {
  return typeof nameSpaces[predicate] === "undefined" ? defaultNamespace : nameSpaces[predicate];
};

var makeMapName = function makeMapName(vre, localName) {
  return "http://timbuctoo.huygens.knaw.nl/mapping/" + vre + "/" + localName;
};

var mapBasicProperty = function mapBasicProperty(predicateObjectMap) {
  return {
    "objectMap": {
      "column": predicateObjectMap.objectMap.column,
      "termType": predicateObjectMap.propertyType === "sameAs" ? "http://www.w3.org/ns/r2rml#IRI" : undefined
      // "datatype": "valid IRI string"
    },
    "predicate": "" + getNameSpaceFor(predicateObjectMap.predicate) + predicateObjectMap.predicate
  };
};

var mapRelationProperty = function mapRelationProperty(vre, predicateObjectMap) {
  return {
    "objectMap": {
      "joinCondition": predicateObjectMap.objectMap.joinCondition,
      "parentTriplesMap": "http://timbuctoo.huygens.knaw.nl/mapping/" + vre + "/" + predicateObjectMap.objectMap.parentTriplesMap
    },
    "predicate": "" + getNameSpaceFor(predicateObjectMap.predicate) + predicateObjectMap.predicate
  };
};

var makePredicateObjectMap = function makePredicateObjectMap(vre, predicateObjectMap) {
  if ((0, _propertyMappings.isBasicProperty)(predicateObjectMap)) {
    return mapBasicProperty(predicateObjectMap);
  }

  if (predicateObjectMap.propertyType === "relation") {
    return mapRelationProperty(vre, predicateObjectMap);
  }

  return null;
};

var mapCollection = function mapCollection(vre, archetypeName, collectionName, predicateObjectMaps) {
  return {
    "@id": makeMapName(vre, collectionName),
    "http://www.w3.org/2000/01/rdf-schema#subClassOf": "http://timbuctoo.huygens.knaw.nl/" + archetypeName.replace(/s$/, ""),
    "rml:logicalSource": {
      "rml:source": {
        "tim:rawCollection": collectionName,
        "tim:vreName": vre
      }
    },
    "subjectMap": {
      "template": makeMapName(vre, collectionName) + "/{tim_id}"
    },
    "predicateObjectMap": [{ "object": makeMapName(vre, collectionName), "predicate": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" }].concat(predicateObjectMaps.map(function (pom) {
      return makePredicateObjectMap(vre, pom);
    }).filter(function (pom) {
      return pom !== null;
    }))
  };
};

exports.default = function (vre, collectionMappings, predicateObjectMappings) {
  return _extends({}, rmlTemplate, {
    "@graph": Object.keys(collectionMappings).filter(function (collectionName) {
      return collectionMappings[collectionName].archetypeName !== null;
    }).map(function (collectionName) {
      return mapCollection(vre, collectionMappings[collectionName].archetypeName, collectionName, predicateObjectMappings[collectionName] || []);
    })
  });
};

exports.nameSpaces = nameSpaces;
exports.defaultNamespace = defaultNamespace;

},{"../accessors/property-mappings":105}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = {
   UPLOADING: "UPLOADING",
   MAPPING_CREATION: "MAPPING_CREATION",
   MAPPING_EXECUTION: "MAPPING_EXECUTION",
   MAPPING_CREATION_AFTER_ERRORS: "MAPPING_CREATION_AFTER_ERRORS",
   AVAILABLE: "AVAILABLE"
};

},{}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _cloneDeep = require("./clone-deep");

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Do either of these:
//  a) Set a value by reference if deref is not null
//  b) Set a value directly in to data object if deref is null
var setEither = function setEither(data, deref, key, val) {
	(deref || data)[key] = val;
	return data;
};

// Set a nested value in data (not unlike immutablejs, but a clone of data is expected for proper immutability)
var _setIn = function _setIn(path, value, data) {
	var deref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	return path.length > 1 ? _setIn(path, value, data, deref ? deref[path.shift()] : data[path.shift()]) : setEither(data, deref, path[0], value);
};

var setIn = function setIn(path, value, data) {
	return _setIn((0, _cloneDeep2.default)(path), value, (0, _cloneDeep2.default)(data));
};

exports.default = setIn;

},{"./clone-deep":164}],169:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var uniq = function uniq(accum, cur) {
  return accum.indexOf(cur) < 0 ? accum.concat(cur) : accum;
};

exports.uniq = uniq;

},{}]},{},[146])(146)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9mb3ItZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwibm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvRE9NVXRpbHMuanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvUGF0aFV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL2NyZWF0ZURPTUhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9jcmVhdGVMb2NhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2hpc3RvcnkvbGliL2RlcHJlY2F0ZS5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2hpc3Rvcnkvbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeS1zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvY29ubmVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc3RvcmVTaGFwZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvQXN5bmNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL0hpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9JbmRleExpbmsuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJlZGlyZWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvSW5kZXhSb3V0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL0ludGVybmFsUHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvTGlmZWN5Y2xlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvTGluay5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL1Byb3BUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL1JlZGlyZWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUm91dGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZUNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUm91dGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvUm91dGluZ0NvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9hcHBseVJvdXRlck1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL2NvbXB1dGVDaGFuZ2VkUm91dGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVJvdXRlckhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9nZXRDb21wb25lbnRzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvZ2V0Um91dGVQYXJhbXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9oYXNoSGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvaXNBY3RpdmUuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9tYWtlU3RhdGVXaXRoTG9jYXRpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL21hdGNoUm91dGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9saWIvcm91dGVyV2FybmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlckhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2xpYi93aXRoUm91dGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlZHV4LXRodW5rL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJub2RlX21vZHVsZXMvcmVkdXgvbGliL2NvbWJpbmVSZWR1Y2Vycy5qcyIsIm5vZGVfbW9kdWxlcy9yZWR1eC9saWIvY29tcG9zZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWR1eC9saWIvY3JlYXRlU3RvcmUuanMiLCJub2RlX21vZHVsZXMvcmVkdXgvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwibm9kZV9tb2R1bGVzL3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvcG9ueWZpbGwuanMiLCJub2RlX21vZHVsZXMvdHJpbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94aHItbW9jay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94aHItbW9jay9saWIvTW9ja1JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMveGhyLW1vY2svbGliL01vY2tSZXNwb25zZS5qcyIsIm5vZGVfbW9kdWxlcy94aHItbW9jay9saWIvTW9ja1hNTEh0dHBSZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3hoci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzcmMvYWNjZXNzb3JzL3Byb3BlcnR5LW1hcHBpbmdzLmpzIiwic3JjL2FjdGlvbnMuanMiLCJzcmMvYWN0aW9ucy9kZWxldGUtdnJlLmpzIiwic3JjL2FjdGlvbnMvZmV0Y2gtYnVsa3VwbG9hZGVkLW1ldGFkYXRhLmpzIiwic3JjL2FjdGlvbnMvZmV0Y2gtbXktdnJlcy5qcyIsInNyYy9hY3Rpb25zL3ByZWRpY2F0ZS1vYmplY3QtbWFwcGluZ3MuanMiLCJzcmMvYWN0aW9ucy9wdWJsaXNoLW1hcHBpbmdzLmpzIiwic3JjL2FjdGlvbnMvc2VsZWN0LWNvbGxlY3Rpb24uanMiLCJzcmMvYWN0aW9ucy91cGxvYWQuanMiLCJzcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLWZvcm0vYWRkLXByb3BlcnR5LmpzIiwic3JjL2NvbXBvbmVudHMvY29sbGVjdGlvbi1mb3JtL2FkZC1yZWxhdGlvbi5qcyIsInNyYy9jb21wb25lbnRzL2NvbGxlY3Rpb24tZm9ybS9jb2xsZWN0aW9uLWZvcm0uanMiLCJzcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLWZvcm0vY29sdW1uLXNlbGVjdC5qcyIsInNyYy9jb21wb25lbnRzL2NvbGxlY3Rpb24tZm9ybS9uYW1lcy1mb3JtLmpzIiwic3JjL2NvbXBvbmVudHMvY29sbGVjdGlvbi1mb3JtL3Byb3BlcnR5LWZvcm0uanMiLCJzcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLWZvcm0vcmVsYXRpb24tZm9ybS5qcyIsInNyYy9jb21wb25lbnRzL2NvbGxlY3Rpb24tb3ZlcnZpZXcuanMiLCJzcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLXRhYmxlLmpzIiwic3JjL2NvbXBvbmVudHMvY29sbGVjdGlvbi10YWJzLmpzIiwic3JjL2NvbXBvbmVudHMvY29ubmVjdC1kYXRhLmpzIiwic3JjL2NvbXBvbmVudHMvY29ubmVjdC10by1hcmNoZXR5cGUuanMiLCJzcmMvY29tcG9uZW50cy9kYXRhc2V0LWNhcmRzLmpzIiwic3JjL2NvbXBvbmVudHMvZGF0YXNldC1zZXR0aW5ncy5qcyIsInNyYy9jb21wb25lbnRzL2RhdGFzZXRDYXJkLmpzeCIsInNyYy9jb21wb25lbnRzL2RlbGV0ZS12cmUtY29uZmlybWF0aW9uLWZvcm0uanMiLCJzcmMvY29tcG9uZW50cy9maWVsZHMvbW9kYWwuanMiLCJzcmMvY29tcG9uZW50cy9maWVsZHMvc2VsZWN0LWZpZWxkLmpzIiwic3JjL2NvbXBvbmVudHMvZmlyc3RVcGxvYWQuanMiLCJzcmMvY29tcG9uZW50cy9mb290ZXIuanMiLCJzcmMvY29tcG9uZW50cy9tZXNzYWdlLmpzIiwic3JjL2NvbXBvbmVudHMvcGFnZS5qc3giLCJzcmMvY29tcG9uZW50cy90YWJsZS9kYXRhLXJvdy5qcyIsInNyYy9jb21wb25lbnRzL3RhYmxlL2hlYWRlci1jZWxsLmpzIiwic3JjL2NvbXBvbmVudHMvdXBsb2FkLWJ1dHRvbi5qcyIsInNyYy9jb25uZWN0b3JzL2NvbGxlY3Rpb24tb3ZlcnZpZXcuanMiLCJzcmMvY29ubmVjdG9ycy9jb25uZWN0LWRhdGEuanMiLCJzcmMvY29ubmVjdG9ycy9jb25uZWN0LXRvLWFyY2hldHlwZS5qcyIsInNyYy9jb25uZWN0b3JzL2RhdGFzZXQtc2V0dGluZ3MuanMiLCJzcmMvY29ubmVjdG9ycy9wYWdlLWNvbm5lY3Rvci5qcyIsInNyYy9jb25uZWN0b3JzL3RyYW5zZm9ybWVycy90YWJsZS5qcyIsInNyYy9jb25uZWN0b3JzL3RyYW5zZm9ybWVycy90YWJzLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3JlZHVjZXJzL2FjdGl2ZS1jb2xsZWN0aW9uLmpzIiwic3JjL3JlZHVjZXJzL2FyY2hldHlwZS5qcyIsInNyYy9yZWR1Y2Vycy9jdXN0b20tcHJvcGVydGllcy5qcyIsInNyYy9yZWR1Y2Vycy9kYXRhc2V0LXNldHRpbmdzLmpzIiwic3JjL3JlZHVjZXJzL2RhdGFzZXRzLmpzIiwic3JjL3JlZHVjZXJzL2ltcG9ydC1kYXRhLmpzIiwic3JjL3JlZHVjZXJzL2luZGV4LmpzIiwic3JjL3JlZHVjZXJzL21hcHBpbmdzLmpzIiwic3JjL3JlZHVjZXJzL21lc3NhZ2VzLmpzIiwic3JjL3JlZHVjZXJzL3ByZWRpY2F0ZS1vYmplY3QtbWFwcGluZ3MuanMiLCJzcmMvcmVkdWNlcnMvcHJldmlldy1ybWwuanMiLCJzcmMvcmVkdWNlcnMvdXNlcmRhdGEuanMiLCJzcmMvcm91dGVyLmpzIiwic3JjL3NlcnZlcm1vY2tzLmpzIiwic3JjL3N0b3JlLmpzIiwic3JjL3Rva2VuLmpzIiwic3JjL3V0aWwvY2FtZWwybGFiZWwuanMiLCJzcmMvdXRpbC9jbG9uZS1kZWVwLmpzIiwic3JjL3V0aWwvY29sb3ItY29kZXMuanMiLCJzcmMvdXRpbC9nZW5lcmF0ZS1ybWwtbWFwcGluZy5qcyIsInNyYy91dGlsL3B1Ymxpc2gtc3RhdGUuanMiLCJzcmMvdXRpbC9zZXQtaW4uanMiLCJzcmMvdXRpbC91bmlxLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEdBQWhCLElBQXVCLEdBQXZCO0FBQ0EsUUFBTyxJQUFQO0FBQ0EsQ0FIRDs7QUFLQTtBQUNBLElBQU0sU0FBUyxTQUFULE1BQVMsQ0FBQyxJQUFELEVBQU8sS0FBUCxFQUFjLElBQWQ7QUFBQSxLQUFvQixLQUFwQix1RUFBNEIsSUFBNUI7QUFBQSxRQUNkLEtBQUssTUFBTCxHQUFjLENBQWQsR0FDQyxPQUFPLElBQVAsRUFBYSxLQUFiLEVBQW9CLElBQXBCLEVBQTBCLFFBQVEsTUFBTSxLQUFLLEtBQUwsRUFBTixDQUFSLEdBQThCLEtBQUssS0FBSyxLQUFMLEVBQUwsQ0FBeEQsQ0FERCxHQUVDLFVBQVUsSUFBVixFQUFnQixLQUFoQixFQUF1QixLQUFLLENBQUwsQ0FBdkIsRUFBZ0MsS0FBaEMsQ0FIYTtBQUFBLENBQWY7O0FBS0EsSUFBTSxRQUFRLFNBQVIsS0FBUSxDQUFDLElBQUQsRUFBTyxLQUFQLEVBQWMsSUFBZDtBQUFBLFFBQ2IsT0FBTyx5QkFBTSxJQUFOLENBQVAsRUFBb0IsS0FBcEIsRUFBMkIseUJBQU0sSUFBTixDQUEzQixDQURhO0FBQUEsQ0FBZDs7a0JBR2UsSzs7Ozs7Ozs7QUNuQmYsSUFBTSxPQUFPLFNBQVAsSUFBTyxDQUFDLEtBQUQsRUFBUSxHQUFSO0FBQUEsU0FBZ0IsTUFBTSxPQUFOLENBQWMsR0FBZCxJQUFxQixDQUFyQixHQUF5QixNQUFNLE1BQU4sQ0FBYSxHQUFiLENBQXpCLEdBQTZDLEtBQTdEO0FBQUEsQ0FBYjs7UUFFUyxJLEdBQUEsSSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNiBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpKTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuIiwidmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7fTtcbn1cbiIsIi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnB1c2guXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBQVVNIID0gJ1BVU0gnO1xuXG5leHBvcnRzLlBVU0ggPSBQVVNIO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgYSBjYWxsIHRvIGhpc3RvcnkucmVwbGFjZS5cbiAqL1xudmFyIFJFUExBQ0UgPSAnUkVQTEFDRSc7XG5cbmV4cG9ydHMuUkVQTEFDRSA9IFJFUExBQ0U7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBzb21lIG90aGVyIGFjdGlvbiBzdWNoXG4gKiBhcyB1c2luZyBhIGJyb3dzZXIncyBiYWNrL2ZvcndhcmQgYnV0dG9ucyBhbmQvb3IgbWFudWFsbHkgbWFuaXB1bGF0aW5nXG4gKiB0aGUgVVJMIGluIGEgYnJvd3NlcidzIGxvY2F0aW9uIGJhci4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd0V2ZW50SGFuZGxlcnMvb25wb3BzdGF0ZVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBQT1AgPSAnUE9QJztcblxuZXhwb3J0cy5QT1AgPSBQT1A7XG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIFBVU0g6IFBVU0gsXG4gIFJFUExBQ0U6IFJFUExBQ0UsXG4gIFBPUDogUE9QXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuXG5mdW5jdGlvbiBsb29wQXN5bmModHVybnMsIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBjdXJyZW50VHVybiA9IDAsXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcbiAgdmFyIHN5bmMgPSBmYWxzZSxcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcbiAgICAgIGRvbmVBcmdzID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaXNEb25lID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIGRvbmVBcmdzID0gW10uY29uY2F0KF9zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYXNOZXh0ID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jID0gdHJ1ZTtcblxuICAgIHdoaWxlICghaXNEb25lICYmIGN1cnJlbnRUdXJuIDwgdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgd29yay5jYWxsKHRoaXMsIGN1cnJlbnRUdXJuKyssIG5leHQsIGRvbmUpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcblxuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIGxvb3AgZmluaXNoZWQgc3luY2hyb25vdXNseS5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGRvbmVBcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufSIsIi8qZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc2F2ZVN0YXRlID0gc2F2ZVN0YXRlO1xuZXhwb3J0cy5yZWFkU3RhdGUgPSByZWFkU3RhdGU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBLZXlQcmVmaXggPSAnQEBIaXN0b3J5Lyc7XG52YXIgUXVvdGFFeGNlZWRlZEVycm9ycyA9IFsnUXVvdGFFeGNlZWRlZEVycm9yJywgJ1FVT1RBX0VYQ0VFREVEX0VSUiddO1xuXG52YXIgU2VjdXJpdHlFcnJvciA9ICdTZWN1cml0eUVycm9yJztcblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICByZXR1cm4gS2V5UHJlZml4ICsga2V5O1xufVxuXG5mdW5jdGlvbiBzYXZlU3RhdGUoa2V5LCBzdGF0ZSkge1xuICB0cnkge1xuICAgIGlmIChzdGF0ZSA9PSBudWxsKSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShjcmVhdGVLZXkoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGNyZWF0ZUtleShrZXkpLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gU2VjdXJpdHlFcnJvcikge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgZHVlIHRvIHNlY3VyaXR5IHNldHRpbmdzJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoUXVvdGFFeGNlZWRlZEVycm9ycy5pbmRleE9mKGVycm9yLm5hbWUpID49IDAgJiYgd2luZG93LnNlc3Npb25TdG9yYWdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gU2FmYXJpIFwicHJpdmF0ZSBtb2RlXCIgdGhyb3dzIFF1b3RhRXhjZWVkZWRFcnJvci5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiBTYWZhcmkgcHJpdmF0ZSBtb2RlJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gIHZhciBqc29uID0gdW5kZWZpbmVkO1xuICB0cnkge1xuICAgIGpzb24gPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShjcmVhdGVLZXkoa2V5KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byByZWFkIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoanNvbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWdub3JlIGludmFsaWQgSlNPTi5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMuZ2V0SGFzaFBhdGggPSBnZXRIYXNoUGF0aDtcbmV4cG9ydHMucmVwbGFjZUhhc2hQYXRoID0gcmVwbGFjZUhhc2hQYXRoO1xuZXhwb3J0cy5nZXRXaW5kb3dQYXRoID0gZ2V0V2luZG93UGF0aDtcbmV4cG9ydHMuZ28gPSBnbztcbmV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IGdldFVzZXJDb25maXJtYXRpb247XG5leHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeTtcbmV4cG9ydHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaDtcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIGlmIChub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVsxXSB8fCAnJztcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArICcjJyArIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dQYXRoKCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xufVxuXG5mdW5jdGlvbiBnbyhuKSB7XG4gIGlmIChuKSB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWNrdC9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHJldHVybiB1YS5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuZXhwb3J0cy5jYW5Vc2VET00gPSBjYW5Vc2VET007IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5leHRyYWN0UGF0aCA9IGV4dHJhY3RQYXRoO1xuZXhwb3J0cy5wYXJzZVBhdGggPSBwYXJzZVBhdGg7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RQYXRoKHN0cmluZykge1xuICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL15odHRwcz86XFwvXFwvW15cXC9dKi8pO1xuXG4gIGlmIChtYXRjaCA9PSBudWxsKSByZXR1cm4gc3RyaW5nO1xuXG4gIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IGV4dHJhY3RQYXRoKHBhdGgpO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHBhdGggPT09IHBhdGhuYW1lLCAnQSBwYXRoIG11c3QgYmUgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoIG9ubHksIG5vdCBhIGZ1bGx5IHF1YWxpZmllZCBVUkwgbGlrZSBcIiVzXCInLCBwYXRoKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICBpZiAocGF0aG5hbWUgPT09ICcnKSBwYXRobmFtZSA9ICcvJztcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoXG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVET01IaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVET01IaXN0b3J5KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIEhUTUw1J3MgaGlzdG9yeSBBUElcbiAqIChwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudCkgdG8gbWFuYWdlIGhpc3RvcnkuXG4gKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2Qgb2YgbWFuYWdpbmcgaGlzdG9yeSBpbiBicm93c2VycyBiZWNhdXNlXG4gKiBpdCBwcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqXG4gKiBOb3RlOiBJbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBmdWxsXG4gKiBwYWdlIHJlbG9hZHMgd2lsbCBiZSB1c2VkIHRvIHByZXNlcnZlIFVSTHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBmb3JjZVJlZnJlc2ggPSBvcHRpb25zLmZvcmNlUmVmcmVzaDtcblxuICB2YXIgaXNTdXBwb3J0ZWQgPSBfRE9NVXRpbHMuc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciB1c2VSZWZyZXNoID0gIWlzU3VwcG9ydGVkIHx8IGZvcmNlUmVmcmVzaDtcblxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGhpc3RvcnlTdGF0ZSA9IGhpc3RvcnlTdGF0ZSB8fCB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoaXN0b3J5U3RhdGUgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRXaW5kb3dQYXRoKCk7XG4gICAgdmFyIF9oaXN0b3J5U3RhdGUgPSBoaXN0b3J5U3RhdGU7XG4gICAgdmFyIGtleSA9IF9oaXN0b3J5U3RhdGUua2V5O1xuXG4gICAgdmFyIHN0YXRlID0gdW5kZWZpbmVkO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHN0YXRlID0gX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcblxuICAgICAgaWYgKGlzU3VwcG9ydGVkKSB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGhpc3RvcnlTdGF0ZSwgeyBrZXk6IGtleSB9KSwgbnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFBvcFN0YXRlTGlzdGVuZXIoX3JlZikge1xuICAgIHZhciB0cmFuc2l0aW9uVG8gPSBfcmVmLnRyYW5zaXRpb25UbztcblxuICAgIGZ1bmN0aW9uIHBvcFN0YXRlTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG5cbiAgICAgIHRyYW5zaXRpb25UbyhnZXRDdXJyZW50TG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgICB9XG5cbiAgICBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdwb3BzdGF0ZScsIHBvcFN0YXRlTGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3BvcHN0YXRlJywgcG9wU3RhdGVMaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICB2YXIgYmFzZW5hbWUgPSBsb2NhdGlvbi5iYXNlbmFtZTtcbiAgICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgICB2YXIgYWN0aW9uID0gbG9jYXRpb24uYWN0aW9uO1xuICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKGtleSwgc3RhdGUpO1xuXG4gICAgdmFyIHBhdGggPSAoYmFzZW5hbWUgfHwgJycpICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuICAgIHZhciBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICBrZXk6IGtleVxuICAgIH07XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBpZiAodXNlUmVmcmVzaCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHBhdGg7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gUHJldmVudCBsb2NhdGlvbiB1cGRhdGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIG51bGwsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJFUExBQ0VcbiAgICAgIGlmICh1c2VSZWZyZXNoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHBhdGgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFByZXZlbnQgbG9jYXRpb24gdXBkYXRlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBudWxsLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZURPTUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGVcbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICBoaXN0b3J5LnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaGlzdG9yeS51bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG5cbiAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayxcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9va1xuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NSGlzdG9yeShvcHRpb25zKSB7XG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe1xuICAgIGdldFVzZXJDb25maXJtYXRpb246IF9ET01VdGlscy5nZXRVc2VyQ29uZmlybWF0aW9uXG4gIH0sIG9wdGlvbnMsIHtcbiAgICBnbzogX0RPTVV0aWxzLmdvXG4gIH0pKTtcblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnRE9NIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbjogbGlzdGVuXG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVET01IaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlRE9NSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlRE9NSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGlzQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCgpIHtcbiAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICBpZiAoaXNBYnNvbHV0ZVBhdGgocGF0aCkpIHJldHVybiB0cnVlO1xuXG4gIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgoJy8nICsgcGF0aCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHBhdGggKyAocGF0aC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIChrZXkgKyAnPScgKyB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1s/Jl0/JyArIGtleSArICc9W2EtekEtWjAtOV0rJyksICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoJ1xcXFw/Lio/XFxcXGInICsga2V5ICsgJz0oLis/KVxcXFxiJykpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5cbnZhciBEZWZhdWx0UXVlcnlLZXkgPSAnX2snO1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgcXVlcnlLZXkgPSBvcHRpb25zLnF1ZXJ5S2V5O1xuXG4gIGlmIChxdWVyeUtleSA9PT0gdW5kZWZpbmVkIHx8ICEhcXVlcnlLZXkpIHF1ZXJ5S2V5ID0gdHlwZW9mIHF1ZXJ5S2V5ID09PSAnc3RyaW5nJyA/IHF1ZXJ5S2V5IDogRGVmYXVsdFF1ZXJ5S2V5O1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gICAgdmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBrZXkgPSBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwgcXVlcnlLZXkpO1xuICAgICAgcGF0aCA9IHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIHF1ZXJ5S2V5KTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBzdGF0ZSA9IF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG4gICAgICAgIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgoYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBxdWVyeUtleSwga2V5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKF9yZWYpIHtcbiAgICB2YXIgdHJhbnNpdGlvblRvID0gX3JlZi50cmFuc2l0aW9uVG87XG5cbiAgICBmdW5jdGlvbiBoYXNoQ2hhbmdlTGlzdGVuZXIoKSB7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHJldHVybjsgLy8gQWx3YXlzIG1ha2Ugc3VyZSBoYXNoZXMgYXJlIHByZWNlZWRlZCB3aXRoIGEgLy5cblxuICAgICAgdHJhbnNpdGlvblRvKGdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9XG5cbiAgICBlbnN1cmVTbGFzaCgpO1xuICAgIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlTGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VuYW1lID0gbG9jYXRpb24uYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgICB2YXIgYWN0aW9uID0gbG9jYXRpb24uYWN0aW9uO1xuICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgc2VhcmNoO1xuXG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBwYXRoID0gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBxdWVyeUtleSwga2V5KTtcbiAgICAgIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKGtleSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEcm9wIGtleSBhbmQgc3RhdGUuXG4gICAgICBsb2NhdGlvbi5rZXkgPSBsb2NhdGlvbi5zdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRIYXNoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBpZiAoY3VycmVudEhhc2ggIT09IHBhdGgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnWW91IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGggdXNpbmcgaGFzaCBoaXN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50SGFzaCAhPT0gcGF0aCkge1xuICAgICAgLy8gUkVQTEFDRVxuICAgICAgX0RPTVV0aWxzLnJlcGxhY2VIYXNoUGF0aChwYXRoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVET01IaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgZmluaXNoVHJhbnNpdGlvbjogZmluaXNoVHJhbnNpdGlvbixcbiAgICBzYXZlU3RhdGU6IF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgbG9jYXRpb24uc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucHVzaChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IGxvY2F0aW9uLnN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnJlcGxhY2UobG9jYXRpb24pO1xuICB9XG5cbiAgdmFyIGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkID0gX0RPTVV0aWxzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5nbyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xuICAgIHJldHVybiAnIycgKyBoaXN0b3J5LmNyZWF0ZUhyZWYocGF0aCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIGhpc3RvcnkucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBoaXN0b3J5LnVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcblxuICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIoKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IHN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgcGF0aCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBzdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogcmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgcHVzaFN0YXRlOiBwdXNoU3RhdGUsIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICByZXBsYWNlU3RhdGU6IHJlcGxhY2VTdGF0ZSAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIYXNoSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9kZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX2NyZWF0ZUxvY2F0aW9uMiA9IHJlcXVpcmUoJy4vY3JlYXRlTG9jYXRpb24nKTtcblxudmFyIF9jcmVhdGVMb2NhdGlvbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVMb2NhdGlvbjIpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9kZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZScpO1xuXG52YXIgX2RlcHJlY2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVSYW5kb21LZXkobGVuZ3RoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgbGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiZcbiAgLy9hLmFjdGlvbiA9PT0gYi5hY3Rpb24gJiYgLy8gRGlmZmVyZW50IGFjdGlvbiAhPT0gbG9jYXRpb24gY2hhbmdlLlxuICBhLmtleSA9PT0gYi5rZXkgJiYgX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShhLnN0YXRlLCBiLnN0YXRlKTtcbn1cblxudmFyIERlZmF1bHRLZXlMZW5ndGggPSA2O1xuXG5mdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gb3B0aW9ucy5nZXRDdXJyZW50TG9jYXRpb247XG4gIHZhciBmaW5pc2hUcmFuc2l0aW9uID0gb3B0aW9ucy5maW5pc2hUcmFuc2l0aW9uO1xuICB2YXIgc2F2ZVN0YXRlID0gb3B0aW9ucy5zYXZlU3RhdGU7XG4gIHZhciBnbyA9IG9wdGlvbnMuZ287XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gb3B0aW9ucy5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB2YXIga2V5TGVuZ3RoID0gb3B0aW9ucy5rZXlMZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiBrZXlMZW5ndGggIT09ICdudW1iZXInKSBrZXlMZW5ndGggPSBEZWZhdWx0S2V5TGVuZ3RoO1xuXG4gIHZhciB0cmFuc2l0aW9uSG9va3MgPSBbXTtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgIHRyYW5zaXRpb25Ib29rcy5wdXNoKGhvb2spO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYW5zaXRpb25Ib29rcyA9IHRyYW5zaXRpb25Ib29rcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFsbEtleXMgPSBbXTtcbiAgdmFyIGNoYW5nZUxpc3RlbmVycyA9IFtdO1xuICB2YXIgbG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudCgpIHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uICYmIHBlbmRpbmdMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihwZW5kaW5nTG9jYXRpb24ua2V5KTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gYWxsS2V5cy5pbmRleE9mKGxvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihuZXdMb2NhdGlvbikge1xuICAgIHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudCgpO1xuXG4gICAgbG9jYXRpb24gPSBuZXdMb2NhdGlvbjtcblxuICAgIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGFsbEtleXMgPSBbXS5jb25jYXQoYWxsS2V5cy5zbGljZSgwLCBjdXJyZW50ICsgMSksIFtsb2NhdGlvbi5rZXldKTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUkVQTEFDRSkge1xuICAgICAgYWxsS2V5c1tjdXJyZW50XSA9IGxvY2F0aW9uLmtleTtcbiAgICB9XG5cbiAgICBjaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGNoYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgbGlzdGVuZXIobG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2xvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgICBhbGxLZXlzID0gW19sb2NhdGlvbi5rZXldO1xuICAgICAgdXBkYXRlTG9jYXRpb24oX2xvY2F0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hhbmdlTGlzdGVuZXJzID0gY2hhbmdlTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBfQXN5bmNVdGlscy5sb29wQXN5bmModHJhbnNpdGlvbkhvb2tzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10odHJhbnNpdGlvbkhvb2tzW2luZGV4XSwgbG9jYXRpb24sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgZG9uZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmIChnZXRVc2VyQ29uZmlybWF0aW9uICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGZ1bmN0aW9uIChvaykge1xuICAgICAgICAgIGNhbGxiYWNrKG9rICE9PSBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobWVzc2FnZSAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHBlbmRpbmdMb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uVG8obmV4dExvY2F0aW9uKSB7XG4gICAgaWYgKGxvY2F0aW9uICYmIGxvY2F0aW9uc0FyZUVxdWFsKGxvY2F0aW9uLCBuZXh0TG9jYXRpb24pKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICBwZW5kaW5nTG9jYXRpb24gPSBuZXh0TG9jYXRpb247XG5cbiAgICBjb25maXJtVHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAocGVuZGluZ0xvY2F0aW9uICE9PSBuZXh0TG9jYXRpb24pIHJldHVybjsgLy8gVHJhbnNpdGlvbiB3YXMgaW50ZXJydXB0ZWQuXG5cbiAgICAgIGlmIChvaykge1xuICAgICAgICAvLyB0cmVhdCBQVVNIIHRvIGN1cnJlbnQgcGF0aCBsaWtlIFJFUExBQ0UgdG8gYmUgY29uc2lzdGVudCB3aXRoIGJyb3dzZXJzXG4gICAgICAgIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICAgICAgdmFyIG5leHRQYXRoID0gY3JlYXRlUGF0aChuZXh0TG9jYXRpb24pO1xuXG4gICAgICAgICAgaWYgKG5leHRQYXRoID09PSBwcmV2UGF0aCAmJiBfZGVlcEVxdWFsMlsnZGVmYXVsdCddKGxvY2F0aW9uLnN0YXRlLCBuZXh0TG9jYXRpb24uc3RhdGUpKSBuZXh0TG9jYXRpb24uYWN0aW9uID0gX0FjdGlvbnMuUkVQTEFDRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaW5pc2hUcmFuc2l0aW9uKG5leHRMb2NhdGlvbikgIT09IGZhbHNlKSB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChsb2NhdGlvbiAmJiBuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gYWxsS2V5cy5pbmRleE9mKG5leHRMb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xICYmIG5leHRJbmRleCAhPT0gLTEpIGdvKHByZXZJbmRleCAtIG5leHRJbmRleCk7IC8vIFJlc3RvcmUgdGhlIFVSTC5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIF9BY3Rpb25zLlBVU0gsIGNyZWF0ZUtleSgpKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5SRVBMQUNFLCBjcmVhdGVLZXkoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gY3JlYXRlUmFuZG9tS2V5KGtleUxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cbiAgICB2YXIgcmVzdWx0ID0gcGF0aG5hbWU7XG5cbiAgICBpZiAoc2VhcmNoKSByZXN1bHQgKz0gc2VhcmNoO1xuXG4gICAgaWYgKGhhc2gpIHJlc3VsdCArPSBoYXNoO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGNyZWF0ZUtleSgpIDogYXJndW1lbnRzWzJdO1xuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdUaGUgc3RhdGUgKDJuZCkgYXJndW1lbnQgdG8gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgYSAnICsgJ2xvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBhY3Rpb24gfSk7XG5cbiAgICAgIGFjdGlvbiA9IGtleTtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1szXSB8fCBjcmVhdGVLZXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NyZWF0ZUxvY2F0aW9uM1snZGVmYXVsdCddKGxvY2F0aW9uLCBhY3Rpb24sIGtleSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICB1cGRhdGVMb2NhdGlvblN0YXRlKGxvY2F0aW9uLCBzdGF0ZSk7XG4gICAgICB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uU3RhdGUoZ2V0Q3VycmVudExvY2F0aW9uKCksIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvblN0YXRlKGxvY2F0aW9uLCBzdGF0ZSkge1xuICAgIGxvY2F0aW9uLnN0YXRlID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLnN0YXRlLCBzdGF0ZSk7XG4gICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAodHJhbnNpdGlvbkhvb2tzLmluZGV4T2YoaG9vaykgPT09IC0xKSB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSAhPT0gaG9vaztcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICB0cmFuc2l0aW9uVG86IHRyYW5zaXRpb25UbyxcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNyZWF0ZUtleTogY3JlYXRlS2V5LFxuICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICBzZXRTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShzZXRTdGF0ZSwgJ3NldFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBsb2NhdGlvbi5rZXkgdG8gc2F2ZSBzdGF0ZSBpbnN0ZWFkJyksXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZWdpc3RlclRyYW5zaXRpb25Ib29rLCAncmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10odW5yZWdpc3RlclRyYW5zaXRpb25Ib29rLCAndW5yZWdpc3RlclRyYW5zaXRpb25Ib29rIGlzIGRlcHJlY2F0ZWQ7IHVzZSB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgZnJvbSBsaXN0ZW5CZWZvcmUgaW5zdGVhZCcpLFxuICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKCkge1xuICB2YXIgbG9jYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnLycgOiBhcmd1bWVudHNbMF07XG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfQWN0aW9ucy5QT1AgOiBhcmd1bWVudHNbMV07XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBfZm91cnRoQXJnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1szXTtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGNyZWF0ZUxvY2F0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhICcgKyAnbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgYWN0aW9uID0ga2V5IHx8IF9BY3Rpb25zLlBPUDtcbiAgICBrZXkgPSBfZm91cnRoQXJnO1xuICB9XG5cbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoIHx8ICcnO1xuICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2ggfHwgJyc7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlIHx8IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAga2V5OiBrZXlcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlTG9jYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKSB7XG4gIHJldHVybiBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3RhdGU7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZW50cnkpIHtcbiAgICBtZW1vW2VudHJ5LmtleV0gPSBlbnRyeS5zdGF0ZTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogb3B0aW9ucyB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IFtvcHRpb25zXSB9O1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBzYXZlU3RhdGUsXG4gICAgZ286IGdvXG4gIH0pKTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zO1xuICB2YXIgZW50cmllcyA9IF9vcHRpb25zLmVudHJpZXM7XG4gIHZhciBjdXJyZW50ID0gX29wdGlvbnMuY3VycmVudDtcblxuICBpZiAodHlwZW9mIGVudHJpZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZW50cmllcyA9IFtlbnRyaWVzXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgIGVudHJpZXMgPSBbJy8nXTtcbiAgfVxuXG4gIGVudHJpZXMgPSBlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2YXIga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcblxuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSByZXR1cm4geyBwYXRobmFtZTogZW50cnksIGtleToga2V5IH07XG5cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnb2JqZWN0JyAmJiBlbnRyeSkgcmV0dXJuIF9leHRlbmRzKHt9LCBlbnRyeSwgeyBrZXk6IGtleSB9KTtcblxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnVW5hYmxlIHRvIGNyZWF0ZSBoaXN0b3J5IGVudHJ5IGZyb20gJXMnLCBlbnRyeSkgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSk7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGN1cnJlbnQgPSBlbnRyaWVzLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSB7XG4gICAgIShjdXJyZW50ID49IDAgJiYgY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnQ3VycmVudCBpbmRleCBtdXN0IGJlID49IDAgYW5kIDwgJXMsIHdhcyAlcycsIGVudHJpZXMubGVuZ3RoLCBjdXJyZW50KSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHN0b3JhZ2UgPSBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcyk7XG5cbiAgZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgICBzdG9yYWdlW2tleV0gPSBzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbY3VycmVudF07XG4gICAgdmFyIGJhc2VuYW1lID0gZW50cnkuYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gZW50cnkucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGVudHJ5LnNlYXJjaDtcblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgKHNlYXJjaCB8fCAnJyk7XG5cbiAgICB2YXIga2V5ID0gdW5kZWZpbmVkLFxuICAgICAgICBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZW50cnkua2V5KSB7XG4gICAgICBrZXkgPSBlbnRyeS5rZXk7XG4gICAgICBzdGF0ZSA9IHJlYWRTdGF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBpbmRleCA9IGN1cnJlbnQgKyBuO1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgZW50cmllcy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgaWYgKG4pIHtcbiAgICAgIGlmICghY2FuR28obikpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnQ2Fubm90IGdvKCVzKSB0aGVyZSBpcyBub3QgZW5vdWdoIGhpc3RvcnknLCBuKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ICs9IG47XG5cbiAgICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24oKTtcblxuICAgICAgLy8gY2hhbmdlIGFjdGlvbiB0byBQT1BcbiAgICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKF9leHRlbmRzKHt9LCBjdXJyZW50TG9jYXRpb24sIHsgYWN0aW9uOiBfQWN0aW9ucy5QT1AgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICBzd2l0Y2ggKGxvY2F0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBfQWN0aW9ucy5QVVNIOlxuICAgICAgICBjdXJyZW50ICs9IDE7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBvbiB0aGUgdG9wIG9mIHN0YWNrXG4gICAgICAgIC8vIHJlbW92ZSByZXN0IGFuZCBwdXNoIG5ld1xuICAgICAgICBpZiAoY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSBlbnRyaWVzLnNwbGljZShjdXJyZW50KTtcblxuICAgICAgICBlbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfQWN0aW9ucy5SRVBMQUNFOlxuICAgICAgICBlbnRyaWVzW2N1cnJlbnRdID0gbG9jYXRpb247XG4gICAgICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbWVzc2FnZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSAnICsgbWVzc2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlcHJlY2F0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2soaG9vaywgbG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gIHZhciByZXN1bHQgPSBob29rKGxvY2F0aW9uLCBjYWxsYmFjayk7XG5cbiAgaWYgKGhvb2subGVuZ3RoIDwgMikge1xuICAgIC8vIEFzc3VtZSB0aGUgaG9vayBydW5zIHN5bmNocm9ub3VzbHkgYW5kIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSByZXR1cm4gdmFsdWUuXG4gICAgY2FsbGJhY2socmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocmVzdWx0ID09PSB1bmRlZmluZWQsICdZb3Ugc2hvdWxkIG5vdCBcInJldHVyblwiIGluIGEgdHJhbnNpdGlvbiBob29rIHdpdGggYSBjYWxsYmFjayBhcmd1bWVudDsgY2FsbCB0aGUgY2FsbGJhY2sgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJ1blRyYW5zaXRpb25Ib29rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX2RlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlJyk7XG5cbnZhciBfZGVwcmVjYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZSk7XG5cbmZ1bmN0aW9uIHVzZUJhc2VuYW1lKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuXG4gICAgdmFyIGJhc2VuYW1lID0gb3B0aW9ucy5iYXNlbmFtZTtcblxuICAgIHZhciBjaGVja2VkQmFzZUhyZWYgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrQmFzZUhyZWYoKSB7XG4gICAgICBpZiAoY2hlY2tlZEJhc2VIcmVmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXV0b21hdGljYWxseSB1c2UgdGhlIHZhbHVlIG9mIDxiYXNlIGhyZWY+IGluIEhUTUxcbiAgICAgIC8vIGRvY3VtZW50cyBhcyBiYXNlbmFtZSBpZiBpdCdzIG5vdCBleHBsaWNpdGx5IGdpdmVuLlxuICAgICAgaWYgKGJhc2VuYW1lID09IG51bGwgJiYgX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgICAgICB2YXIgYmFzZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdiYXNlJylbMF07XG4gICAgICAgIHZhciBiYXNlSHJlZiA9IGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgICAgICBpZiAoYmFzZUhyZWYgIT0gbnVsbCkge1xuICAgICAgICAgIGJhc2VuYW1lID0gYmFzZUhyZWY7XG5cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdBdXRvbWF0aWNhbGx5IHNldHRpbmcgYmFzZW5hbWUgdXNpbmcgPGJhc2UgaHJlZj4gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCAnICsgJ2JlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVGhlIHNlbWFudGljcyBvZiA8YmFzZSBocmVmPiBhcmUgJyArICdzdWJ0bHkgZGlmZmVyZW50IGZyb20gYmFzZW5hbWUuIFBsZWFzZSBwYXNzIHRoZSBiYXNlbmFtZSBleHBsaWNpdGx5IGluICcgKyAndGhlIG9wdGlvbnMgdG8gY3JlYXRlSGlzdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoZWNrZWRCYXNlSHJlZiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGNoZWNrQmFzZUhyZWYoKTtcblxuICAgICAgaWYgKGJhc2VuYW1lICYmIGxvY2F0aW9uLmJhc2VuYW1lID09IG51bGwpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZW5hbWUpID09PSAwKSB7XG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHJpbmcoYmFzZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9IGJhc2VuYW1lO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSAnJykgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYXRpb24uYmFzZW5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBjaGVja0Jhc2VIcmVmKCk7XG5cbiAgICAgIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICB2YXIgcG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgIHZhciBub3JtYWxpemVkQmFzZW5hbWUgPSBiYXNlbmFtZS5zbGljZSgtMSkgPT09ICcvJyA/IGJhc2VuYW1lIDogYmFzZW5hbWUgKyAnLyc7XG4gICAgICB2YXIgbm9ybWFsaXplZFBhdGhuYW1lID0gcG5hbWUuY2hhckF0KDApID09PSAnLycgPyBwbmFtZS5zbGljZSgxKSA6IHBuYW1lO1xuICAgICAgdmFyIHBhdGhuYW1lID0gbm9ybWFsaXplZEJhc2VuYW1lICsgbm9ybWFsaXplZFBhdGhuYW1lO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10oaG9vaywgYWRkQmFzZW5hbWUobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIoYWRkQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5wdXNoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZShwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZEJhc2VuYW1lKGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW3ByZXBlbmRCYXNlbmFtZShsb2NhdGlvbildLmNvbmNhdChhcmdzKSkpO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHVzZUJhc2VuYW1lO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX3F1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnktc3RyaW5nJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxudmFyIFNFQVJDSF9CQVNFX0tFWSA9ICckc2VhcmNoQmFzZSc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdHJpbmdpZnlRdWVyeShxdWVyeSkge1xuICByZXR1cm4gX3F1ZXJ5U3RyaW5nLnN0cmluZ2lmeShxdWVyeSkucmVwbGFjZSgvJTIwL2csICcrJyk7XG59XG5cbnZhciBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5wYXJzZTtcblxuZnVuY3Rpb24gaXNOZXN0ZWRPYmplY3Qob2JqZWN0KSB7XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHApICYmIHR5cGVvZiBvYmplY3RbcF0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iamVjdFtwXSkgJiYgb2JqZWN0W3BdICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgfXJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNyZWF0ZUhpc3RvcnkgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjcmVhdGVcbiAqIGhpc3Rvcnkgb2JqZWN0cyB0aGF0IGtub3cgaG93IHRvIGhhbmRsZSBVUkwgcXVlcmllcy5cbiAqL1xuZnVuY3Rpb24gdXNlUXVlcmllcyhjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcblxuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IG9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBvcHRpb25zLnBhcnNlUXVlcnlTdHJpbmc7XG5cbiAgICBpZiAodHlwZW9mIHN0cmluZ2lmeVF1ZXJ5ICE9PSAnZnVuY3Rpb24nKSBzdHJpbmdpZnlRdWVyeSA9IGRlZmF1bHRTdHJpbmdpZnlRdWVyeTtcblxuICAgIGlmICh0eXBlb2YgcGFyc2VRdWVyeVN0cmluZyAhPT0gJ2Z1bmN0aW9uJykgcGFyc2VRdWVyeVN0cmluZyA9IGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nO1xuXG4gICAgZnVuY3Rpb24gYWRkUXVlcnkobG9jYXRpb24pIHtcbiAgICAgIGlmIChsb2NhdGlvbi5xdWVyeSA9PSBudWxsKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG5cbiAgICAgICAgbG9jYXRpb24ucXVlcnkgPSBwYXJzZVF1ZXJ5U3RyaW5nKHNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICBsb2NhdGlvbltTRUFSQ0hfQkFTRV9LRVldID0geyBzZWFyY2g6IHNlYXJjaCwgc2VhcmNoQmFzZTogJycgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiBhbGwgdGhlIGJvb2sta2VlcGluZyBoZXJlLCB0aGlzIHNob3VsZCBqdXN0IHN0cmlwIHRoZVxuICAgICAgLy8gc3RyaW5naWZpZWQgcXVlcnkgZnJvbSB0aGUgc2VhcmNoLlxuXG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kUXVlcnkobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICB2YXIgc2VhcmNoQmFzZVNwZWMgPSBsb2NhdGlvbltTRUFSQ0hfQkFTRV9LRVldO1xuICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcXVlcnkgPyBzdHJpbmdpZnlRdWVyeShxdWVyeSkgOiAnJztcbiAgICAgIGlmICghc2VhcmNoQmFzZVNwZWMgJiYgIXF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHN0cmluZ2lmeVF1ZXJ5ICE9PSBkZWZhdWx0U3RyaW5naWZ5UXVlcnkgfHwgIWlzTmVzdGVkT2JqZWN0KHF1ZXJ5KSwgJ3VzZVF1ZXJpZXMgZG9lcyBub3Qgc3RyaW5naWZ5IG5lc3RlZCBxdWVyeSBvYmplY3RzIGJ5IGRlZmF1bHQ7ICcgKyAndXNlIGEgY3VzdG9tIHN0cmluZ2lmeVF1ZXJ5IGZ1bmN0aW9uJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKGxvY2F0aW9uKTtcblxuICAgICAgdmFyIHNlYXJjaEJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2VhcmNoQmFzZVNwZWMgJiYgbG9jYXRpb24uc2VhcmNoID09PSBzZWFyY2hCYXNlU3BlYy5zZWFyY2gpIHtcbiAgICAgICAgc2VhcmNoQmFzZSA9IHNlYXJjaEJhc2VTcGVjLnNlYXJjaEJhc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2hCYXNlID0gbG9jYXRpb24uc2VhcmNoIHx8ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VhcmNoID0gc2VhcmNoQmFzZTtcbiAgICAgIGlmIChxdWVyeVN0cmluZykge1xuICAgICAgICBzZWFyY2ggKz0gKHNlYXJjaCA/ICcmJyA6ICc/JykgKyBxdWVyeVN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgKF9leHRlbmRzMiA9IHtcbiAgICAgICAgc2VhcmNoOiBzZWFyY2hcbiAgICAgIH0sIF9leHRlbmRzMltTRUFSQ0hfQkFTRV9LRVldID0geyBzZWFyY2g6IHNlYXJjaCwgc2VhcmNoQmFzZTogc2VhcmNoQmFzZSB9LCBfZXh0ZW5kczIpKTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIF9ydW5UcmFuc2l0aW9uSG9vazJbJ2RlZmF1bHQnXShob29rLCBhZGRRdWVyeShsb2NhdGlvbiksIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICBsaXN0ZW5lcihhZGRRdWVyeShsb2NhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnB1c2goYXBwZW5kUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oIXF1ZXJ5LCAndGhlIHF1ZXJ5IGFyZ3VtZW50IHRvIGNyZWF0ZVBhdGggaXMgZGVwcmVjYXRlZDsgdXNlIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgoYXBwZW5kUXVlcnkobG9jYXRpb24sIHF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXSghcXVlcnksICd0aGUgcXVlcnkgYXJndW1lbnQgdG8gY3JlYXRlSHJlZiBpcyBkZXByZWNhdGVkOyB1c2UgYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihhcHBlbmRRdWVyeShsb2NhdGlvbiwgcXVlcnkgfHwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnVsbExvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbYXBwZW5kUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIGlmIChsb2NhdGlvbi5xdWVyeSkge1xuICAgICAgICBmdWxsTG9jYXRpb24ucXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZGRRdWVyeShmdWxsTG9jYXRpb24pO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgsIHF1ZXJ5KSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCwgeyBxdWVyeTogcXVlcnkgfSkpO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgsIHF1ZXJ5KSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCwgeyBxdWVyeTogcXVlcnkgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgICAgcmVwbGFjZVN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHJlcGxhY2VTdGF0ZSwgJ3JlcGxhY2VTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcmVwbGFjZSBpbnN0ZWFkJylcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gdXNlUXVlcmllcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgY3VzdG9tU3RhdGljcykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleXNbaV1dICYmICFLTk9XTl9TVEFUSUNTW2tleXNbaV1dICYmICghY3VzdG9tU3RhdGljcyB8fCAhY3VzdG9tU3RhdGljc1trZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21wb25lbnRba2V5c1tpXV0gPSBzb3VyY2VDb21wb25lbnRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHZhbHVlID0gT2JqZWN0KHZhbHVlKTtcbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiB2YWx1ZSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIHRyaW0gPSByZXF1aXJlKCd0cmltJylcbiAgLCBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKVxuICAsIGlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiB7fVxuXG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIGZvckVhY2goXG4gICAgICB0cmltKGhlYWRlcnMpLnNwbGl0KCdcXG4nKVxuICAgICwgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgaW5kZXggPSByb3cuaW5kZXhPZignOicpXG4gICAgICAgICAgLCBrZXkgPSB0cmltKHJvdy5zbGljZSgwLCBpbmRleCkpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAsIHZhbHVlID0gdHJpbShyb3cuc2xpY2UoaW5kZXggKyAxKSlcblxuICAgICAgICBpZiAodHlwZW9mKHJlc3VsdFtrZXldKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gWyByZXN1bHRba2V5XSwgdmFsdWUgXVxuICAgICAgICB9XG4gICAgICB9XG4gIClcblxuICByZXR1cm4gcmVzdWx0XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cmljdFVyaUVuY29kZSA9IHJlcXVpcmUoJ3N0cmljdC11cmktZW5jb2RlJyk7XG5cbmV4cG9ydHMuZXh0cmFjdCA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5zcGxpdCgnPycpWzFdIHx8ICcnO1xufTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cblx0c3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG5cdGlmICghc3RyKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cblx0cmV0dXJuIHN0ci5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbiAocmV0LCBwYXJhbSkge1xuXHRcdHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG5cdFx0Ly8gRmlyZWZveCAocHJlIDQwKSBkZWNvZGVzIGAlM0RgIHRvIGA9YFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nL3B1bGwvMzdcblx0XHR2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHR2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzLmpvaW4oJz0nKSA6IHVuZGVmaW5lZDtcblxuXHRcdGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xuXG5cdFx0Ly8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0dmFsID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG5cblx0XHRpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRyZXRba2V5XSA9IHZhbDtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0W2tleV0pKSB7XG5cdFx0XHRyZXRba2V5XS5wdXNoKHZhbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldFtrZXldID0gW3JldFtrZXldLCB2YWxdO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sIHt9KTtcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gb2JqID8gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdmFsID0gb2JqW2tleV07XG5cblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH1cblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdHJldHVybiB2YWwuc2xpY2UoKS5zb3J0KCkubWFwKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwyKTtcblx0XHRcdH0pLmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyaWN0VXJpRW5jb2RlKGtleSkgKyAnPScgKyBzdHJpY3RVcmlFbmNvZGUodmFsKTtcblx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHgubGVuZ3RoID4gMDtcblx0fSkuam9pbignJicpIDogJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB1bmRlZmluZWQ7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3N0b3JlU2hhcGUgPSByZXF1aXJlKCcuLi91dGlscy9zdG9yZVNoYXBlJyk7XG5cbnZhciBfc3RvcmVTaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdG9yZVNoYXBlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKSB7XG4gIGlmIChkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IHRydWU7XG5cbiAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKCc8UHJvdmlkZXI+IGRvZXMgbm90IHN1cHBvcnQgY2hhbmdpbmcgYHN0b3JlYCBvbiB0aGUgZmx5LiAnICsgJ0l0IGlzIG1vc3QgbGlrZWx5IHRoYXQgeW91IHNlZSB0aGlzIGVycm9yIGJlY2F1c2UgeW91IHVwZGF0ZWQgdG8gJyArICdSZWR1eCAyLnggYW5kIFJlYWN0IFJlZHV4IDIueCB3aGljaCBubyBsb25nZXIgaG90IHJlbG9hZCByZWR1Y2VycyAnICsgJ2F1dG9tYXRpY2FsbHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yZWR1eC9yZWxlYXNlcy8nICsgJ3RhZy92Mi4wLjAgZm9yIHRoZSBtaWdyYXRpb24gaW5zdHJ1Y3Rpb25zLicpO1xufVxuXG52YXIgUHJvdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gIFByb3ZpZGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHsgc3RvcmU6IHRoaXMuc3RvcmUgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBQcm92aWRlcihwcm9wcywgY29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm92aWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgIF90aGlzLnN0b3JlID0gcHJvcHMuc3RvcmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH07XG5cbiAgcmV0dXJuIFByb3ZpZGVyO1xufShfcmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQcm92aWRlcjtcblxuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICBQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgIHZhciBuZXh0U3RvcmUgPSBuZXh0UHJvcHMuc3RvcmU7XG5cblxuICAgIGlmIChzdG9yZSAhPT0gbmV4dFN0b3JlKSB7XG4gICAgICB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXS5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRcbn07XG5Qcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl0uaXNSZXF1aXJlZFxufTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29ubmVjdDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfc3RvcmVTaGFwZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0b3JlU2hhcGUnKTtcblxudmFyIF9zdG9yZVNoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0b3JlU2hhcGUpO1xuXG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJy4uL3V0aWxzL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgX3NoYWxsb3dFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFsbG93RXF1YWwpO1xuXG52YXIgX3dyYXBBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dyYXBBY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgX3dyYXBBY3Rpb25DcmVhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQWN0aW9uQ3JlYXRvcnMpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzID0gcmVxdWlyZSgnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnKTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob2lzdE5vblJlYWN0U3RhdGljcyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzID0gZnVuY3Rpb24gZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSkge1xuICByZXR1cm4ge307XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG52YXIgZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIHsgZGlzcGF0Y2g6IGRpc3BhdGNoIH07XG59O1xudmFyIGRlZmF1bHRNZXJnZVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBwYXJlbnRQcm9wcywgc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcyk7XG59O1xuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSB7XG4gIHJldHVybiBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxudmFyIGVycm9yT2JqZWN0ID0geyB2YWx1ZTogbnVsbCB9O1xuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIGN0eCkge1xuICB0cnkge1xuICAgIHJldHVybiBmbi5hcHBseShjdHgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JPYmplY3QudmFsdWUgPSBlO1xuICAgIHJldHVybiBlcnJvck9iamVjdDtcbiAgfVxufVxuXG4vLyBIZWxwcyB0cmFjayBob3QgcmVsb2FkaW5nLlxudmFyIG5leHRWZXJzaW9uID0gMDtcblxuZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgdmFyIHNob3VsZFN1YnNjcmliZSA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcbiAgdmFyIG1hcFN0YXRlID0gbWFwU3RhdGVUb1Byb3BzIHx8IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHM7XG5cbiAgdmFyIG1hcERpc3BhdGNoID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hcERpc3BhdGNoID0gbWFwRGlzcGF0Y2hUb1Byb3BzO1xuICB9IGVsc2UgaWYgKCFtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgICBtYXBEaXNwYXRjaCA9IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgbWFwRGlzcGF0Y2ggPSAoMCwgX3dyYXBBY3Rpb25DcmVhdG9yczJbXCJkZWZhdWx0XCJdKShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICB9XG5cbiAgdmFyIGZpbmFsTWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHMgfHwgZGVmYXVsdE1lcmdlUHJvcHM7XG4gIHZhciBfb3B0aW9ucyRwdXJlID0gb3B0aW9ucy5wdXJlLFxuICAgICAgcHVyZSA9IF9vcHRpb25zJHB1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfb3B0aW9ucyRwdXJlLFxuICAgICAgX29wdGlvbnMkd2l0aFJlZiA9IG9wdGlvbnMud2l0aFJlZixcbiAgICAgIHdpdGhSZWYgPSBfb3B0aW9ucyR3aXRoUmVmID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHdpdGhSZWY7XG5cbiAgdmFyIGNoZWNrTWVyZ2VkRXF1YWxzID0gcHVyZSAmJiBmaW5hbE1lcmdlUHJvcHMgIT09IGRlZmF1bHRNZXJnZVByb3BzO1xuXG4gIC8vIEhlbHBzIHRyYWNrIGhvdCByZWxvYWRpbmcuXG4gIHZhciB2ZXJzaW9uID0gbmV4dFZlcnNpb24rKztcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICB2YXIgY29ubmVjdERpc3BsYXlOYW1lID0gJ0Nvbm5lY3QoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tTdGF0ZVNoYXBlKHByb3BzLCBtZXRob2ROYW1lKSB7XG4gICAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShwcm9wcykpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKG1ldGhvZE5hbWUgKyAnKCkgaW4gJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICcgbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuICcgKyAoJ0luc3RlYWQgcmVjZWl2ZWQgJyArIHByb3BzICsgJy4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lcmdlZFByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIHBhcmVudFByb3BzKSB7XG4gICAgICB2YXIgbWVyZ2VkUHJvcHMgPSBmaW5hbE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpO1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1lcmdlZFByb3BzLCAnbWVyZ2VQcm9wcycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH1cblxuICAgIHZhciBDb25uZWN0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0cyhDb25uZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gIXB1cmUgfHwgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkIHx8IHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQ7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBDb25uZWN0KHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25uZWN0KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgICAgICBfdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBwcm9wcy5zdG9yZSB8fCBjb250ZXh0LnN0b3JlO1xuXG4gICAgICAgICgwLCBfaW52YXJpYW50MltcImRlZmF1bHRcIl0pKF90aGlzLnN0b3JlLCAnQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIGVpdGhlciB0aGUgY29udGV4dCBvciAnICsgKCdwcm9wcyBvZiBcIicgKyBjb25uZWN0RGlzcGxheU5hbWUgKyAnXCIuICcpICsgJ0VpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sICcgKyAoJ29yIGV4cGxpY2l0bHkgcGFzcyBcInN0b3JlXCIgYXMgYSBwcm9wIHRvIFwiJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICdcIi4nKSk7XG5cbiAgICAgICAgdmFyIHN0b3JlU3RhdGUgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgc3RvcmVTdGF0ZTogc3RvcmVTdGF0ZSB9O1xuICAgICAgICBfdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcHV0ZVN0YXRlUHJvcHMgPSBmdW5jdGlvbiBjb21wdXRlU3RhdGVQcm9wcyhzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlRmluYWxNYXBTdGF0ZShzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgdmFyIHN0YXRlUHJvcHMgPSB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMgPyB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBwcm9wcykgOiB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKHN0YXRlKTtcblxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShzdGF0ZVByb3BzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlUHJvcHM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb25maWd1cmVGaW5hbE1hcFN0YXRlID0gZnVuY3Rpb24gY29uZmlndXJlRmluYWxNYXBTdGF0ZShzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZFN0YXRlID0gbWFwU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSwgcHJvcHMpO1xuICAgICAgICB2YXIgaXNGYWN0b3J5ID0gdHlwZW9mIG1hcHBlZFN0YXRlID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMgPSBpc0ZhY3RvcnkgPyBtYXBwZWRTdGF0ZSA6IG1hcFN0YXRlO1xuICAgICAgICB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMgPSB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzLmxlbmd0aCAhPT0gMTtcblxuICAgICAgICBpZiAoaXNGYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVN0YXRlUHJvcHMoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1hcHBlZFN0YXRlLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlZFN0YXRlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcHV0ZURpc3BhdGNoUHJvcHMgPSBmdW5jdGlvbiBjb21wdXRlRGlzcGF0Y2hQcm9wcyhzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaChzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoUHJvcHMgPSB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHMgPyB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBwcm9wcykgOiB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKTtcblxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShkaXNwYXRjaFByb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoUHJvcHM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb25maWd1cmVGaW5hbE1hcERpc3BhdGNoID0gZnVuY3Rpb24gY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaChzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZERpc3BhdGNoID0gbWFwRGlzcGF0Y2goc3RvcmUuZGlzcGF0Y2gsIHByb3BzKTtcbiAgICAgICAgdmFyIGlzRmFjdG9yeSA9IHR5cGVvZiBtYXBwZWREaXNwYXRjaCA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgICB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzID0gaXNGYWN0b3J5ID8gbWFwcGVkRGlzcGF0Y2ggOiBtYXBEaXNwYXRjaDtcbiAgICAgICAgdGhpcy5kb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzID0gdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcy5sZW5ndGggIT09IDE7XG5cbiAgICAgICAgaWYgKGlzRmFjdG9yeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVEaXNwYXRjaFByb3BzKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShtYXBwZWREaXNwYXRjaCwgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWREaXNwYXRjaDtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHRTdGF0ZVByb3BzID0gdGhpcy5jb21wdXRlU3RhdGVQcm9wcyh0aGlzLnN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVQcm9wcyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0U3RhdGVQcm9wcywgdGhpcy5zdGF0ZVByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHREaXNwYXRjaFByb3BzID0gdGhpcy5jb21wdXRlRGlzcGF0Y2hQcm9wcyh0aGlzLnN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hQcm9wcyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0RGlzcGF0Y2hQcm9wcywgdGhpcy5kaXNwYXRjaFByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQcm9wcyA9IG5leHREaXNwYXRjaFByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQgPSBmdW5jdGlvbiB1cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dE1lcmdlZFByb3BzID0gY29tcHV0ZU1lcmdlZFByb3BzKHRoaXMuc3RhdGVQcm9wcywgdGhpcy5kaXNwYXRjaFByb3BzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMubWVyZ2VkUHJvcHMgJiYgY2hlY2tNZXJnZWRFcXVhbHMgJiYgKDAsIF9zaGFsbG93RXF1YWwyW1wiZGVmYXVsdFwiXSkobmV4dE1lcmdlZFByb3BzLCB0aGlzLm1lcmdlZFByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbic7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmIChzaG91bGRTdWJzY3JpYmUgJiYgIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICEoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0UHJvcHMsIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLm1lcmdlZFByb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdG9yZVN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgcHJldlN0b3JlU3RhdGUgPSB0aGlzLnN0YXRlLnN0b3JlU3RhdGU7XG4gICAgICAgIGlmIChwdXJlICYmIHByZXZTdG9yZVN0YXRlID09PSBzdG9yZVN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB1cmUgJiYgIXRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcykge1xuICAgICAgICAgIHZhciBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSB0cnlDYXRjaCh0aGlzLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFoYXZlU3RhdGVQcm9wc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBlcnJvck9iamVjdC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgc3RvcmVTdGF0ZTogc3RvcmVTdGF0ZSB9KTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldFdyYXBwZWRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgKDAsIF9pbnZhcmlhbnQyW1wiZGVmYXVsdFwiXSkod2l0aFJlZiwgJ1RvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSAnICsgJ3sgd2l0aFJlZjogdHJ1ZSB9IGFzIHRoZSBmb3VydGggYXJndW1lbnQgb2YgdGhlIGNvbm5lY3QoKSBjYWxsLicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgaGF2ZU93blByb3BzQ2hhbmdlZCA9IHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZCxcbiAgICAgICAgICAgIGhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCxcbiAgICAgICAgICAgIGhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQsXG4gICAgICAgICAgICBzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IsXG4gICAgICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLnJlbmRlcmVkRWxlbWVudDtcblxuXG4gICAgICAgIHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gbnVsbDtcblxuICAgICAgICBpZiAoc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVTdGF0ZVByb3BzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMgPSB0cnVlO1xuICAgICAgICBpZiAocHVyZSAmJiByZW5kZXJlZEVsZW1lbnQpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGVTdGF0ZVByb3BzID0gaGFzU3RvcmVTdGF0ZUNoYW5nZWQgfHwgaGF2ZU93blByb3BzQ2hhbmdlZCAmJiB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHM7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlRGlzcGF0Y2hQcm9wcyA9IGhhdmVPd25Qcm9wc0NoYW5nZWQgJiYgdGhpcy5kb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChoYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkKSB7XG4gICAgICAgICAgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG91bGRVcGRhdGVTdGF0ZVByb3BzKSB7XG4gICAgICAgICAgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gdGhpcy51cGRhdGVTdGF0ZVByb3BzSWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlRGlzcGF0Y2hQcm9wcykge1xuICAgICAgICAgIGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChoYXZlU3RhdGVQcm9wc0NoYW5nZWQgfHwgaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkIHx8IGhhdmVPd25Qcm9wc0NoYW5nZWQpIHtcbiAgICAgICAgICBoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkID0gdGhpcy51cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkICYmIHJlbmRlcmVkRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJlZEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2l0aFJlZikge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50ID0gKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShXcmFwcGVkQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgdGhpcy5tZXJnZWRQcm9wcywge1xuICAgICAgICAgICAgcmVmOiAnd3JhcHBlZEluc3RhbmNlJ1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9ICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoV3JhcHBlZENvbXBvbmVudCwgdGhpcy5tZXJnZWRQcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZEVsZW1lbnQ7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29ubmVjdDtcbiAgICB9KF9yZWFjdC5Db21wb25lbnQpO1xuXG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IGNvbm5lY3REaXNwbGF5TmFtZTtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0ge1xuICAgICAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl1cbiAgICB9O1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0ge1xuICAgICAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl1cbiAgICB9O1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID09PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgYXJlIGhvdCByZWxvYWRpbmchXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9ob2lzdE5vblJlYWN0U3RhdGljczJbXCJkZWZhdWx0XCJdKShDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbm5lY3QgPSBleHBvcnRzLlByb3ZpZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX1Byb3ZpZGVyID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1Byb3ZpZGVyJyk7XG5cbnZhciBfUHJvdmlkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHJvdmlkZXIpO1xuXG52YXIgX2Nvbm5lY3QgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvY29ubmVjdCcpO1xuXG52YXIgX2Nvbm5lY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29ubmVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5leHBvcnRzLlByb3ZpZGVyID0gX1Byb3ZpZGVyMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmNvbm5lY3QgPSBfY29ubmVjdDJbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBzaGFsbG93RXF1YWw7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgb2JqQVtrZXlzQVtpXV0gIT09IG9iakJba2V5c0FbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzcGF0Y2g6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBnZXRTdGF0ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd2FybmluZztcbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3cmFwQWN0aW9uQ3JlYXRvcnM7XG5cbnZhciBfcmVkdXggPSByZXF1aXJlKCdyZWR1eCcpO1xuXG5mdW5jdGlvbiB3cmFwQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgIHJldHVybiAoMCwgX3JlZHV4LmJpbmRBY3Rpb25DcmVhdG9ycykoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuZXhwb3J0cy5tYXBBc3luYyA9IG1hcEFzeW5jO1xuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBzeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IFtdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzTmV4dCA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsuY2FsbCh0aGlzLCBjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZnVuY3Rpb24gbWFwQXN5bmMoYXJyYXksIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcblxuICB2YXIgaXNEb25lID0gZmFsc2UsXG4gICAgICBkb25lQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSkge1xuICAgIGlmIChpc0RvbmUpIHJldHVybjtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICBpc0RvbmUgPSArK2RvbmVDb3VudCA9PT0gbGVuZ3RoO1xuXG4gICAgICBpZiAoaXNEb25lKSBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgd29yayhpdGVtLCBpbmRleCwgZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEEgbWl4aW4gdGhhdCBhZGRzIHRoZSBcImhpc3RvcnlcIiBpbnN0YW5jZSB2YXJpYWJsZSB0byBjb21wb25lbnRzLlxuICovXG52YXIgSGlzdG9yeSA9IHtcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICBoaXN0b3J5OiBfSW50ZXJuYWxQcm9wVHlwZXMuaGlzdG9yeVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAndGhlIGBIaXN0b3J5YCBtaXhpbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgYWNjZXNzIGBjb250ZXh0LnJvdXRlcmAgd2l0aCB5b3VyIG93biBgY29udGV4dFR5cGVzYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWhpc3RvcnltaXhpbicpIDogdm9pZCAwO1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuY29udGV4dC5oaXN0b3J5O1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTGluayA9IHJlcXVpcmUoJy4vTGluaycpO1xuXG52YXIgX0xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQW4gPEluZGV4TGluaz4gaXMgdXNlZCB0byBsaW5rIHRvIGFuIDxJbmRleFJvdXRlPi5cbiAqL1xudmFyIEluZGV4TGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhMaW5rJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9MaW5rMi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBvbmx5QWN0aXZlT25JbmRleDogdHJ1ZSB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9SZWRpcmVjdCA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcblxudmFyIF9SZWRpcmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWRpcmVjdCk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBbiA8SW5kZXhSZWRpcmVjdD4gaXMgdXNlZCB0byByZWRpcmVjdCBmcm9tIGFuIGluZGV4Um91dGUuXG4gKi9cblxudmFyIEluZGV4UmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4UmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9IF9SZWRpcmVjdDIuZGVmYXVsdC5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FuIDxJbmRleFJlZGlyZWN0PiBkb2VzIG5vdCBtYWtlIHNlbnNlIGF0IHRoZSByb290IG9mIHlvdXIgcm91dGUgY29uZmlnJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRvOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBxdWVyeTogb2JqZWN0LFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgb25FbnRlcjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8SW5kZXhSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZ1bmMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLmZ1bmM7XG5cbi8qKlxuICogQW4gPEluZGV4Um91dGU+IGlzIHVzZWQgdG8gc3BlY2lmeSBpdHMgcGFyZW50J3MgPFJvdXRlIGluZGV4Um91dGU+IGluXG4gKiBhIEpTWCByb3V0ZSBjb25maWcuXG4gKi9cblxudmFyIEluZGV4Um91dGUgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4Um91dGUnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBbiA8SW5kZXhSb3V0ZT4gZG9lcyBub3QgbWFrZSBzZW5zZSBhdCB0aGUgcm9vdCBvZiB5b3VyIHJvdXRlIGNvbmZpZycpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPEluZGV4Um91dGU+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4Um91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJvdXRlcyA9IGV4cG9ydHMucm91dGUgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudCA9IGV4cG9ydHMuaGlzdG9yeSA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZmFsc3kgPSBmYWxzeTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0O1xudmFyIGFycmF5T2YgPSBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2Y7XG52YXIgb25lT2ZUeXBlID0gX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGU7XG52YXIgZWxlbWVudCA9IF9yZWFjdC5Qcm9wVHlwZXMuZWxlbWVudDtcbnZhciBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGU7XG52YXIgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XG5mdW5jdGlvbiBmYWxzeShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkgcmV0dXJuIG5ldyBFcnJvcignPCcgKyBjb21wb25lbnROYW1lICsgJz4gc2hvdWxkIG5vdCBoYXZlIGEgXCInICsgcHJvcE5hbWUgKyAnXCIgcHJvcCcpO1xufVxuXG52YXIgaGlzdG9yeSA9IGV4cG9ydHMuaGlzdG9yeSA9IHNoYXBlKHtcbiAgbGlzdGVuOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgY29tcG9uZW50ID0gZXhwb3J0cy5jb21wb25lbnQgPSBvbmVPZlR5cGUoW2Z1bmMsIHN0cmluZ10pO1xudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBvbmVPZlR5cGUoW2NvbXBvbmVudCwgb2JqZWN0XSk7XG52YXIgcm91dGUgPSBleHBvcnRzLnJvdXRlID0gb25lT2ZUeXBlKFtvYmplY3QsIGVsZW1lbnRdKTtcbnZhciByb3V0ZXMgPSBleHBvcnRzLnJvdXRlcyA9IG9uZU9mVHlwZShbcm91dGUsIGFycmF5T2Yocm91dGUpXSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBvYmplY3QgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBUaGUgTGlmZWN5Y2xlIG1peGluIGFkZHMgdGhlIHJvdXRlcldpbGxMZWF2ZSBsaWZlY3ljbGUgbWV0aG9kIHRvIGFcbiAqIGNvbXBvbmVudCB0aGF0IG1heSBiZSB1c2VkIHRvIGNhbmNlbCBhIHRyYW5zaXRpb24gb3IgcHJvbXB0IHRoZSB1c2VyXG4gKiBmb3IgY29uZmlybWF0aW9uLlxuICpcbiAqIE9uIHN0YW5kYXJkIHRyYW5zaXRpb25zLCByb3V0ZXJXaWxsTGVhdmUgcmVjZWl2ZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZVxuICogbG9jYXRpb24gd2UncmUgdHJhbnNpdGlvbmluZyB0by4gVG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLCByZXR1cm4gZmFsc2UuXG4gKiBUbyBwcm9tcHQgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbiwgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykuXG4gKlxuICogRHVyaW5nIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgKGFzc3VtaW5nIHlvdSdyZSB1c2luZyB0aGUgdXNlQmVmb3JlVW5sb2FkXG4gKiBoaXN0b3J5IGVuaGFuY2VyKSwgcm91dGVyV2lsbExlYXZlIGRvZXMgbm90IHJlY2VpdmUgYSBsb2NhdGlvbiBvYmplY3RcbiAqIGJlY2F1c2UgaXQgaXNuJ3QgcG9zc2libGUgZm9yIHVzIHRvIGtub3cgdGhlIGxvY2F0aW9uIHdlJ3JlIHRyYW5zaXRpb25pbmdcbiAqIHRvLiBJbiB0aGlzIGNhc2Ugcm91dGVyV2lsbExlYXZlIG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudFxuICogdGhlIHVzZXIgZnJvbSBjbG9zaW5nIHRoZSB3aW5kb3cvdGFiLlxuICovXG5cbnZhciBMaWZlY3ljbGUgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgLy8gTmVzdGVkIGNoaWxkcmVuIHJlY2VpdmUgdGhlIHJvdXRlIGFzIGNvbnRleHQsIGVpdGhlclxuICAgIC8vIHNldCBieSB0aGUgcm91dGUgY29tcG9uZW50IHVzaW5nIHRoZSBSb3V0ZUNvbnRleHQgbWl4aW5cbiAgICAvLyBvciBieSBzb21lIG90aGVyIGFuY2VzdG9yLlxuICAgIHJvdXRlOiBvYmplY3RcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICAvLyBSb3V0ZSBjb21wb25lbnRzIHJlY2VpdmUgdGhlIHJvdXRlIG9iamVjdCBhcyBhIHByb3AuXG4gICAgcm91dGU6IG9iamVjdFxuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ3RoZSBgTGlmZWN5Y2xlYCBtaXhpbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlci5zZXRSb3V0ZUxlYXZlSG9vayhyb3V0ZSwgaG9vaylgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItbGlmZWN5Y2xlbWl4aW4nKSA6IHZvaWQgMDtcbiAgICAhdGhpcy5yb3V0ZXJXaWxsTGVhdmUgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIExpZmVjeWNsZSBtaXhpbiByZXF1aXJlcyB5b3UgdG8gZGVmaW5lIGEgcm91dGVyV2lsbExlYXZlIG1ldGhvZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciByb3V0ZSA9IHRoaXMucHJvcHMucm91dGUgfHwgdGhpcy5jb250ZXh0LnJvdXRlO1xuXG4gICAgIXJvdXRlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBMaWZlY3ljbGUgbWl4aW4gbXVzdCBiZSB1c2VkIG9uIGVpdGhlciBhKSBhIDxSb3V0ZSBjb21wb25lbnQ+IG9yICcgKyAnYikgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlIGNvbXBvbmVudD4gdGhhdCB1c2VzIHRoZSBSb3V0ZUNvbnRleHQgbWl4aW4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSA9IHRoaXMuY29udGV4dC5oaXN0b3J5Lmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXJXaWxsTGVhdmUpO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKSB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSgpO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaWZlY3ljbGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBib29sID0gX1JlYWN0JFByb3BUeXBlcy5ib29sO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb25lT2ZUeXBlID0gX1JlYWN0JFByb3BUeXBlcy5vbmVPZlR5cGU7XG5cblxuZnVuY3Rpb24gaXNMZWZ0Q2xpY2tFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuXG4vLyBUT0RPOiBEZS1kdXBsaWNhdGUgYWdhaW5zdCBoYXNBbnlQcm9wZXJ0aWVzIGluIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLlxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkpIHJldHVybiBmYWxzZTtcbiAgfXJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbkRlc2NyaXB0b3IodG8sIF9yZWYpIHtcbiAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeTtcbiAgdmFyIGhhc2ggPSBfcmVmLmhhc2g7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgaWYgKHF1ZXJ5IHx8IGhhc2ggfHwgc3RhdGUpIHtcbiAgICByZXR1cm4geyBwYXRobmFtZTogdG8sIHF1ZXJ5OiBxdWVyeSwgaGFzaDogaGFzaCwgc3RhdGU6IHN0YXRlIH07XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogQSA8TGluaz4gaXMgdXNlZCB0byBjcmVhdGUgYW4gPGE+IGVsZW1lbnQgdGhhdCBsaW5rcyB0byBhIHJvdXRlLlxuICogV2hlbiB0aGF0IHJvdXRlIGlzIGFjdGl2ZSwgdGhlIGxpbmsgZ2V0cyB0aGUgdmFsdWUgb2YgaXRzXG4gKiBhY3RpdmVDbGFzc05hbWUgcHJvcC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgeW91IGhhdmUgdGhlIGZvbGxvd2luZyByb3V0ZTpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL3Bvc3RzLzpwb3N0SURcIiBjb21wb25lbnQ9e1Bvc3R9IC8+XG4gKlxuICogWW91IGNvdWxkIHVzZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudCB0byBsaW5rIHRvIHRoYXQgcm91dGU6XG4gKlxuICogICA8TGluayB0bz17YC9wb3N0cy8ke3Bvc3QuaWR9YH0gLz5cbiAqXG4gKiBMaW5rcyBtYXkgcGFzcyBhbG9uZyBsb2NhdGlvbiBzdGF0ZSBhbmQvb3IgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAqIGluIHRoZSBzdGF0ZS9xdWVyeSBwcm9wcywgcmVzcGVjdGl2ZWx5LlxuICpcbiAqICAgPExpbmsgLi4uIHF1ZXJ5PXt7IHNob3c6IHRydWUgfX0gc3RhdGU9e3sgdGhlOiAnc3RhdGUnIH19IC8+XG4gKi9cbnZhciBMaW5rID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdMaW5rJyxcblxuXG4gIGNvbnRleHRUeXBlczoge1xuICAgIHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRvOiBvbmVPZlR5cGUoW3N0cmluZywgb2JqZWN0XSksXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBoYXNoOiBzdHJpbmcsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBhY3RpdmVTdHlsZTogb2JqZWN0LFxuICAgIGFjdGl2ZUNsYXNzTmFtZTogc3RyaW5nLFxuICAgIG9ubHlBY3RpdmVPbkluZGV4OiBib29sLmlzUmVxdWlyZWQsXG4gICAgb25DbGljazogZnVuYyxcbiAgICB0YXJnZXQ6IHN0cmluZ1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbmx5QWN0aXZlT25JbmRleDogZmFsc2UsXG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICB9LFxuICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKSB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICF0aGlzLmNvbnRleHQucm91dGVyID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxMaW5rPnMgcmVuZGVyZWQgb3V0c2lkZSBvZiBhIHJvdXRlciBjb250ZXh0IGNhbm5vdCBuYXZpZ2F0ZS4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB8fCAhaXNMZWZ0Q2xpY2tFdmVudChldmVudCkpIHJldHVybjtcblxuICAgIC8vIElmIHRhcmdldCBwcm9wIGlzIHNldCAoZS5nLiB0byBcIl9ibGFua1wiKSwgbGV0IGJyb3dzZXIgaGFuZGxlIGxpbmsuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB1bnRlc3RhYmxlIHdpdGggS2FybWEgKi9cbiAgICBpZiAodGhpcy5wcm9wcy50YXJnZXQpIHJldHVybjtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdG8gPSBfcHJvcHMudG87XG4gICAgdmFyIHF1ZXJ5ID0gX3Byb3BzLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gX3Byb3BzLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gX3Byb3BzLnN0YXRlO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yKHRvLCB7IHF1ZXJ5OiBxdWVyeSwgaGFzaDogaGFzaCwgc3RhdGU6IHN0YXRlIH0pO1xuXG4gICAgdGhpcy5jb250ZXh0LnJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0byA9IF9wcm9wczIudG87XG4gICAgdmFyIHF1ZXJ5ID0gX3Byb3BzMi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IF9wcm9wczIuaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBfcHJvcHMyLnN0YXRlO1xuICAgIHZhciBhY3RpdmVDbGFzc05hbWUgPSBfcHJvcHMyLmFjdGl2ZUNsYXNzTmFtZTtcbiAgICB2YXIgYWN0aXZlU3R5bGUgPSBfcHJvcHMyLmFjdGl2ZVN0eWxlO1xuICAgIHZhciBvbmx5QWN0aXZlT25JbmRleCA9IF9wcm9wczIub25seUFjdGl2ZU9uSW5kZXg7XG5cbiAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMiwgWyd0bycsICdxdWVyeScsICdoYXNoJywgJ3N0YXRlJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdhY3RpdmVTdHlsZScsICdvbmx5QWN0aXZlT25JbmRleCddKTtcblxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCEocXVlcnkgfHwgaGFzaCB8fCBzdGF0ZSksICd0aGUgYHF1ZXJ5YCwgYGhhc2hgLCBhbmQgYHN0YXRlYCBwcm9wcyBvbiBgPExpbms+YCBhcmUgZGVwcmVjYXRlZCwgdXNlIGA8TGluayB0bz17eyBwYXRobmFtZSwgcXVlcnksIGhhc2gsIHN0YXRlIH19Lz4uIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcblxuICAgIC8vIElnbm9yZSBpZiByZW5kZXJlZCBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIHJvdXRlciwgc2ltcGxpZmllcyB1bml0IHRlc3RpbmcuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXI7XG5cblxuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIC8vIElmIHVzZXIgZG9lcyBub3Qgc3BlY2lmeSBhIGB0b2AgcHJvcCwgcmV0dXJuIGFuIGVtcHR5IGFuY2hvciB0YWcuXG4gICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgeyBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9KTtcbiAgICAgIHByb3BzLmhyZWYgPSByb3V0ZXIuY3JlYXRlSHJlZihsb2NhdGlvbik7XG5cbiAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUgfHwgYWN0aXZlU3R5bGUgIT0gbnVsbCAmJiAhaXNFbXB0eU9iamVjdChhY3RpdmVTdHlsZSkpIHtcbiAgICAgICAgaWYgKHJvdXRlci5pc0FjdGl2ZShsb2NhdGlvbiwgb25seUFjdGl2ZU9uSW5kZXgpKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmVTdHlsZSkgcHJvcHMuc3R5bGUgPSBfZXh0ZW5kcyh7fSwgcHJvcHMuc3R5bGUsIGFjdGl2ZVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBpbGVQYXR0ZXJuID0gY29tcGlsZVBhdHRlcm47XG5leHBvcnRzLm1hdGNoUGF0dGVybiA9IG1hdGNoUGF0dGVybjtcbmV4cG9ydHMuZ2V0UGFyYW1OYW1lcyA9IGdldFBhcmFtTmFtZXM7XG5leHBvcnRzLmdldFBhcmFtcyA9IGdldFBhcmFtcztcbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGZvcm1hdFBhdHRlcm47XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBfY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICB2YXIgcmVnZXhwU291cmNlID0gJyc7XG4gIHZhciBwYXJhbU5hbWVzID0gW107XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICB2YXIgbWF0Y2ggPSB2b2lkIDAsXG4gICAgICBsYXN0SW5kZXggPSAwLFxuICAgICAgbWF0Y2hlciA9IC86KFthLXpBLVpfJF1bYS16QS1aMC05XyRdKil8XFwqXFwqfFxcKnxcXCh8XFwpL2c7XG4gIHdoaWxlIChtYXRjaCA9IG1hdGNoZXIuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGlmIChtYXRjaC5pbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSBlc2NhcGVSZWdFeHAocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyhbXi9dKyknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKionKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyguKiknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoLio/KSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJygnKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyg/Oic7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyknKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyk/JztcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChtYXRjaFswXSk7XG5cbiAgICBsYXN0SW5kZXggPSBtYXRjaGVyLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIHBhdHRlcm4ubGVuZ3RoKSk7XG4gICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0dGVybjogcGF0dGVybixcbiAgICByZWdleHBTb3VyY2U6IHJlZ2V4cFNvdXJjZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHRva2VuczogdG9rZW5zXG4gIH07XG59XG5cbnZhciBDb21waWxlZFBhdHRlcm5zQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dKSBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl0gPSBfY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgcmV0dXJuIENvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBtYXRjaCBhIHBhdHRlcm4gb24gdGhlIGdpdmVuIHBhdGhuYW1lLiBQYXR0ZXJucyBtYXkgdXNlXG4gKiB0aGUgZm9sbG93aW5nIHNwZWNpYWwgY2hhcmFjdGVyczpcbiAqXG4gKiAtIDpwYXJhbU5hbWUgICAgIE1hdGNoZXMgYSBVUkwgc2VnbWVudCB1cCB0byB0aGUgbmV4dCAvLCA/LCBvciAjLiBUaGVcbiAqICAgICAgICAgICAgICAgICAgY2FwdHVyZWQgc3RyaW5nIGlzIGNvbnNpZGVyZWQgYSBcInBhcmFtXCJcbiAqIC0gKCkgICAgICAgICAgICAgV3JhcHMgYSBzZWdtZW50IG9mIHRoZSBVUkwgdGhhdCBpcyBvcHRpb25hbFxuICogLSAqICAgICAgICAgICAgICBDb25zdW1lcyAobm9uLWdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHRcbiAqICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWZcbiAqICAgICAgICAgICAgICAgICAgdGhlcmUgaXMgbm9uZVxuICogLSAqKiAgICAgICAgICAgICBDb25zdW1lcyAoZ3JlZWR5KSBhbGwgY2hhcmFjdGVycyB1cCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAqICAgICAgICAgICAgICAgICAgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZiB0aGVyZSBpcyBub25lXG4gKlxuICogIFRoZSBmdW5jdGlvbiBjYWxscyBjYWxsYmFjayhlcnJvciwgbWF0Y2hlZCkgd2hlbiBmaW5pc2hlZC5cbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcmVtYWluaW5nUGF0aG5hbWVcbiAqIC0gcGFyYW1OYW1lc1xuICogLSBwYXJhbVZhbHVlc1xuICovXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgLy8gRW5zdXJlIHBhdHRlcm4gc3RhcnRzIHdpdGggbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kgd2l0aCBwYXRobmFtZS5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gJy8nICsgcGF0dGVybjtcbiAgfVxuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4yID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgdmFyIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlO1xuICB2YXIgcGFyYW1OYW1lcyA9IF9jb21waWxlUGF0dGVybjIucGFyYW1OYW1lcztcbiAgdmFyIHRva2VucyA9IF9jb21waWxlUGF0dGVybjIudG9rZW5zO1xuXG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHJlZ2V4cFNvdXJjZSArPSAnLz8nOyAvLyBBbGxvdyBvcHRpb25hbCBwYXRoIHNlcGFyYXRvciBhdCBlbmQuXG4gIH1cblxuICAvLyBTcGVjaWFsLWNhc2UgcGF0dGVybnMgbGlrZSAnKicgZm9yIGNhdGNoLWFsbCByb3V0ZXMuXG4gIGlmICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJyQnO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyByZWdleHBTb3VyY2UsICdpJykpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1hdGNoZWRQYXRoID0gbWF0Y2hbMF07XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cihtYXRjaGVkUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggZW5kcyBhdCBhIHBhdGggc2VwYXJhdG9yLCBpZiB3ZSBkaWRuJ3QgbWF0Y2hcbiAgICAvLyB0aGUgZnVsbCBwYXRoLCBzbyBhbnkgcmVtYWluaW5nIHBhdGhuYW1lIGlzIGEgbmV3IHBhdGggc2VnbWVudC5cbiAgICBpZiAobWF0Y2hlZFBhdGguY2hhckF0KG1hdGNoZWRQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIHBhdGhuYW1lLCB0cmVhdCB0aGUgcGF0aCBzZXBhcmF0b3IgYXMgcGFydCBvZlxuICAgIC8vIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgZm9yIHByb3Blcmx5IGNvbnRpbnVpbmcgdGhlIG1hdGNoLlxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gJy8nICsgcmVtYWluaW5nUGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHBhcmFtVmFsdWVzOiBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICYmIGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbU5hbWVzKHBhdHRlcm4pIHtcbiAgcmV0dXJuIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLnBhcmFtTmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtcyhwYXR0ZXJuLCBwYXRobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1OYW1lcyA9IG1hdGNoLnBhcmFtTmFtZXM7XG4gIHZhciBwYXJhbVZhbHVlcyA9IG1hdGNoLnBhcmFtVmFsdWVzO1xuXG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBwYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWVzW2luZGV4XTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuIFRocm93c1xuICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHBhdHRlcm4gZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXR0ZXJuKHBhdHRlcm4sIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjMgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICB2YXIgdG9rZW5zID0gX2NvbXBpbGVQYXR0ZXJuMy50b2tlbnM7XG5cbiAgdmFyIHBhcmVuQ291bnQgPSAwLFxuICAgICAgcGF0aG5hbWUgPSAnJyxcbiAgICAgIHNwbGF0SW5kZXggPSAwO1xuXG4gIHZhciB0b2tlbiA9IHZvaWQgMCxcbiAgICAgIHBhcmFtTmFtZSA9IHZvaWQgMCxcbiAgICAgIHBhcmFtVmFsdWUgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbiA9PT0gJyonIHx8IHRva2VuID09PSAnKionKSB7XG4gICAgICBwYXJhbVZhbHVlID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc3BsYXQpID8gcGFyYW1zLnNwbGF0W3NwbGF0SW5kZXgrK10gOiBwYXJhbXMuc3BsYXQ7XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSShwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKCcpIHtcbiAgICAgIHBhcmVuQ291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKScpIHtcbiAgICAgIHBhcmVuQ291bnQgLT0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICBwYXJhbU5hbWUgPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIFwiJXNcIiBwYXJhbWV0ZXIgZm9yIHBhdGggXCIlc1wiJywgcGFyYW1OYW1lLCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aG5hbWUgKz0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJvdXRlciA9IGV4cG9ydHMucm91dGVzID0gZXhwb3J0cy5yb3V0ZSA9IGV4cG9ydHMuY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50ID0gZXhwb3J0cy5sb2NhdGlvbiA9IGV4cG9ydHMuaGlzdG9yeSA9IGV4cG9ydHMuZmFsc3kgPSBleHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLnJvdXRlclNoYXBlID0gdW5kZWZpbmVkO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxudmFyIEludGVybmFsUHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0ludGVybmFsUHJvcFR5cGVzKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZ1bmMgPSBfcmVhY3QuUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3Q7XG52YXIgc2hhcGUgPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlO1xudmFyIHN0cmluZyA9IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nO1xudmFyIHJvdXRlclNoYXBlID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IHNoYXBlKHtcbiAgcHVzaDogZnVuYy5pc1JlcXVpcmVkLFxuICByZXBsYWNlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvQmFjazogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0ZvcndhcmQ6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgc2V0Um91dGVMZWF2ZUhvb2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNBY3RpdmU6IGZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cbnZhciBsb2NhdGlvblNoYXBlID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gc2hhcGUoe1xuICBwYXRobmFtZTogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHNlYXJjaDogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHN0YXRlOiBvYmplY3QsXG4gIGFjdGlvbjogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGtleTogc3RyaW5nXG59KTtcblxuLy8gRGVwcmVjYXRlZCBzdHVmZiBiZWxvdzpcblxudmFyIGZhbHN5ID0gZXhwb3J0cy5mYWxzeSA9IEludGVybmFsUHJvcFR5cGVzLmZhbHN5O1xudmFyIGhpc3RvcnkgPSBleHBvcnRzLmhpc3RvcnkgPSBJbnRlcm5hbFByb3BUeXBlcy5oaXN0b3J5O1xudmFyIGxvY2F0aW9uID0gZXhwb3J0cy5sb2NhdGlvbiA9IGxvY2F0aW9uU2hhcGU7XG52YXIgY29tcG9uZW50ID0gZXhwb3J0cy5jb21wb25lbnQgPSBJbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnQ7XG52YXIgY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50cyA9IEludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudHM7XG52YXIgcm91dGUgPSBleHBvcnRzLnJvdXRlID0gSW50ZXJuYWxQcm9wVHlwZXMucm91dGU7XG52YXIgcm91dGVzID0gZXhwb3J0cy5yb3V0ZXMgPSBJbnRlcm5hbFByb3BUeXBlcy5yb3V0ZXM7XG52YXIgcm91dGVyID0gZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXJTaGFwZTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVwcmVjYXRlUHJvcFR5cGUgPSBmdW5jdGlvbiBkZXByZWNhdGVQcm9wVHlwZShwcm9wVHlwZSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gcHJvcFR5cGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUgPSBmdW5jdGlvbiBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKHByb3BUeXBlKSB7XG4gICAgICByZXR1cm4gZGVwcmVjYXRlUHJvcFR5cGUocHJvcFR5cGUsICdUaGlzIHByb3AgdHlwZSBpcyBub3QgaW50ZW5kZWQgZm9yIGV4dGVybmFsIHVzZSwgYW5kIHdhcyBwcmV2aW91c2x5IGV4cG9ydGVkIGJ5IG1pc3Rha2UuIFRoZXNlIGludGVybmFsIHByb3AgdHlwZXMgYXJlIGRlcHJlY2F0ZWQgZm9yIGV4dGVybmFsIHVzZSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGxhdGVyIHZlcnNpb24uJyk7XG4gICAgfTtcblxuICAgIHZhciBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUgPSBmdW5jdGlvbiBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUocHJvcFR5cGUsIG5hbWUpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGVQcm9wVHlwZShwcm9wVHlwZSwgJ1RoZSBgJyArIG5hbWUgKyAnYCBwcm9wIHR5cGUgaXMgbm93IGV4cG9ydGVkIGFzIGAnICsgbmFtZSArICdTaGFwZWAgdG8gYXZvaWQgbmFtZSBjb25mbGljdHMuIFRoaXMgZXhwb3J0IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGxhdGVyIHZlcnNpb24uJyk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuZmFsc3kgPSBmYWxzeSA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoZmFsc3kpO1xuICAgIGV4cG9ydHMuaGlzdG9yeSA9IGhpc3RvcnkgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGhpc3RvcnkpO1xuICAgIGV4cG9ydHMuY29tcG9uZW50ID0gY29tcG9uZW50ID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShjb21wb25lbnQpO1xuICAgIGV4cG9ydHMuY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGNvbXBvbmVudHMpO1xuICAgIGV4cG9ydHMucm91dGUgPSByb3V0ZSA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUocm91dGUpO1xuICAgIGV4cG9ydHMucm91dGVzID0gcm91dGVzID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShyb3V0ZXMpO1xuXG4gICAgZXhwb3J0cy5sb2NhdGlvbiA9IGxvY2F0aW9uID0gZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlKGxvY2F0aW9uLCAnbG9jYXRpb24nKTtcbiAgICBleHBvcnRzLnJvdXRlciA9IHJvdXRlciA9IGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZShyb3V0ZXIsICdyb3V0ZXInKTtcbiAgfSkoKTtcbn1cblxudmFyIGRlZmF1bHRFeHBvcnQgPSB7XG4gIGZhbHN5OiBmYWxzeSxcbiAgaGlzdG9yeTogaGlzdG9yeSxcbiAgbG9jYXRpb246IGxvY2F0aW9uLFxuICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgcm91dGU6IHJvdXRlLFxuICAvLyBGb3Igc29tZSByZWFzb24sIHJvdXRlcyB3YXMgbmV2ZXIgaGVyZS5cbiAgcm91dGVyOiByb3V0ZXJcbn07XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlZmF1bHRFeHBvcnQgPSAoMCwgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyLmRlZmF1bHQpKGRlZmF1bHRFeHBvcnQsICdUaGUgZGVmYXVsdCBleHBvcnQgZnJvbSBgcmVhY3Qtcm91dGVyL2xpYi9Qcm9wVHlwZXNgIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIG5hbWVkIGV4cG9ydHMgaW5zdGVhZC4nKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdEV4cG9ydDsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJlZGlyZWN0PiBpcyB1c2VkIHRvIGRlY2xhcmUgYW5vdGhlciBVUkwgcGF0aCBhIGNsaWVudCBzaG91bGRcbiAqIGJlIHNlbnQgdG8gd2hlbiB0aGV5IHJlcXVlc3QgYSBnaXZlbiBVUkwuXG4gKlxuICogUmVkaXJlY3RzIGFyZSBwbGFjZWQgYWxvbmdzaWRlIHJvdXRlcyBpbiB0aGUgcm91dGUgY29uZmlndXJhdGlvblxuICogYW5kIGFyZSB0cmF2ZXJzZWQgaW4gdGhlIHNhbWUgbWFubmVyLlxuICovXG5cbnZhciBSZWRpcmVjdCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciByb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xuXG4gICAgICBpZiAocm91dGUuZnJvbSkgcm91dGUucGF0aCA9IHJvdXRlLmZyb207XG5cbiAgICAgIHJvdXRlLm9uRW50ZXIgPSBmdW5jdGlvbiAobmV4dFN0YXRlLCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IG5leHRTdGF0ZS5sb2NhdGlvbjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5leHRTdGF0ZS5wYXJhbXM7XG5cblxuICAgICAgICB2YXIgcGF0aG5hbWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChyb3V0ZS50by5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybikocm91dGUudG8sIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJvdXRlLnRvKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm91dGVJbmRleCA9IG5leHRTdGF0ZS5yb3V0ZXMuaW5kZXhPZihyb3V0ZSk7XG4gICAgICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSBSZWRpcmVjdC5nZXRSb3V0ZVBhdHRlcm4obmV4dFN0YXRlLnJvdXRlcywgcm91dGVJbmRleCAtIDEpO1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gcGFyZW50UGF0dGVybi5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyByb3V0ZS50bztcbiAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm4pKHBhdHRlcm4sIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsYWNlKHtcbiAgICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICAgICAgcXVlcnk6IHJvdXRlLnF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5LFxuICAgICAgICAgIHN0YXRlOiByb3V0ZS5zdGF0ZSB8fCBsb2NhdGlvbi5zdGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9LFxuICAgIGdldFJvdXRlUGF0dGVybjogZnVuY3Rpb24gZ2V0Um91dGVQYXR0ZXJuKHJvdXRlcywgcm91dGVJbmRleCkge1xuICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IHJvdXRlSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gICAgICAgIHBhcmVudFBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhcmVudFBhdHRlcm47XG5cbiAgICAgICAgaWYgKHBhdHRlcm4uaW5kZXhPZignLycpID09PSAwKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcvJyArIHBhcmVudFBhdHRlcm47XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmcm9tOiBzdHJpbmcsIC8vIEFsaWFzIGZvciBwYXRoXG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeVxuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVkaXJlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xuXG4vKipcbiAqIEEgPFJvdXRlPiBpcyB1c2VkIHRvIGRlY2xhcmUgd2hpY2ggY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgdG8gdGhlXG4gKiBwYWdlIHdoZW4gdGhlIFVSTCBtYXRjaGVzIGEgZ2l2ZW4gcGF0dGVybi5cbiAqXG4gKiBSb3V0ZXMgYXJlIGFycmFuZ2VkIGluIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlLiBXaGVuIGEgbmV3IFVSTCBpc1xuICogcmVxdWVzdGVkLCB0aGUgdHJlZSBpcyBzZWFyY2hlZCBkZXB0aC1maXJzdCB0byBmaW5kIGEgcm91dGUgd2hvc2VcbiAqIHBhdGggbWF0Y2hlcyB0aGUgVVJMLiAgV2hlbiBvbmUgaXMgZm91bmQsIGFsbCByb3V0ZXMgaW4gdGhlIHRyZWVcbiAqIHRoYXQgbGVhZCB0byBpdCBhcmUgY29uc2lkZXJlZCBcImFjdGl2ZVwiIGFuZCB0aGVpciBjb21wb25lbnRzIGFyZVxuICogcmVuZGVyZWQgaW50byB0aGUgRE9NLCBuZXN0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgaW4gdGhlIHRyZWUuXG4gKi9cblxudmFyIFJvdXRlID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZScsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnRcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPFJvdXRlPiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgb2JqZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogVGhlIFJvdXRlQ29udGV4dCBtaXhpbiBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IGZvciByb3V0ZVxuICogY29tcG9uZW50cyB0byBzZXQgdGhlIHJvdXRlIGluIGNvbnRleHQuIFRoaXMgaXMgbmVlZGVkIGZvclxuICogcm91dGVzIHRoYXQgcmVuZGVyIGVsZW1lbnRzIHRoYXQgd2FudCB0byB1c2UgdGhlIExpZmVjeWNsZVxuICogbWl4aW4gdG8gcHJldmVudCB0cmFuc2l0aW9ucy5cbiAqL1xuXG52YXIgUm91dGVDb250ZXh0ID0ge1xuXG4gIHByb3BUeXBlczoge1xuICAgIHJvdXRlOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgcm91dGU6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlOiB0aGlzLnByb3BzLnJvdXRlXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdUaGUgYFJvdXRlQ29udGV4dGAgbWl4aW4gaXMgZGVwcmVjYXRlZC4gWW91IGNhbiBwcm92aWRlIGB0aGlzLnByb3BzLnJvdXRlYCBvbiBjb250ZXh0IHdpdGggeW91ciBvd24gYGNvbnRleHRUeXBlc2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1yb3V0ZWNvbnRleHRtaXhpbicpIDogdm9pZCAwO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZUNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuaXNSZWFjdENoaWxkcmVuID0gaXNSZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQgPSBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW47XG5leHBvcnRzLmNyZWF0ZVJvdXRlcyA9IGNyZWF0ZVJvdXRlcztcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQob2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gaXNSZWFjdENoaWxkcmVuKG9iamVjdCkge1xuICByZXR1cm4gaXNWYWxpZENoaWxkKG9iamVjdCkgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpICYmIG9iamVjdC5ldmVyeShpc1ZhbGlkQ2hpbGQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZShkZWZhdWx0UHJvcHMsIHByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgcm91dGUgPSBjcmVhdGVSb3V0ZSh0eXBlLmRlZmF1bHRQcm9wcywgZWxlbWVudC5wcm9wcyk7XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkUm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4ocm91dGUuY2hpbGRyZW4sIHJvdXRlKTtcblxuICAgIGlmIChjaGlsZFJvdXRlcy5sZW5ndGgpIHJvdXRlLmNoaWxkUm91dGVzID0gY2hpbGRSb3V0ZXM7XG5cbiAgICBkZWxldGUgcm91dGUuY2hpbGRyZW47XG4gIH1cblxuICByZXR1cm4gcm91dGU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHJvdXRlcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gUmVhY3RDaGlsZHJlbi4gSlNYXG4gKiBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIHZpc3VhbGl6ZSBob3cgcm91dGVzIGluIHRoZSBoaWVyYXJjaHkgYXJlXG4gKiBuZXN0ZWQuXG4gKlxuICogICBpbXBvcnQgeyBSb3V0ZSwgY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4gfSBmcm9tICdyZWFjdC1yb3V0ZXInXG4gKlxuICogICBjb25zdCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihcbiAqICAgICA8Um91dGUgY29tcG9uZW50PXtBcHB9PlxuICogICAgICAgPFJvdXRlIHBhdGg9XCJob21lXCIgY29tcG9uZW50PXtEYXNoYm9hcmR9Lz5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwibmV3c1wiIGNvbXBvbmVudD17TmV3c0ZlZWR9Lz5cbiAqICAgICA8L1JvdXRlPlxuICogICApXG4gKlxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSB1c2VkIHdoZW4geW91IHByb3ZpZGUgPFJvdXRlPiBjaGlsZHJlblxuICogdG8gYSA8Um91dGVyPiBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSkge1xuICB2YXIgcm91dGVzID0gW107XG5cbiAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gQ29tcG9uZW50IGNsYXNzZXMgbWF5IGhhdmUgYSBzdGF0aWMgY3JlYXRlKiBtZXRob2QuXG4gICAgICBpZiAoZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkge1xuICAgICAgICB2YXIgcm91dGUgPSBlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKTtcblxuICAgICAgICBpZiAocm91dGUpIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlcy5wdXNoKGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygcm91dGVzIGZyb20gdGhlIGdpdmVuIG9iamVjdCB3aGljaFxuICogbWF5IGJlIGEgSlNYIHJvdXRlLCBhIHBsYWluIG9iamVjdCByb3V0ZSwgb3IgYW4gYXJyYXkgb2YgZWl0aGVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMocm91dGVzKSB7XG4gIGlmIChpc1JlYWN0Q2hpbGRyZW4ocm91dGVzKSkge1xuICAgIHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlcyk7XG4gIH0gZWxzZSBpZiAocm91dGVzICYmICFBcnJheS5pc0FycmF5KHJvdXRlcykpIHtcbiAgICByb3V0ZXMgPSBbcm91dGVzXTtcbiAgfVxuXG4gIHJldHVybiByb3V0ZXM7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBpc0RlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgcmV0dXJuICFoaXN0b3J5IHx8ICFoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG5mdW5jdGlvbiBpc1Vuc3VwcG9ydGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gIC8vIHYzIGhpc3RvcmllcyBleHBvc2UgZ2V0Q3VycmVudExvY2F0aW9uLCBidXQgYXJlbid0IGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gIHJldHVybiBoaXN0b3J5ICYmIGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uO1xufVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSb3V0ZXI+IGlzIGEgaGlnaC1sZXZlbCBBUEkgZm9yIGF1dG9tYXRpY2FsbHkgc2V0dGluZyB1cFxuICogYSByb3V0ZXIgdGhhdCByZW5kZXJzIGEgPFJvdXRlckNvbnRleHQ+IHdpdGggYWxsIHRoZSBwcm9wc1xuICogaXQgbmVlZHMgZWFjaCB0aW1lIHRoZSBVUkwgY2hhbmdlcy5cbiAqL1xuXG52YXIgUm91dGVyID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXInLFxuXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzLFxuICAgIHJvdXRlczogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcywgLy8gYWxpYXMgZm9yIGNoaWxkcmVuXG4gICAgcmVuZGVyOiBmdW5jLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmMsXG4gICAgb25FcnJvcjogZnVuYyxcbiAgICBvblVwZGF0ZTogZnVuYyxcblxuICAgIC8vIERlcHJlY2F0ZWQ6XG4gICAgcGFyc2VRdWVyeVN0cmluZzogZnVuYyxcbiAgICBzdHJpbmdpZnlRdWVyeTogZnVuYyxcblxuICAgIC8vIFBSSVZBVEU6IEZvciBjbGllbnQtc2lkZSByZWh5ZHJhdGlvbiBvZiBzZXJ2ZXIgbWF0Y2guXG4gICAgbWF0Y2hDb250ZXh0OiBvYmplY3RcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiBudWxsLFxuICAgICAgcm91dGVzOiBudWxsLFxuICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgY29tcG9uZW50czogbnVsbFxuICAgIH07XG4gIH0sXG4gIGhhbmRsZUVycm9yOiBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLnByb3BzLm9uRXJyb3IpIHtcbiAgICAgIHRoaXMucHJvcHMub25FcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhyb3cgZXJyb3JzIGJ5IGRlZmF1bHQgc28gd2UgZG9uJ3Qgc2lsZW50bHkgc3dhbGxvdyB0aGVtIVxuICAgICAgdGhyb3cgZXJyb3I7IC8vIFRoaXMgZXJyb3IgcHJvYmFibHkgb2NjdXJyZWQgaW4gZ2V0Q2hpbGRSb3V0ZXMgb3IgZ2V0Q29tcG9uZW50cy5cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IF9wcm9wcy5wYXJzZVF1ZXJ5U3RyaW5nO1xuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IF9wcm9wcy5zdHJpbmdpZnlRdWVyeTtcblxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCEocGFyc2VRdWVyeVN0cmluZyB8fCBzdHJpbmdpZnlRdWVyeSksICdgcGFyc2VRdWVyeVN0cmluZ2AgYW5kIGBzdHJpbmdpZnlRdWVyeWAgYXJlIGRlcHJlY2F0ZWQuIFBsZWFzZSBjcmVhdGUgYSBjdXN0b20gaGlzdG9yeS4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWN1c3RvbXF1ZXJ5c3RyaW5nJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgX2NyZWF0ZVJvdXRlck9iamVjdHMgPSB0aGlzLmNyZWF0ZVJvdXRlck9iamVjdHMoKTtcblxuICAgIHZhciBoaXN0b3J5ID0gX2NyZWF0ZVJvdXRlck9iamVjdHMuaGlzdG9yeTtcbiAgICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy50cmFuc2l0aW9uTWFuYWdlcjtcbiAgICB2YXIgcm91dGVyID0gX2NyZWF0ZVJvdXRlck9iamVjdHMucm91dGVyO1xuXG5cbiAgICB0aGlzLl91bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmxpc3RlbihmdW5jdGlvbiAoZXJyb3IsIHN0YXRlKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUsIF90aGlzLnByb3BzLm9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIH0sXG4gIGNyZWF0ZVJvdXRlck9iamVjdHM6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlck9iamVjdHMoKSB7XG4gICAgdmFyIG1hdGNoQ29udGV4dCA9IHRoaXMucHJvcHMubWF0Y2hDb250ZXh0O1xuXG4gICAgaWYgKG1hdGNoQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG1hdGNoQ29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMucHJvcHMuaGlzdG9yeTtcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJvdXRlcyA9IF9wcm9wczIucm91dGVzO1xuICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wczIuY2hpbGRyZW47XG5cblxuICAgICEhaXNVbnN1cHBvcnRlZEhpc3RvcnkoaGlzdG9yeSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnWW91IGhhdmUgcHJvdmlkZWQgYSBoaXN0b3J5IG9iamVjdCBjcmVhdGVkIHdpdGggaGlzdG9yeSB2My54LiAnICsgJ1RoaXMgdmVyc2lvbiBvZiBSZWFjdCBSb3V0ZXIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB2MyBoaXN0b3J5ICcgKyAnb2JqZWN0cy4gUGxlYXNlIHVzZSBoaXN0b3J5IHYyLnggaW5zdGVhZC4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoaXNEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSkge1xuICAgICAgaGlzdG9yeSA9IHRoaXMud3JhcERlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKHJvdXRlcyB8fCBjaGlsZHJlbikpO1xuICAgIHZhciByb3V0ZXIgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdCkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuICAgIHZhciByb3V0aW5nSGlzdG9yeSA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGluZ0hpc3RvcnkpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICAgIHJldHVybiB7IGhpc3Rvcnk6IHJvdXRpbmdIaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcjogdHJhbnNpdGlvbk1hbmFnZXIsIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG4gIHdyYXBEZXByZWNhdGVkSGlzdG9yeTogZnVuY3Rpb24gd3JhcERlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBfcHJvcHMzLnBhcnNlUXVlcnlTdHJpbmc7XG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gX3Byb3BzMy5zdHJpbmdpZnlRdWVyeTtcblxuXG4gICAgdmFyIGNyZWF0ZUhpc3RvcnkgPSB2b2lkIDA7XG4gICAgaWYgKGhpc3RvcnkpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSXQgYXBwZWFycyB5b3UgaGF2ZSBwcm92aWRlZCBhIGRlcHJlY2F0ZWQgaGlzdG9yeSBvYmplY3QgdG8gYDxSb3V0ZXIvPmAsIHBsZWFzZSB1c2UgYSBoaXN0b3J5IHByb3ZpZGVkIGJ5ICcgKyAnUmVhY3QgUm91dGVyIHdpdGggYGltcG9ydCB7IGJyb3dzZXJIaXN0b3J5IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgIG9yIGBpbXBvcnQgeyBoYXNoSGlzdG9yeSB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYC4gJyArICdJZiB5b3UgYXJlIHVzaW5nIGEgY3VzdG9tIGhpc3RvcnkgcGxlYXNlIGNyZWF0ZSBpdCB3aXRoIGB1c2VSb3V0ZXJIaXN0b3J5YCwgc2VlIGh0dHA6Ly90aW55LmNjL3JvdXRlci11c2luZ2hpc3RvcnkgZm9yIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgICBjcmVhdGVIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2BSb3V0ZXJgIG5vIGxvbmdlciBkZWZhdWx0cyB0aGUgaGlzdG9yeSBwcm9wIHRvIGhhc2ggaGlzdG9yeS4gUGxlYXNlIHVzZSB0aGUgYGhhc2hIaXN0b3J5YCBzaW5nbGV0b24gaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWRlZmF1bHRoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgICBjcmVhdGVIaXN0b3J5ID0gX2NyZWF0ZUhhc2hIaXN0b3J5Mi5kZWZhdWx0O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKHsgcGFyc2VRdWVyeVN0cmluZzogcGFyc2VRdWVyeVN0cmluZywgc3RyaW5naWZ5UXVlcnk6IHN0cmluZ2lmeVF1ZXJ5IH0pO1xuICB9LFxuXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKG5leHRQcm9wcy5oaXN0b3J5ID09PSB0aGlzLnByb3BzLmhpc3RvcnksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+OyBpdCB3aWxsIGJlIGlnbm9yZWQnKSA6IHZvaWQgMDtcblxuICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKChuZXh0UHJvcHMucm91dGVzIHx8IG5leHRQcm9wcy5jaGlsZHJlbikgPT09ICh0aGlzLnByb3BzLnJvdXRlcyB8fCB0aGlzLnByb3BzLmNoaWxkcmVuKSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgcm91dGVzPjsgaXQgd2lsbCBiZSBpZ25vcmVkJykgOiB2b2lkIDA7XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fdW5saXN0ZW4pIHRoaXMuX3VubGlzdGVuKCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBsb2NhdGlvbiA9IF9zdGF0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGVzID0gX3N0YXRlLnJvdXRlcztcbiAgICB2YXIgcGFyYW1zID0gX3N0YXRlLnBhcmFtcztcbiAgICB2YXIgY29tcG9uZW50cyA9IF9zdGF0ZS5jb21wb25lbnRzO1xuICAgIHZhciBfcHJvcHM0ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY3JlYXRlRWxlbWVudCA9IF9wcm9wczQuY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgcmVuZGVyID0gX3Byb3BzNC5yZW5kZXI7XG5cbiAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzNCwgWydjcmVhdGVFbGVtZW50JywgJ3JlbmRlciddKTtcblxuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gbnVsbDsgLy8gQXN5bmMgbWF0Y2hcblxuICAgIC8vIE9ubHkgZm9yd2FyZCBub24tUm91dGVyLXNwZWNpZmljIHByb3BzIHRvIHJvdXRpbmcgY29udGV4dCwgYXMgdGhvc2UgYXJlXG4gICAgLy8gdGhlIG9ubHkgb25lcyB0aGF0IG1pZ2h0IGJlIGN1c3RvbSByb3V0aW5nIGNvbnRleHQgcHJvcHMuXG4gICAgT2JqZWN0LmtleXMoUm91dGVyLnByb3BUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcFR5cGUpIHtcbiAgICAgIHJldHVybiBkZWxldGUgcHJvcHNbcHJvcFR5cGVdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIHJvdXRlcjogdGhpcy5yb3V0ZXIsXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByb3V0ZXM6IHJvdXRlcyxcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRcbiAgICB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbnZhciBfZ2V0Um91dGVQYXJhbXMgPSByZXF1aXJlKCcuL2dldFJvdXRlUGFyYW1zJyk7XG5cbnZhciBfZ2V0Um91dGVQYXJhbXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Um91dGVQYXJhbXMpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGFycmF5ID0gX1JlYWN0JFByb3BUeXBlcy5hcnJheTtcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJvdXRlckNvbnRleHQ+IHJlbmRlcnMgdGhlIGNvbXBvbmVudCB0cmVlIGZvciBhIGdpdmVuIHJvdXRlciBzdGF0ZVxuICogYW5kIHNldHMgdGhlIGhpc3Rvcnkgb2JqZWN0IGFuZCB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBjb250ZXh0LlxuICovXG5cbnZhciBSb3V0ZXJDb250ZXh0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXJDb250ZXh0JyxcblxuXG4gIHByb3BUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdCxcbiAgICByb3V0ZXI6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGxvY2F0aW9uOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZXM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgcGFyYW1zOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICBjb21wb25lbnRzOiBhcnJheS5pc1JlcXVpcmVkLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudFxuICAgIH07XG4gIH0sXG5cblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdCxcbiAgICBsb2NhdGlvbjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGVyOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciByb3V0ZXIgPSBfcHJvcHMucm91dGVyO1xuICAgIHZhciBoaXN0b3J5ID0gX3Byb3BzLmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gX3Byb3BzLmxvY2F0aW9uO1xuXG4gICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYDxSb3V0ZXJDb250ZXh0PmAgZXhwZWN0cyBhIGByb3V0ZXJgIHJhdGhlciB0aGFuIGEgYGhpc3RvcnlgJykgOiB2b2lkIDA7XG5cbiAgICAgIHJvdXRlciA9IF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICAgIHNldFJvdXRlTGVhdmVIb29rOiBoaXN0b3J5Lmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgcm91dGVyLmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZTtcbiAgICB9XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgbG9jYXRpb24gPSAoMCwgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyLmRlZmF1bHQpKGxvY2F0aW9uLCAnYGNvbnRleHQubG9jYXRpb25gIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYSByb3V0ZSBjb21wb25lbnRcXCdzIGBwcm9wcy5sb2NhdGlvbmAgaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWFjY2Vzc2luZ2xvY2F0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaGlzdG9yeTogaGlzdG9yeSwgbG9jYXRpb246IGxvY2F0aW9uLCByb3V0ZXI6IHJvdXRlciB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICByZXR1cm4gY29tcG9uZW50ID09IG51bGwgPyBudWxsIDogdGhpcy5wcm9wcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBoaXN0b3J5ID0gX3Byb3BzMi5oaXN0b3J5O1xuICAgIHZhciBsb2NhdGlvbiA9IF9wcm9wczIubG9jYXRpb247XG4gICAgdmFyIHJvdXRlcyA9IF9wcm9wczIucm91dGVzO1xuICAgIHZhciBwYXJhbXMgPSBfcHJvcHMyLnBhcmFtcztcbiAgICB2YXIgY29tcG9uZW50cyA9IF9wcm9wczIuY29tcG9uZW50cztcblxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcblxuICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICBlbGVtZW50ID0gY29tcG9uZW50cy5yZWR1Y2VSaWdodChmdW5jdGlvbiAoZWxlbWVudCwgY29tcG9uZW50cywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkgcmV0dXJuIGVsZW1lbnQ7IC8vIERvbid0IGNyZWF0ZSBuZXcgY2hpbGRyZW47IHVzZSB0aGUgZ3JhbmRjaGlsZHJlbi5cblxuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcm91dGVQYXJhbXMgPSAoMCwgX2dldFJvdXRlUGFyYW1zMi5kZWZhdWx0KShyb3V0ZSwgcGFyYW1zKTtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGhpc3Rvcnk6IGhpc3RvcnksXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIHJvdXRlOiByb3V0ZSxcbiAgICAgICAgICByb3V0ZVBhcmFtczogcm91dGVQYXJhbXMsXG4gICAgICAgICAgcm91dGVzOiByb3V0ZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoKDAsIF9Sb3V0ZVV0aWxzLmlzUmVhY3RDaGlsZHJlbikoZWxlbWVudCkpIHtcbiAgICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbGVtZW50LCBwcm9wKSkgcHJvcHNbcHJvcF0gPSBlbGVtZW50W3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodHlwZW9mIGNvbXBvbmVudHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvbXBvbmVudHMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbXBvbmVudHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBrZXkgYXMgYSBwcm9wIHRvIGNyZWF0ZUVsZW1lbnQgdG8gYWxsb3dcbiAgICAgICAgICAgICAgLy8gY3VzdG9tIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb25zIHRvIGtub3cgd2hpY2ggbmFtZWQgY29tcG9uZW50XG4gICAgICAgICAgICAgIC8vIHRoZXkncmUgcmVuZGVyaW5nLCBmb3IgZS5nLiBtYXRjaGluZyB1cCB0byBmZXRjaGVkIGRhdGEuXG4gICAgICAgICAgICAgIGVsZW1lbnRzW2tleV0gPSBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHNba2V5XSwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGtleToga2V5IH0sIHByb3BzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50cywgcHJvcHMpO1xuICAgICAgfSwgZWxlbWVudCk7XG4gICAgfVxuXG4gICAgIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgPyBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIHJvb3Qgcm91dGUgbXVzdCByZW5kZXIgYSBzaW5nbGUgZWxlbWVudCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5jcmVhdGVSb3V0ZXJPYmplY3QgPSBjcmVhdGVSb3V0ZXJPYmplY3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5ID0gY3JlYXRlUm91dGluZ0hpc3Rvcnk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlck9iamVjdChoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcikge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBzZXRSb3V0ZUxlYXZlSG9vazogdHJhbnNpdGlvbk1hbmFnZXIubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlLFxuICAgIGlzQWN0aXZlOiB0cmFuc2l0aW9uTWFuYWdlci5pc0FjdGl2ZVxuICB9KTtcbn1cblxuLy8gZGVwcmVjYXRlZFxuZnVuY3Rpb24gY3JlYXRlUm91dGluZ0hpc3RvcnkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpIHtcbiAgaGlzdG9yeSA9IF9leHRlbmRzKHt9LCBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBoaXN0b3J5ID0gKDAsIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMi5kZWZhdWx0KShoaXN0b3J5LCAnYHByb3BzLmhpc3RvcnlgIGFuZCBgY29udGV4dC5oaXN0b3J5YCBhcmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBgY29udGV4dC5yb3V0ZXJgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItY29udGV4dGNoYW5nZXMnKTtcbiAgfVxuXG4gIHJldHVybiBoaXN0b3J5O1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUm91dGluZ0NvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRpbmdDb250ZXh0JyxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgUm91dGluZ0NvbnRleHRgIGhhcyBiZWVuIHJlbmFtZWQgdG8gYFJvdXRlckNvbnRleHRgLiBQbGVhc2UgdXNlIGBpbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItcm91dGVyY29udGV4dCcpIDogdm9pZCAwO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIHRoaXMucHJvcHMpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGluZ0NvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJ1bkVudGVySG9va3MgPSBydW5FbnRlckhvb2tzO1xuZXhwb3J0cy5ydW5DaGFuZ2VIb29rcyA9IHJ1bkNoYW5nZUhvb2tzO1xuZXhwb3J0cy5ydW5MZWF2ZUhvb2tzID0gcnVuTGVhdmVIb29rcztcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25Ib29rKGhvb2ssIHJvdXRlLCBhc3luY0FyaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaG9vay5hcHBseShyb3V0ZSwgYXJncyk7XG5cbiAgICBpZiAoaG9vay5sZW5ndGggPCBhc3luY0FyaXR5KSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAvLyBBc3N1bWUgaG9vayBleGVjdXRlcyBzeW5jaHJvbm91c2x5IGFuZFxuICAgICAgLy8gYXV0b21hdGljYWxseSBjYWxsIHRoZSBjYWxsYmFjay5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFbnRlckhvb2tzKHJvdXRlcykge1xuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLm9uRW50ZXIpIGhvb2tzLnB1c2goY3JlYXRlVHJhbnNpdGlvbkhvb2socm91dGUub25FbnRlciwgcm91dGUsIDMpKTtcblxuICAgIHJldHVybiBob29rcztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VIb29rcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5vbkNoYW5nZSkgaG9va3MucHVzaChjcmVhdGVUcmFuc2l0aW9uSG9vayhyb3V0ZS5vbkNoYW5nZSwgcm91dGUsIDQpKTtcbiAgICByZXR1cm4gaG9va3M7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2tzKGxlbmd0aCwgaXRlciwgY2FsbGJhY2spIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWRpcmVjdEluZm8gPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24sIGRlcHJlY2F0ZWRQYXRobmFtZSwgZGVwcmVjYXRlZFF1ZXJ5KSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRQYXRobmFtZSkge1xuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRobmFtZSwgcXVlcnkpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBgcmVwbGFjZShsb2NhdGlvbilgIHdpdGggYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcbiAgICAgIHJlZGlyZWN0SW5mbyA9IHtcbiAgICAgICAgcGF0aG5hbWU6IGRlcHJlY2F0ZWRQYXRobmFtZSxcbiAgICAgICAgcXVlcnk6IGRlcHJlY2F0ZWRRdWVyeSxcbiAgICAgICAgc3RhdGU6IGxvY2F0aW9uXG4gICAgICB9O1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVkaXJlY3RJbmZvID0gbG9jYXRpb247XG4gIH1cblxuICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShsZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgIGl0ZXIoaW5kZXgsIHJlcGxhY2UsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykge1xuICAgICAgICBkb25lKGVycm9yLCByZWRpcmVjdEluZm8pOyAvLyBObyBuZWVkIHRvIGNvbnRpbnVlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25FbnRlciBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyXG4gKiB3aXRoIG9uRW50ZXIobmV4dFN0YXRlLCByZXBsYWNlLCBjYWxsYmFjaykgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RJbmZvKSB3aGVuIGZpbmlzaGVkLiBUaGUgZmlyc3QgaG9va1xuICogdG8gdXNlIHJlcGxhY2Ugc2hvcnQtY2lyY3VpdHMgdGhlIGxvb3AuXG4gKlxuICogSWYgYSBob29rIG5lZWRzIHRvIHJ1biBhc3luY2hyb25vdXNseSwgaXQgbWF5IHVzZSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBIb3dldmVyLCBkb2luZyBzbyB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHBhdXNlLFxuICogd2hpY2ggY291bGQgbGVhZCB0byBhIG5vbi1yZXNwb25zaXZlIFVJIGlmIHRoZSBob29rIGlzIHNsb3cuXG4gKi9cbmZ1bmN0aW9uIHJ1bkVudGVySG9va3Mocm91dGVzLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IGdldEVudGVySG9va3Mocm91dGVzKTtcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xuICAgIGhvb2tzW2luZGV4XShuZXh0U3RhdGUsIHJlcGxhY2UsIG5leHQpO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25DaGFuZ2UgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxuICogd2l0aCBvbkNoYW5nZShwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgY2FsbGJhY2spIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxuICpcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcbiAqIHdoaWNoIGNvdWxkIGxlYWQgdG8gYSBub24tcmVzcG9uc2l2ZSBVSSBpZiB0aGUgaG9vayBpcyBzbG93LlxuICovXG5mdW5jdGlvbiBydW5DaGFuZ2VIb29rcyhyb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IGdldENoYW5nZUhvb2tzKHJvdXRlcyk7XG4gIHJldHVybiBydW5UcmFuc2l0aW9uSG9va3MoaG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2UsIG5leHQpIHtcbiAgICBob29rc1tpbmRleF0oc3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgbmV4dCk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkxlYXZlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHJ1bkxlYXZlSG9va3Mocm91dGVzLCBwcmV2U3RhdGUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChyb3V0ZXNbaV0ub25MZWF2ZSkgcm91dGVzW2ldLm9uTGVhdmUuY2FsbChyb3V0ZXNbaV0sIHByZXZTdGF0ZSk7XG4gIH1cbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaChmdW5jdGlvbiAobWlkZGxld2FyZSwgaW5kZXgpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKG1pZGRsZXdhcmUucmVuZGVyUm91dGVyQ29udGV4dCB8fCBtaWRkbGV3YXJlLnJlbmRlclJvdXRlQ29tcG9uZW50LCAnVGhlIG1pZGRsZXdhcmUgc3BlY2lmaWVkIGF0IGluZGV4ICcgKyBpbmRleCArICcgZG9lcyBub3QgYXBwZWFyIHRvIGJlICcgKyAnYSB2YWxpZCBSZWFjdCBSb3V0ZXIgbWlkZGxld2FyZS4nKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aXRoQ29udGV4dCA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgIHJldHVybiBtaWRkbGV3YXJlLnJlbmRlclJvdXRlckNvbnRleHQ7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgdmFyIHdpdGhDb21wb25lbnQgPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZS5yZW5kZXJSb3V0ZUNvbXBvbmVudDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIHZhciBtYWtlQ3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIG1ha2VDcmVhdGVFbGVtZW50KCkge1xuICAgIHZhciBiYXNlQ3JlYXRlRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IF9yZWFjdC5jcmVhdGVFbGVtZW50IDogYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcykge1xuICAgICAgcmV0dXJuIHdpdGhDb21wb25lbnQucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCByZW5kZXJSb3V0ZUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gcmVuZGVyUm91dGVDb21wb25lbnQocHJldmlvdXMsIHByb3BzKTtcbiAgICAgIH0sIGJhc2VDcmVhdGVFbGVtZW50KENvbXBvbmVudCwgcHJvcHMpKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gd2l0aENvbnRleHQucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHByZXZpb3VzLCByZW5kZXJSb3V0ZXJDb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVuZGVyUm91dGVyQ29udGV4dChwcmV2aW91cywgcmVuZGVyUHJvcHMpO1xuICAgIH0sIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgcmVuZGVyUHJvcHMsIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IG1ha2VDcmVhdGVFbGVtZW50KHJlbmRlclByb3BzLmNyZWF0ZUVsZW1lbnQpXG4gICAgfSkpKTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlQnJvd3Nlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQnJvd3Nlckhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKF9jcmVhdGVCcm93c2VySGlzdG9yeTIuZGVmYXVsdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSkge1xuICBpZiAoIXJvdXRlLnBhdGgpIHJldHVybiBmYWxzZTtcblxuICB2YXIgcGFyYW1OYW1lcyA9ICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpO1xuXG4gIHJldHVybiBwYXJhbU5hbWVzLnNvbWUoZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIHJldHVybiBwcmV2U3RhdGUucGFyYW1zW3BhcmFtTmFtZV0gIT09IG5leHRTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgeyBsZWF2ZVJvdXRlcywgY2hhbmdlUm91dGVzLCBlbnRlclJvdXRlcyB9IGRldGVybWluZWQgYnlcbiAqIHRoZSBjaGFuZ2UgZnJvbSBwcmV2U3RhdGUgdG8gbmV4dFN0YXRlLiBXZSBsZWF2ZSByb3V0ZXMgaWYgZWl0aGVyXG4gKiAxKSB0aGV5IGFyZSBub3QgaW4gdGhlIG5leHQgc3RhdGUgb3IgMikgdGhleSBhcmUgaW4gdGhlIG5leHQgc3RhdGVcbiAqIGJ1dCB0aGVpciBwYXJhbXMgaGF2ZSBjaGFuZ2VkIChpLmUuIC91c2Vycy8xMjMgPT4gL3VzZXJzLzQ1NikuXG4gKlxuICogbGVhdmVSb3V0ZXMgYXJlIG9yZGVyZWQgc3RhcnRpbmcgYXQgdGhlIGxlYWYgcm91dGUgb2YgdGhlIHRyZWVcbiAqIHdlJ3JlIGxlYXZpbmcgdXAgdG8gdGhlIGNvbW1vbiBwYXJlbnQgcm91dGUuIGVudGVyUm91dGVzIGFyZSBvcmRlcmVkXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHRyZWUgd2UncmUgZW50ZXJpbmcgZG93biB0byB0aGUgbGVhZiByb3V0ZS5cbiAqXG4gKiBjaGFuZ2VSb3V0ZXMgYXJlIGFueSByb3V0ZXMgdGhhdCBkaWRuJ3QgbGVhdmUgb3IgZW50ZXIgZHVyaW5nXG4gKiB0aGUgdHJhbnNpdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUNoYW5nZWRSb3V0ZXMocHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUgJiYgcHJldlN0YXRlLnJvdXRlcztcbiAgdmFyIG5leHRSb3V0ZXMgPSBuZXh0U3RhdGUucm91dGVzO1xuXG4gIHZhciBsZWF2ZVJvdXRlcyA9IHZvaWQgMCxcbiAgICAgIGNoYW5nZVJvdXRlcyA9IHZvaWQgMCxcbiAgICAgIGVudGVyUm91dGVzID0gdm9pZCAwO1xuICBpZiAocHJldlJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50SXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICBsZWF2ZVJvdXRlcyA9IHByZXZSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAocGFyZW50SXNMZWF2aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlzTGVhdmluZyA9IG5leHRSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xIHx8IHJvdXRlUGFyYW1zQ2hhbmdlZChyb3V0ZSwgcHJldlN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgIGlmIChpc0xlYXZpbmcpIHBhcmVudElzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGlzTGVhdmluZztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIG9uTGVhdmUgaG9va3Mgc3RhcnQgYXQgdGhlIGxlYWYgcm91dGUuXG4gICAgICBsZWF2ZVJvdXRlcy5yZXZlcnNlKCk7XG5cbiAgICAgIGVudGVyUm91dGVzID0gW107XG4gICAgICBjaGFuZ2VSb3V0ZXMgPSBbXTtcblxuICAgICAgbmV4dFJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICB2YXIgaXNOZXcgPSBwcmV2Um91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICAgICAgdmFyIHBhcmFtc0NoYW5nZWQgPSBsZWF2ZVJvdXRlcy5pbmRleE9mKHJvdXRlKSAhPT0gLTE7XG5cbiAgICAgICAgaWYgKGlzTmV3IHx8IHBhcmFtc0NoYW5nZWQpIGVudGVyUm91dGVzLnB1c2gocm91dGUpO2Vsc2UgY2hhbmdlUm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBsZWF2ZVJvdXRlcyA9IFtdO1xuICAgIGNoYW5nZVJvdXRlcyA9IFtdO1xuICAgIGVudGVyUm91dGVzID0gbmV4dFJvdXRlcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVhdmVSb3V0ZXM6IGxlYXZlUm91dGVzLFxuICAgIGNoYW5nZVJvdXRlczogY2hhbmdlUm91dGVzLFxuICAgIGVudGVyUm91dGVzOiBlbnRlclJvdXRlc1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb21wdXRlQ2hhbmdlZFJvdXRlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX3VzZUJhc2VuYW1lID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUnKTtcblxudmFyIF91c2VCYXNlbmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZSk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMpIHtcbiAgLy8gc2lnbmF0dXJlcyBhbmQgdHlwZSBjaGVja2luZyBkaWZmZXIgYmV0d2VlbiBgdXNlUm91dGVzYCBhbmRcbiAgLy8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgLCBoYXZlIHRvIGNyZWF0ZSBgbWVtb3J5SGlzdG9yeWAgZmlyc3QgYmVjYXVzZVxuICAvLyBgdXNlUXVlcmllc2AgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSBzaWduYXR1cmVcbiAgdmFyIG1lbW9yeUhpc3RvcnkgPSAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB2YXIgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIG1lbW9yeUhpc3Rvcnk7XG4gIH07XG4gIHZhciBoaXN0b3J5ID0gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KSgoMCwgX3VzZUJhc2VuYW1lMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSkob3B0aW9ucyk7XG4gIGhpc3RvcnkuX192Ml9jb21wYXRpYmxlX18gPSB0cnVlO1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNyZWF0ZUhpc3RvcnkpIHtcbiAgdmFyIGhpc3RvcnkgPSB2b2lkIDA7XG4gIGlmIChjYW5Vc2VET00pIGhpc3RvcnkgPSAoMCwgX3VzZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKCk7XG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5ID0gcmVxdWlyZSgnLi91c2VSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXJIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyID0gcmVxdWlyZSgnLi9jb21wdXRlQ2hhbmdlZFJvdXRlcycpO1xuXG52YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXB1dGVDaGFuZ2VkUm91dGVzMik7XG5cbnZhciBfVHJhbnNpdGlvblV0aWxzID0gcmVxdWlyZSgnLi9UcmFuc2l0aW9uVXRpbHMnKTtcblxudmFyIF9pc0FjdGl2ZTIgPSByZXF1aXJlKCcuL2lzQWN0aXZlJyk7XG5cbnZhciBfaXNBY3RpdmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBY3RpdmUyKTtcblxudmFyIF9nZXRDb21wb25lbnRzID0gcmVxdWlyZSgnLi9nZXRDb21wb25lbnRzJyk7XG5cbnZhciBfZ2V0Q29tcG9uZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRDb21wb25lbnRzKTtcblxudmFyIF9tYXRjaFJvdXRlcyA9IHJlcXVpcmUoJy4vbWF0Y2hSb3V0ZXMnKTtcblxudmFyIF9tYXRjaFJvdXRlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaFJvdXRlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGhhc0FueVByb3BlcnRpZXMob2JqZWN0KSB7XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHApKSByZXR1cm4gdHJ1ZTtcbiAgfXJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoaGlzdG9yeSwgcm91dGVzKSB7XG4gIHZhciBzdGF0ZSA9IHt9O1xuXG4gIC8vIFNpZ25hdHVyZSBzaG91bGQgYmUgKGxvY2F0aW9uLCBpbmRleE9ubHkpLCBidXQgbmVlZHMgdG8gc3VwcG9ydCAocGF0aCxcbiAgLy8gcXVlcnksIGluZGV4T25seSlcbiAgZnVuY3Rpb24gaXNBY3RpdmUobG9jYXRpb24pIHtcbiAgICB2YXIgaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZGVwcmVjYXRlZEluZGV4T25seSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMl07XG5cbiAgICB2YXIgaW5kZXhPbmx5ID0gdm9pZCAwO1xuICAgIGlmIChpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSAmJiBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSAhPT0gdHJ1ZSB8fCBkZXByZWNhdGVkSW5kZXhPbmx5ICE9PSBudWxsKSB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2Bpc0FjdGl2ZShwYXRobmFtZSwgcXVlcnksIGluZGV4T25seSkgaXMgZGVwcmVjYXRlZDsgdXNlIGBpc0FjdGl2ZShsb2NhdGlvbiwgaW5kZXhPbmx5KWAgd2l0aCBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWlzQWN0aXZlZGVwcmVjYXRlZCcpIDogdm9pZCAwO1xuICAgICAgbG9jYXRpb24gPSB7IHBhdGhuYW1lOiBsb2NhdGlvbiwgcXVlcnk6IGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5IH07XG4gICAgICBpbmRleE9ubHkgPSBkZXByZWNhdGVkSW5kZXhPbmx5IHx8IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgaW5kZXhPbmx5ID0gaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfaXNBY3RpdmUzLmRlZmF1bHQpKGxvY2F0aW9uLCBpbmRleE9ubHksIHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5yb3V0ZXMsIHN0YXRlLnBhcmFtcyk7XG4gIH1cblxuICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBtYXRjaChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAocGFydGlhbE5leHRTdGF0ZSAmJiBwYXJ0aWFsTmV4dFN0YXRlLmxvY2F0aW9uID09PSBsb2NhdGlvbikge1xuICAgICAgLy8gQ29udGludWUgZnJvbSB3aGVyZSB3ZSBsZWZ0IG9mZi5cbiAgICAgIGZpbmlzaE1hdGNoKHBhcnRpYWxOZXh0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKDAsIF9tYXRjaFJvdXRlczIuZGVmYXVsdCkocm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgICAgIGZpbmlzaE1hdGNoKF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgbG9jYXRpb246IGxvY2F0aW9uIH0pLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoTWF0Y2gobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAgIHZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMgPSAoMCwgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMy5kZWZhdWx0KShzdGF0ZSwgbmV4dFN0YXRlKTtcblxuICAgIHZhciBsZWF2ZVJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5sZWF2ZVJvdXRlcztcbiAgICB2YXIgY2hhbmdlUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmNoYW5nZVJvdXRlcztcbiAgICB2YXIgZW50ZXJSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMuZW50ZXJSb3V0ZXM7XG5cblxuICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkxlYXZlSG9va3MpKGxlYXZlUm91dGVzLCBzdGF0ZSk7XG5cbiAgICAvLyBUZWFyIGRvd24gY29uZmlybWF0aW9uIGhvb2tzIGZvciBsZWZ0IHJvdXRlc1xuICAgIGxlYXZlUm91dGVzLmZpbHRlcihmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJldHVybiBlbnRlclJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTE7XG4gICAgfSkuZm9yRWFjaChyZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKTtcblxuICAgIC8vIGNoYW5nZSBhbmQgZW50ZXIgaG9va3MgYXJlIHJ1biBpbiBzZXJpZXNcbiAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5DaGFuZ2VIb29rcykoY2hhbmdlUm91dGVzLCBzdGF0ZSwgbmV4dFN0YXRlLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykgcmV0dXJuIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKTtcblxuICAgICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuRW50ZXJIb29rcykoZW50ZXJSb3V0ZXMsIG5leHRTdGF0ZSwgZmluaXNoRW50ZXJIb29rcyk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBmaW5pc2hFbnRlckhvb2tzKGVycm9yLCByZWRpcmVjdEluZm8pIHtcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHJldHVybiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbyk7XG5cbiAgICAgIC8vIFRPRE86IEZldGNoIGNvbXBvbmVudHMgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICAgICgwLCBfZ2V0Q29tcG9uZW50czIuZGVmYXVsdCkobmV4dFN0YXRlLCBmdW5jdGlvbiAoZXJyb3IsIGNvbXBvbmVudHMpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRPRE86IE1ha2UgbWF0Y2ggYSBwdXJlIGZ1bmN0aW9uIGFuZCBoYXZlIHNvbWUgb3RoZXIgQVBJXG4gICAgICAgICAgLy8gZm9yIFwibWF0Y2ggYW5kIHVwZGF0ZSBzdGF0ZVwiLlxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwsIHN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBjb21wb25lbnRzOiBjb21wb25lbnRzIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pIHtcbiAgICAgIGlmIChlcnJvcikgY2FsbGJhY2soZXJyb3IpO2Vsc2UgY2FsbGJhY2sobnVsbCwgcmVkaXJlY3RJbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUm91dGVHdWlkID0gMTtcblxuICBmdW5jdGlvbiBnZXRSb3V0ZUlEKHJvdXRlKSB7XG4gICAgdmFyIGNyZWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICByZXR1cm4gcm91dGUuX19pZF9fIHx8IGNyZWF0ZSAmJiAocm91dGUuX19pZF9fID0gUm91dGVHdWlkKyspO1xuICB9XG5cbiAgdmFyIFJvdXRlSG9va3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGdldFJvdXRlSG9va3NGb3JSb3V0ZXMocm91dGVzKSB7XG4gICAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgICAgaG9va3MucHVzaC5hcHBseShob29rcywgUm91dGVIb29rc1tnZXRSb3V0ZUlEKHJvdXRlKV0pO1xuICAgICAgcmV0dXJuIGhvb2tzO1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25Ib29rKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICgwLCBfbWF0Y2hSb3V0ZXMyLmRlZmF1bHQpKHJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbmV4dFN0YXRlKSB7XG4gICAgICBpZiAobmV4dFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogV2UgZGlkbid0IGFjdHVhbGx5IG1hdGNoIGFueXRoaW5nLCBidXQgaGFuZ1xuICAgICAgICAvLyBvbnRvIGVycm9yL25leHRTdGF0ZSBzbyB3ZSBkb24ndCBoYXZlIHRvIG1hdGNoUm91dGVzXG4gICAgICAgIC8vIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FjaGUgc29tZSBzdGF0ZSBoZXJlIHNvIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgIC8vIG1hdGNoUm91dGVzKCkgYWdhaW4gaW4gdGhlIGxpc3RlbiBjYWxsYmFjay5cbiAgICAgIHBhcnRpYWxOZXh0U3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcblxuICAgICAgdmFyIGhvb2tzID0gZ2V0Um91dGVIb29rc0ZvclJvdXRlcygoMCwgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMy5kZWZhdWx0KShzdGF0ZSwgcGFydGlhbE5leHRTdGF0ZSkubGVhdmVSb3V0ZXMpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvb2tzLmxlbmd0aDsgcmVzdWx0ID09IG51bGwgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGxvY2F0aW9uIGFyZyBoZXJlIGluZGljYXRlcyB0b1xuICAgICAgICAvLyB0aGUgdXNlciB0aGF0IHRoaXMgaXMgYSB0cmFuc2l0aW9uIGhvb2suXG4gICAgICAgIHJlc3VsdCA9IGhvb2tzW2ldKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB1bnRlc3RhYmxlIHdpdGggS2FybWEgKi9cbiAgZnVuY3Rpb24gYmVmb3JlVW5sb2FkSG9vaygpIHtcbiAgICAvLyBTeW5jaHJvbm91c2x5IGNoZWNrIHRvIHNlZSBpZiBhbnkgcm91dGUgaG9va3Mgd2FudFxuICAgIC8vIHRvIHByZXZlbnQgdGhlIGN1cnJlbnQgd2luZG93L3RhYiBmcm9tIGNsb3NpbmcuXG4gICAgaWYgKHN0YXRlLnJvdXRlcykge1xuICAgICAgdmFyIGhvb2tzID0gZ2V0Um91dGVIb29rc0ZvclJvdXRlcyhzdGF0ZS5yb3V0ZXMpO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJyAmJiBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8gUGFzc2luZyBubyBhcmdzIGluZGljYXRlcyB0byB0aGUgdXNlciB0aGF0IHRoaXMgaXMgYVxuICAgICAgICAvLyBiZWZvcmV1bmxvYWQgaG9vay4gV2UgZG9uJ3Qga25vdyB0aGUgbmV4dCBsb2NhdGlvbi5cbiAgICAgICAgbWVzc2FnZSA9IGhvb2tzW2ldKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmxpc3RlbkJlZm9yZSA9IHZvaWQgMCxcbiAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUocm91dGUpIHtcbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUsIGZhbHNlKTtcbiAgICBpZiAoIXJvdXRlSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgIGlmICghaGFzQW55UHJvcGVydGllcyhSb3V0ZUhvb2tzKSkge1xuICAgICAgLy8gdGVhcmRvd24gdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xuICAgICAgaWYgKHVubGlzdGVuQmVmb3JlKSB7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlKCk7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHVubGlzdGVuQmVmb3JlVW5sb2FkKSB7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkKCk7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBob29rIGZ1bmN0aW9uIHRvIHJ1biBiZWZvcmUgbGVhdmluZyB0aGUgZ2l2ZW4gcm91dGUuXG4gICAqXG4gICAqIER1cmluZyBhIG5vcm1hbCB0cmFuc2l0aW9uLCB0aGUgaG9vayBmdW5jdGlvbiByZWNlaXZlcyB0aGUgbmV4dCBsb2NhdGlvblxuICAgKiBhcyBpdHMgb25seSBhcmd1bWVudCBhbmQgY2FuIHJldHVybiBlaXRoZXIgYSBwcm9tcHQgbWVzc2FnZSAoc3RyaW5nKSB0byBzaG93IHRoZSB1c2VyLFxuICAgKiB0byBtYWtlIHN1cmUgdGhleSB3YW50IHRvIGxlYXZlIHRoZSBwYWdlOyBvciBgZmFsc2VgLCB0byBwcmV2ZW50IHRoZSB0cmFuc2l0aW9uLlxuICAgKiBBbnkgb3RoZXIgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAqXG4gICAqIER1cmluZyB0aGUgYmVmb3JldW5sb2FkIGV2ZW50IChpbiBicm93c2VycykgdGhlIGhvb2sgcmVjZWl2ZXMgbm8gYXJndW1lbnRzLlxuICAgKiBJbiB0aGlzIGNhc2UgaXQgbXVzdCByZXR1cm4gYSBwcm9tcHQgbWVzc2FnZSB0byBwcmV2ZW50IHRoZSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byB1bmJpbmQgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCBob29rKSB7XG4gICAgLy8gVE9ETzogV2FybiBpZiB0aGV5IHJlZ2lzdGVyIGZvciBhIHJvdXRlIHRoYXQgaXNuJ3QgY3VycmVudGx5XG4gICAgLy8gYWN0aXZlLiBUaGV5J3JlIHByb2JhYmx5IGRvaW5nIHNvbWV0aGluZyB3cm9uZywgbGlrZSByZS1jcmVhdGluZ1xuICAgIC8vIHJvdXRlIG9iamVjdHMgb24gZXZlcnkgbG9jYXRpb24gY2hhbmdlLlxuICAgIHZhciByb3V0ZUlEID0gZ2V0Um91dGVJRChyb3V0ZSk7XG4gICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgIGlmICghaG9va3MpIHtcbiAgICAgIHZhciB0aGVyZVdlcmVOb1JvdXRlSG9va3MgPSAhaGFzQW55UHJvcGVydGllcyhSb3V0ZUhvb2tzKTtcblxuICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IFtob29rXTtcblxuICAgICAgaWYgKHRoZXJlV2VyZU5vUm91dGVIb29rcykge1xuICAgICAgICAvLyBzZXR1cCB0cmFuc2l0aW9uICYgYmVmb3JldW5sb2FkIGhvb2tzXG4gICAgICAgIHVubGlzdGVuQmVmb3JlID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUodHJhbnNpdGlvbkhvb2spO1xuXG4gICAgICAgIGlmIChoaXN0b3J5Lmxpc3RlbkJlZm9yZVVubG9hZCkgdW5saXN0ZW5CZWZvcmVVbmxvYWQgPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZVVubG9hZChiZWZvcmVVbmxvYWRIb29rKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhvb2tzLmluZGV4T2YoaG9vaykgPT09IC0xKSB7XG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYWRkaW5nIG11bHRpcGxlIGxlYXZlIGhvb2tzIGZvciB0aGUgc2FtZSByb3V0ZSBpcyBkZXByZWNhdGVkOyBtYW5hZ2UgbXVsdGlwbGUgY29uZmlybWF0aW9ucyBpbiB5b3VyIG93biBjb2RlIGluc3RlYWQnKSA6IHZvaWQgMDtcblxuICAgICAgICBob29rcy5wdXNoKGhvb2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaG9va3MgPSBSb3V0ZUhvb2tzW3JvdXRlSURdO1xuXG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgdmFyIG5ld0hvb2tzID0gaG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChuZXdIb29rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSb3V0ZUhvb2tzW3JvdXRlSURdID0gbmV3SG9va3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIEFQSSBmb3Igc3RhdGVmdWwgZW52aXJvbm1lbnRzLiBBcyB0aGUgbG9jYXRpb25cbiAgICogY2hhbmdlcywgd2UgdXBkYXRlIHN0YXRlIGFuZCBjYWxsIHRoZSBsaXN0ZW5lci4gV2UgY2FuIGFsc29cbiAgICogZ3JhY2VmdWxseSBoYW5kbGUgZXJyb3JzIGFuZCByZWRpcmVjdHMuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAvLyBUT0RPOiBPbmx5IHVzZSBhIHNpbmdsZSBoaXN0b3J5IGxpc3RlbmVyLiBPdGhlcndpc2Ugd2UnbGxcbiAgICAvLyBlbmQgdXAgd2l0aCBtdWx0aXBsZSBjb25jdXJyZW50IGNhbGxzIHRvIG1hdGNoLlxuICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIGlmIChzdGF0ZS5sb2NhdGlvbiA9PT0gbG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIobnVsbCwgc3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2gobG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICBoaXN0b3J5LnJlcGxhY2UocmVkaXJlY3RMb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKG51bGwsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnTG9jYXRpb24gXCIlc1wiIGRpZCBub3QgbWF0Y2ggYW55IHJvdXRlcycsIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCkgOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGU6IGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xufVxuXG4vL2V4cG9ydCBkZWZhdWx0IHVzZVJvdXRlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNhblVzZU1lbWJyYW5lID0gdW5kZWZpbmVkO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2FuVXNlTWVtYnJhbmUgPSBleHBvcnRzLmNhblVzZU1lbWJyYW5lID0gZmFsc2U7XG5cbi8vIE5vLW9wIGJ5IGRlZmF1bHQuXG52YXIgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICB0cnkge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLngpIHtcbiAgICAgIGV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSBjYW5Vc2VNZW1icmFuZSA9IHRydWU7XG4gICAgfVxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cblxuICBpZiAoY2FuVXNlTWVtYnJhbmUpIHtcbiAgICBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyhvYmplY3QsIG1lc3NhZ2UpIHtcbiAgICAgIC8vIFdyYXAgdGhlIGRlcHJlY2F0ZWQgb2JqZWN0IGluIGEgbWVtYnJhbmUgdG8gd2FybiBvbiBwcm9wZXJ0eSBhY2Nlc3MuXG4gICAgICB2YXIgbWVtYnJhbmUgPSB7fTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgcmV0dXJuICdjb250aW51ZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9iamVjdFtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIENhbid0IHVzZSBmYXQgYXJyb3cgaGVyZSBiZWNhdXNlIG9mIHVzZSBvZiBhcmd1bWVudHMgYmVsb3cuXG4gICAgICAgICAgbWVtYnJhbmVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W3Byb3BdLmFwcGx5KG9iamVjdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBhcmUgbm9uLWVudW1lcmFibGUgdG8gcHJldmVudCBSZWFjdCBkZXYgdG9vbHMgZnJvbVxuICAgICAgICAvLyBzZWVpbmcgdGhlbSBhbmQgY2F1c2luZyBzcHVyaW91cyB3YXJuaW5ncyB3aGVuIGFjY2Vzc2luZyB0aGVtLiBJblxuICAgICAgICAvLyBwcmluY2lwbGUgdGhpcyBjb3VsZCBiZSBkb25lIHdpdGggYSBwcm94eSwgYnV0IHN1cHBvcnQgZm9yIHRoZVxuICAgICAgICAvLyBvd25LZXlzIHRyYXAgb24gcHJveGllcyBpcyBub3QgdW5pdmVyc2FsLCBldmVuIGFtb25nIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHN1cHBvcnQgcHJveGllcy5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lbWJyYW5lLCBwcm9wLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9iamVjdCkge1xuICAgICAgICB2YXIgX3JldCA9IF9sb29wKHByb3ApO1xuXG4gICAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lbWJyYW5lO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbWFrZVN0YXRlV2l0aExvY2F0aW9uJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ha2VTdGF0ZVdpdGhMb2NhdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpIHtcbiAgICBjYWxsYmFjayhudWxsLCByb3V0ZS5jb21wb25lbnQgfHwgcm91dGUuY29tcG9uZW50cyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldENvbXBvbmVudCA9IHJvdXRlLmdldENvbXBvbmVudCB8fCByb3V0ZS5nZXRDb21wb25lbnRzO1xuICBpZiAoIWdldENvbXBvbmVudCkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxvY2F0aW9uID0gbmV4dFN0YXRlLmxvY2F0aW9uO1xuXG4gIHZhciBuZXh0U3RhdGVXaXRoTG9jYXRpb24gPSAoMCwgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIuZGVmYXVsdCkobmV4dFN0YXRlLCBsb2NhdGlvbik7XG5cbiAgZ2V0Q29tcG9uZW50LmNhbGwocm91dGUsIG5leHRTdGF0ZVdpdGhMb2NhdGlvbiwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGZldGNoZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciB0aGUgZ2l2ZW4gcm91dGVyXG4gKiBzdGF0ZSBhbmQgY2FsbHMgY2FsbGJhY2soZXJyb3IsIGNvbXBvbmVudHMpIHdoZW4gZmluaXNoZWQuXG4gKlxuICogTm90ZTogVGhpcyBvcGVyYXRpb24gbWF5IGZpbmlzaCBzeW5jaHJvbm91c2x5IGlmIG5vIHJvdXRlcyBoYXZlIGFuXG4gKiBhc3luY2hyb25vdXMgZ2V0Q29tcG9uZW50cyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudHMobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAoMCwgX0FzeW5jVXRpbHMubWFwQXN5bmMpKG5leHRTdGF0ZS5yb3V0ZXMsIGZ1bmN0aW9uIChyb3V0ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZ2V0Q29tcG9uZW50c0ZvclJvdXRlKG5leHRTdGF0ZSwgcm91dGUsIGNhbGxiYWNrKTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRDb21wb25lbnRzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbi8qKlxuICogRXh0cmFjdHMgYW4gb2JqZWN0IG9mIHBhcmFtcyB0aGUgZ2l2ZW4gcm91dGUgY2FyZXMgYWJvdXQgZnJvbVxuICogdGhlIGdpdmVuIHBhcmFtcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdXRlUGFyYW1zKHJvdXRlLCBwYXJhbXMpIHtcbiAgdmFyIHJvdXRlUGFyYW1zID0ge307XG5cbiAgaWYgKCFyb3V0ZS5wYXRoKSByZXR1cm4gcm91dGVQYXJhbXM7XG5cbiAgKDAsIF9QYXR0ZXJuVXRpbHMuZ2V0UGFyYW1OYW1lcykocm91dGUucGF0aCkuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwKSkge1xuICAgICAgcm91dGVQYXJhbXNbcF0gPSBwYXJhbXNbcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVQYXJhbXM7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFJvdXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUhhc2hIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGV4cG9ydHMuaGFzaEhpc3RvcnkgPSBleHBvcnRzLmJyb3dzZXJIaXN0b3J5ID0gZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLmZvcm1hdFBhdHRlcm4gPSBleHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBleHBvcnRzLm1hdGNoID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMuUHJvcFR5cGVzID0gZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IGV4cG9ydHMuUm91dGVyQ29udGV4dCA9IGV4cG9ydHMuY3JlYXRlUm91dGVzID0gZXhwb3J0cy51c2VSb3V0ZXMgPSBleHBvcnRzLlJvdXRlQ29udGV4dCA9IGV4cG9ydHMuTGlmZWN5Y2xlID0gZXhwb3J0cy5IaXN0b3J5ID0gZXhwb3J0cy5Sb3V0ZSA9IGV4cG9ydHMuUmVkaXJlY3QgPSBleHBvcnRzLkluZGV4Um91dGUgPSBleHBvcnRzLkluZGV4UmVkaXJlY3QgPSBleHBvcnRzLndpdGhSb3V0ZXIgPSBleHBvcnRzLkluZGV4TGluayA9IGV4cG9ydHMuTGluayA9IGV4cG9ydHMuUm91dGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXM7XG4gIH1cbn0pO1xuXG52YXIgX1Byb3BUeXBlczIgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2xvY2F0aW9uU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5sb2NhdGlvblNoYXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5yb3V0ZXJTaGFwZTtcbiAgfVxufSk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRQYXR0ZXJuJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuO1xuICB9XG59KTtcblxudmFyIF9Sb3V0ZXIyID0gcmVxdWlyZSgnLi9Sb3V0ZXInKTtcblxudmFyIF9Sb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyMik7XG5cbnZhciBfTGluazIgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmsyKTtcblxudmFyIF9JbmRleExpbmsyID0gcmVxdWlyZSgnLi9JbmRleExpbmsnKTtcblxudmFyIF9JbmRleExpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhMaW5rMik7XG5cbnZhciBfd2l0aFJvdXRlcjIgPSByZXF1aXJlKCcuL3dpdGhSb3V0ZXInKTtcblxudmFyIF93aXRoUm91dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dpdGhSb3V0ZXIyKTtcblxudmFyIF9JbmRleFJlZGlyZWN0MiA9IHJlcXVpcmUoJy4vSW5kZXhSZWRpcmVjdCcpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhSZWRpcmVjdDIpO1xuXG52YXIgX0luZGV4Um91dGUyID0gcmVxdWlyZSgnLi9JbmRleFJvdXRlJyk7XG5cbnZhciBfSW5kZXhSb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJvdXRlMik7XG5cbnZhciBfUmVkaXJlY3QyID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0Mik7XG5cbnZhciBfUm91dGUyID0gcmVxdWlyZSgnLi9Sb3V0ZScpO1xuXG52YXIgX1JvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlMik7XG5cbnZhciBfSGlzdG9yeTIgPSByZXF1aXJlKCcuL0hpc3RvcnknKTtcblxudmFyIF9IaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hpc3RvcnkyKTtcblxudmFyIF9MaWZlY3ljbGUyID0gcmVxdWlyZSgnLi9MaWZlY3ljbGUnKTtcblxudmFyIF9MaWZlY3ljbGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGlmZWN5Y2xlMik7XG5cbnZhciBfUm91dGVDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlQ29udGV4dDIpO1xuXG52YXIgX3VzZVJvdXRlczIgPSByZXF1aXJlKCcuL3VzZVJvdXRlcycpO1xuXG52YXIgX3VzZVJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXMyKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dDIpO1xuXG52YXIgX1JvdXRpbmdDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGluZ0NvbnRleHQnKTtcblxudmFyIF9Sb3V0aW5nQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0aW5nQ29udGV4dDIpO1xuXG52YXIgX1Byb3BUeXBlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm9wVHlwZXMyKTtcblxudmFyIF9tYXRjaDIgPSByZXF1aXJlKCcuL21hdGNoJyk7XG5cbnZhciBfbWF0Y2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2gyKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeTIpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTIgPSByZXF1aXJlKCcuL2FwcGx5Um91dGVyTWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseVJvdXRlck1pZGRsZXdhcmUyKTtcblxudmFyIF9icm93c2VySGlzdG9yeTIgPSByZXF1aXJlKCcuL2Jyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfYnJvd3Nlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJvd3Nlckhpc3RvcnkyKTtcblxudmFyIF9oYXNoSGlzdG9yeTIgPSByZXF1aXJlKCcuL2hhc2hIaXN0b3J5Jyk7XG5cbnZhciBfaGFzaEhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzaEhpc3RvcnkyKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLlJvdXRlciA9IF9Sb3V0ZXIzLmRlZmF1bHQ7IC8qIGNvbXBvbmVudHMgKi9cblxuZXhwb3J0cy5MaW5rID0gX0xpbmszLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4TGluayA9IF9JbmRleExpbmszLmRlZmF1bHQ7XG5leHBvcnRzLndpdGhSb3V0ZXIgPSBfd2l0aFJvdXRlcjMuZGVmYXVsdDtcblxuLyogY29tcG9uZW50cyAoY29uZmlndXJhdGlvbikgKi9cblxuZXhwb3J0cy5JbmRleFJlZGlyZWN0ID0gX0luZGV4UmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4Um91dGUgPSBfSW5kZXhSb3V0ZTMuZGVmYXVsdDtcbmV4cG9ydHMuUmVkaXJlY3QgPSBfUmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlID0gX1JvdXRlMy5kZWZhdWx0O1xuXG4vKiBtaXhpbnMgKi9cblxuZXhwb3J0cy5IaXN0b3J5ID0gX0hpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLkxpZmVjeWNsZSA9IF9MaWZlY3ljbGUzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlQ29udGV4dCA9IF9Sb3V0ZUNvbnRleHQzLmRlZmF1bHQ7XG5cbi8qIHV0aWxzICovXG5cbmV4cG9ydHMudXNlUm91dGVzID0gX3VzZVJvdXRlczMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGVyQ29udGV4dCA9IF9Sb3V0ZXJDb250ZXh0My5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IF9Sb3V0aW5nQ29udGV4dDMuZGVmYXVsdDtcbmV4cG9ydHMuUHJvcFR5cGVzID0gX1Byb3BUeXBlczMuZGVmYXVsdDtcbmV4cG9ydHMubWF0Y2ggPSBfbWF0Y2gzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBfdXNlUm91dGVySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gX2FwcGx5Um91dGVyTWlkZGxld2FyZTMuZGVmYXVsdDtcblxuLyogaGlzdG9yaWVzICovXG5cbmV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBfYnJvd3Nlckhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmhhc2hIaXN0b3J5ID0gX2hhc2hIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzLmRlZmF1bHQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNBY3RpdmU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgcCBpbiBhKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYltwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGFbcF0sIGJbcF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcGF0aG5hbWUgbWF0Y2hlcyB0aGUgc3VwcGxpZWQgb25lLCBuZXQgb2ZcbiAqIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoIG5vcm1hbGl6YXRpb24uIFRoaXMgaXMgc3VmZmljaWVudCBmb3IgYW5cbiAqIGluZGV4T25seSByb3V0ZSBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50UGF0aG5hbWUpIHtcbiAgLy8gTm9ybWFsaXplIGxlYWRpbmcgc2xhc2ggZm9yIGNvbnNpc3RlbmN5LiBMZWFkaW5nIHNsYXNoIG9uIHBhdGhuYW1lIGhhc1xuICAvLyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZCBpbiBpc0FjdGl2ZS4gU2VlIGNhdmVhdCB0aGVyZS5cbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSA9ICcvJyArIGN1cnJlbnRQYXRobmFtZTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgZW5kIG9mIGJvdGggcGF0aCBuYW1lcyB0b28uIE1heWJlIGAvZm9vL2Agc2hvdWxkbid0IHNob3dcbiAgLy8gYC9mb29gIGFzIGFjdGl2ZSwgYnV0IGluIHRoaXMgY2FzZSwgd2Ugd291bGQgYWxyZWFkeSBoYXZlIGZhaWxlZCB0aGVcbiAgLy8gbWF0Y2guXG4gIGlmIChwYXRobmFtZS5jaGFyQXQocGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHBhdGhuYW1lICs9ICcvJztcbiAgfVxuICBpZiAoY3VycmVudFBhdGhuYW1lLmNoYXJBdChjdXJyZW50UGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gY3VycmVudFBhdGhuYW1lID09PSBwYXRobmFtZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGhuYW1lIG1hdGNoZXMgdGhlIGFjdGl2ZSByb3V0ZXMgYW5kIHBhcmFtcy5cbiAqL1xuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWUsXG4gICAgICBwYXJhbU5hbWVzID0gW10sXG4gICAgICBwYXJhbVZhbHVlcyA9IFtdO1xuXG4gIC8vIGZvci4uLm9mIHdvdWxkIHdvcmsgaGVyZSBidXQgaXQncyBwcm9iYWJseSBzbG93ZXIgcG9zdC10cmFuc3BpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICAgIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBleGFjdCBtYXRjaCBvbiB0aGUgcm91dGUuIEp1c3QgY2hlY2sgdGhhdCBhbGwgdGhlIHBhcmFtc1xuICAgICAgICAvLyBtYXRjaC5cbiAgICAgICAgLy8gRklYTUU6IFRoaXMgZG9lc24ndCB3b3JrIG9uIHJlcGVhdGVkIHBhcmFtcy5cbiAgICAgICAgcmV0dXJuIHBhcmFtTmFtZXMuZXZlcnkoZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcmFtVmFsdWVzW2luZGV4XSkgPT09IFN0cmluZyhwYXJhbXNbcGFyYW1OYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYWxsIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgZ2l2ZW4gcXVlcnkgYXJlXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBhY3RpdmVRdWVyeSkge1xuICBpZiAoYWN0aXZlUXVlcnkgPT0gbnVsbCkgcmV0dXJuIHF1ZXJ5ID09IG51bGw7XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBkZWVwRXF1YWwocXVlcnksIGFjdGl2ZVF1ZXJ5KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSA8TGluaz4gdG8gdGhlIGdpdmVuIHBhdGhuYW1lL3F1ZXJ5IGNvbWJpbmF0aW9uIGlzXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBpc0FjdGl2ZShfcmVmLCBpbmRleE9ubHksIGN1cnJlbnRMb2NhdGlvbiwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHBhdGhuYW1lID0gX3JlZi5wYXRobmFtZTtcbiAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIGEgYml0IHVnbHkuIEl0IGtlZXBzIGFyb3VuZCBzdXBwb3J0IGZvciB0cmVhdGluZyBwYXRobmFtZXNcbiAgLy8gd2l0aG91dCBwcmVjZWRpbmcgc2xhc2hlcyBhcyBhYnNvbHV0ZSBwYXRocywgYnV0IHBvc3NpYmx5IGFsc28gd29ya3NcbiAgLy8gYXJvdW5kIHRoZSBzYW1lIHF1aXJrcyB3aXRoIGJhc2VuYW1lcyBhcyBpbiBtYXRjaFJvdXRlcy5cbiAgaWYgKHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfVxuXG4gIGlmICghcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgLy8gVGhlIHBhdGggY2hlY2sgaXMgbmVjZXNzYXJ5IGFuZCBzdWZmaWNpZW50IGZvciBpbmRleE9ubHksIGJ1dCBvdGhlcndpc2VcbiAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIHRoZSByb3V0ZXMuXG4gICAgaWYgKGluZGV4T25seSB8fCAhcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5SXNBY3RpdmUocXVlcnksIGN1cnJlbnRMb2NhdGlvbi5xdWVyeSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1ha2VTdGF0ZVdpdGhMb2NhdGlvbjtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZVdpdGhMb2NhdGlvbihzdGF0ZSwgbG9jYXRpb24pIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuY2FuVXNlTWVtYnJhbmUpIHtcbiAgICB2YXIgc3RhdGVXaXRoTG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgc3RhdGUpO1xuXG4gICAgLy8gSSBkb24ndCB1c2UgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyBoZXJlIGJlY2F1c2UgSSB3YW50IHRvIGtlZXAgdGhlXG4gICAgLy8gc2FtZSBjb2RlIHBhdGggYmV0d2VlbiBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiwgaW4gdGhhdCB3ZSBqdXN0XG4gICAgLy8gYXNzaWduIGV4dHJhIHByb3BlcnRpZXMgdG8gdGhlIGNvcHkgb2YgdGhlIHN0YXRlIG9iamVjdCBpbiBib3RoIGNhc2VzLlxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYXRpb24sIHByb3ApKSB7XG4gICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhdGVXaXRoTG9jYXRpb24sIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBY2Nlc3NpbmcgbG9jYXRpb24gcHJvcGVydGllcyBkaXJlY3RseSBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgZ2V0Q29tcG9uZW50YCwgYGdldENvbXBvbmVudHNgLCBgZ2V0Q2hpbGRSb3V0ZXNgLCBhbmQgYGdldEluZGV4Um91dGVgIGlzIGRlcHJlY2F0ZWQuIFRoYXQgYXJndW1lbnQgaXMgbm93IHRoZSByb3V0ZXIgc3RhdGUgKGBuZXh0U3RhdGVgIG9yIGBwYXJ0aWFsTmV4dFN0YXRlYCkgcmF0aGVyIHRoYW4gdGhlIGxvY2F0aW9uLiBUbyBhY2Nlc3MgdGhlIGxvY2F0aW9uLCB1c2UgYG5leHRTdGF0ZS5sb2NhdGlvbmAgb3IgYHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb25gLicpIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gbG9jYXRpb24pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVXaXRoTG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCBsb2NhdGlvbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL0FjdGlvbnMnKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1JvdXRlclV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZXJVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKlxuICogQSBoaWdoLWxldmVsIEFQSSB0byBiZSB1c2VkIGZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXRjaGVzIGEgbG9jYXRpb24gdG8gYSBzZXQgb2Ygcm91dGVzIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIHJlbmRlclByb3BzKSB3aGVuIGZpbmlzaGVkLlxuICpcbiAqIE5vdGU6IFlvdSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHVzZSB0aGlzIGluIGEgYnJvd3NlciB1bmxlc3MgeW91J3JlIHVzaW5nXG4gKiBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgd2l0aCBhc3luYyByb3V0ZXMuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoKF9yZWYsIGNhbGxiYWNrKSB7XG4gIHZhciBoaXN0b3J5ID0gX3JlZi5oaXN0b3J5O1xuICB2YXIgcm91dGVzID0gX3JlZi5yb3V0ZXM7XG4gIHZhciBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb247XG5cbiAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydoaXN0b3J5JywgJ3JvdXRlcycsICdsb2NhdGlvbiddKTtcblxuICAhKGhpc3RvcnkgfHwgbG9jYXRpb24pID8gXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ21hdGNoIG5lZWRzIGEgaGlzdG9yeSBvciBhIGxvY2F0aW9uJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIGhpc3RvcnkgPSBoaXN0b3J5ID8gaGlzdG9yeSA6ICgwLCBfY3JlYXRlTWVtb3J5SGlzdG9yeTIuZGVmYXVsdCkob3B0aW9ucyk7XG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKHJvdXRlcykpO1xuXG4gIHZhciB1bmxpc3RlbiA9IHZvaWQgMDtcblxuICBpZiAobG9jYXRpb24pIHtcbiAgICAvLyBBbGxvdyBtYXRjaCh7IGxvY2F0aW9uOiAnL3RoZS9wYXRoJywgLi4uIH0pXG4gICAgbG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQaWNrIHVwIHRoZSBsb2NhdGlvbiBmcm9tIHRoZSBoaXN0b3J5IHZpYSBzeW5jaHJvbm91cyBoaXN0b3J5Lmxpc3RlblxuICAgIC8vIGNhbGwgaWYgbmVlZGVkLlxuICAgIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGhpc3RvcnlMb2NhdGlvbikge1xuICAgICAgbG9jYXRpb24gPSBoaXN0b3J5TG9jYXRpb247XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcm91dGVyID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0ZXJPYmplY3QpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgaGlzdG9yeSA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGluZ0hpc3RvcnkpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICB0cmFuc2l0aW9uTWFuYWdlci5tYXRjaChsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUpIHtcbiAgICBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiAmJiByb3V0ZXIuY3JlYXRlTG9jYXRpb24ocmVkaXJlY3RMb2NhdGlvbiwgX0FjdGlvbnMuUkVQTEFDRSksIG5leHRTdGF0ZSAmJiBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7XG4gICAgICBoaXN0b3J5OiBoaXN0b3J5LFxuICAgICAgcm91dGVyOiByb3V0ZXIsXG4gICAgICBtYXRjaENvbnRleHQ6IHsgaGlzdG9yeTogaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXI6IHRyYW5zaXRpb25NYW5hZ2VyLCByb3V0ZXI6IHJvdXRlciB9XG4gICAgfSkpO1xuXG4gICAgLy8gRGVmZXIgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIHRvIGhlcmUgdG8gcHJldmVudCBET00gaGlzdG9yaWVzIGZyb20gaGF2aW5nXG4gICAgLy8gdG8gdW53aW5kIERPTSBldmVudCBsaXN0ZW5lcnMgdW5uZWNlc3NhcmlseSwgaW4gY2FzZSBjYWxsYmFjayByZW5kZXJzIGFcbiAgICAvLyA8Um91dGVyPiBhbmQgYXR0YWNoZXMgYW5vdGhlciBoaXN0b3J5IGxpc3RlbmVyLlxuICAgIGlmICh1bmxpc3Rlbikge1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoUm91dGVzO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24gPSByZXF1aXJlKCcuL21ha2VTdGF0ZVdpdGhMb2NhdGlvbicpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYWtlU3RhdGVXaXRoTG9jYXRpb24pO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRDaGlsZFJvdXRlcyhyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICByZXR1cm4gW251bGwsIHJvdXRlLmNoaWxkUm91dGVzXTtcbiAgfVxuICBpZiAoIXJvdXRlLmdldENoaWxkUm91dGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHN5bmMgPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gdm9pZCAwO1xuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0ge1xuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgfTtcblxuICB2YXIgcGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiA9ICgwLCBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMi5kZWZhdWx0KShwYXJ0aWFsTmV4dFN0YXRlLCBsb2NhdGlvbik7XG5cbiAgcm91dGUuZ2V0Q2hpbGRSb3V0ZXMocGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBjaGlsZFJvdXRlcykge1xuICAgIGNoaWxkUm91dGVzID0gIWVycm9yICYmICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGNoaWxkUm91dGVzKTtcbiAgICBpZiAoc3luYykge1xuICAgICAgcmVzdWx0ID0gW2Vycm9yLCBjaGlsZFJvdXRlc107XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyb3IsIGNoaWxkUm91dGVzKTtcbiAgfSk7XG5cbiAgc3luYyA9IGZhbHNlO1xuICByZXR1cm4gcmVzdWx0OyAvLyBNaWdodCBiZSB1bmRlZmluZWQuXG59XG5cbmZ1bmN0aW9uIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmluZGV4Um91dGUpIHtcbiAgICBjYWxsYmFjayhudWxsLCByb3V0ZS5pbmRleFJvdXRlKTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5nZXRJbmRleFJvdXRlKSB7XG4gICAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgICB9O1xuXG4gICAgdmFyIHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24gPSAoMCwgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIuZGVmYXVsdCkocGFydGlhbE5leHRTdGF0ZSwgbG9jYXRpb24pO1xuXG4gICAgcm91dGUuZ2V0SW5kZXhSb3V0ZShwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCAhZXJyb3IgJiYgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoaW5kZXhSb3V0ZSlbMF0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXRobGVzcyA9IHJvdXRlLmNoaWxkUm91dGVzLmZpbHRlcihmdW5jdGlvbiAoY2hpbGRSb3V0ZSkge1xuICAgICAgICByZXR1cm4gIWNoaWxkUm91dGUucGF0aDtcbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShwYXRobGVzcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgICBnZXRJbmRleFJvdXRlKHBhdGhsZXNzW2luZGV4XSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcbiAgICAgICAgICBpZiAoZXJyb3IgfHwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgICAgdmFyIHJvdXRlcyA9IFtwYXRobGVzc1tpbmRleF1dLmNvbmNhdChBcnJheS5pc0FycmF5KGluZGV4Um91dGUpID8gaW5kZXhSb3V0ZSA6IFtpbmRleFJvdXRlXSk7XG4gICAgICAgICAgICBkb25lKGVycm9yLCByb3V0ZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJvdXRlcykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByb3V0ZXMpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblBhcmFtcyhwYXJhbXMsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKSB7XG4gIHJldHVybiBwYXJhbU5hbWVzLnJlZHVjZShmdW5jdGlvbiAocGFyYW1zLCBwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbVZhbHVlcyAmJiBwYXJhbVZhbHVlc1tpbmRleF07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXNbcGFyYW1OYW1lXSkpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdLnB1c2gocGFyYW1WYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IFtwYXJhbXNbcGFyYW1OYW1lXSwgcGFyYW1WYWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gcGFyYW1WYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpIHtcbiAgcmV0dXJuIGFzc2lnblBhcmFtcyh7fSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlRGVlcChyb3V0ZSwgbG9jYXRpb24sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBwYXJhbU5hbWVzID0gW107XG4gICAgcGFyYW1WYWx1ZXMgPSBbXTtcbiAgfVxuXG4gIC8vIE9ubHkgdHJ5IHRvIG1hdGNoIHRoZSBwYXRoIGlmIHRoZSByb3V0ZSBhY3R1YWxseSBoYXMgYSBwYXR0ZXJuLCBhbmQgaWZcbiAgLy8gd2UncmUgbm90IGp1c3Qgc2VhcmNoaW5nIGZvciBwb3RlbnRpYWwgbmVzdGVkIGFic29sdXRlIHBhdGhzLlxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9ICgwLCBfUGF0dGVyblV0aWxzLm1hdGNoUGF0dGVybikocGF0dGVybiwgcmVtYWluaW5nUGF0aG5hbWUpO1xuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBtYXRjaGVkLnJlbWFpbmluZ1BhdGhuYW1lO1xuICAgICAgICBwYXJhbU5hbWVzID0gW10uY29uY2F0KHBhcmFtTmFtZXMsIG1hdGNoZWQucGFyYW1OYW1lcyk7XG4gICAgICAgIHBhcmFtVmFsdWVzID0gW10uY29uY2F0KHBhcmFtVmFsdWVzLCBtYXRjaGVkLnBhcmFtVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIEJ5IGFzc3VtcHRpb24sIHBhdHRlcm4gaXMgbm9uLWVtcHR5IGhlcmUsIHdoaWNoIGlzIHRoZSBwcmVyZXF1aXNpdGUgZm9yXG4gICAgLy8gYWN0dWFsbHkgdGVybWluYXRpbmcgYSBtYXRjaC5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09ICcnKSB7XG4gICAgICB2YXIgX3JldDIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgICByb3V0ZXM6IFtyb3V0ZV0sXG4gICAgICAgICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kZXhSb3V0ZSkpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXRjaCRyb3V0ZXM7XG5cbiAgICAgICAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoaW5kZXhSb3V0ZS5ldmVyeShmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXJvdXRlLnBhdGg7XG4gICAgICAgICAgICAgIH0pLCAnSW5kZXggcm91dGVzIHNob3VsZCBub3QgaGF2ZSBwYXRocycpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAoX21hdGNoJHJvdXRlcyA9IG1hdGNoLnJvdXRlcykucHVzaC5hcHBseShfbWF0Y2gkcm91dGVzLCBpbmRleFJvdXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXhSb3V0ZSkge1xuICAgICAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghaW5kZXhSb3V0ZS5wYXRoLCAnSW5kZXggcm91dGVzIHNob3VsZCBub3QgaGF2ZSBwYXRocycpIDogdm9pZCAwO1xuICAgICAgICAgICAgICBtYXRjaC5yb3V0ZXMucHVzaChpbmRleFJvdXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWF0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2OiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcblxuICAgICAgaWYgKCh0eXBlb2YgX3JldDIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKF9yZXQyKSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0Mi52O1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPSBudWxsIHx8IHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgLy8gRWl0aGVyIGEpIHRoaXMgcm91dGUgbWF0Y2hlZCBhdCBsZWFzdCBzb21lIG9mIHRoZSBwYXRoIG9yIGIpXG4gICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byBsb2FkIHRoaXMgcm91dGUncyBjaGlsZHJlbiBhc3luY2hyb25vdXNseS4gSW5cbiAgICAvLyBlaXRoZXIgY2FzZSBjb250aW51ZSBjaGVja2luZyBmb3IgbWF0Y2hlcyBpbiB0aGUgc3VidHJlZS5cbiAgICB2YXIgb25DaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIG9uQ2hpbGRSb3V0ZXMoZXJyb3IsIGNoaWxkUm91dGVzKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZFJvdXRlcykge1xuICAgICAgICAvLyBDaGVjayB0aGUgY2hpbGQgcm91dGVzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBtYXRjaC5cbiAgICAgICAgbWF0Y2hSb3V0ZXMoY2hpbGRSb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG1hdGNoKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gQSBjaGlsZCByb3V0ZSBtYXRjaGVkISBBdWdtZW50IHRoZSBtYXRjaCBhbmQgcGFzcyBpdCB1cCB0aGUgc3RhY2suXG4gICAgICAgICAgICBtYXRjaC5yb3V0ZXMudW5zaGlmdChyb3V0ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXRjaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc3VsdCA9IGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIG9uQ2hpbGRSb3V0ZXMpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIG9uQ2hpbGRSb3V0ZXMuYXBwbHkodW5kZWZpbmVkLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgbWF0Y2hlcyB0aGUgZ2l2ZW4gbG9jYXRpb24gdG8gYSBzZXQgb2Ygcm91dGVzIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHN0YXRlKSB3aGVuIGZpbmlzaGVkLiBUaGUgc3RhdGUgb2JqZWN0IHdpbGwgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcm91dGVzICAgICAgIEFuIGFycmF5IG9mIHJvdXRlcyB0aGF0IG1hdGNoZWQsIGluIGhpZXJhcmNoaWNhbCBvcmRlclxuICogLSBwYXJhbXMgICAgICAgQW4gb2JqZWN0IG9mIFVSTCBwYXJhbWV0ZXJzXG4gKlxuICogTm90ZTogVGhpcyBvcGVyYXRpb24gbWF5IGZpbmlzaCBzeW5jaHJvbm91c2x5IGlmIG5vIHJvdXRlcyBoYXZlIGFuXG4gKiBhc3luY2hyb25vdXMgZ2V0Q2hpbGRSb3V0ZXMgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uLCBjYWxsYmFjaywgcmVtYWluaW5nUGF0aG5hbWUpIHtcbiAgdmFyIHBhcmFtTmFtZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDQgfHwgYXJndW1lbnRzWzRdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1s0XTtcbiAgdmFyIHBhcmFtVmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSA1IHx8IGFyZ3VtZW50c1s1XSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbNV07XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGEgbGl0dGxlIGJpdCB1Z2x5LCBidXQgaXQgd29ya3MgYXJvdW5kIGEgcXVpcmsgaW4gaGlzdG9yeVxuICAgIC8vIHRoYXQgc3RyaXBzIHRoZSBsZWFkaW5nIHNsYXNoIGZyb20gcGF0aG5hbWVzIHdoZW4gdXNpbmcgYmFzZW5hbWVzIHdpdGhcbiAgICAvLyB0cmFpbGluZyBzbGFzaGVzLlxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6ICcvJyArIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgfVxuXG4gICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKHJvdXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgIG1hdGNoUm91dGVEZWVwKHJvdXRlc1tpbmRleF0sIGxvY2F0aW9uLCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgbWF0Y2gpIHtcbiAgICAgIGlmIChlcnJvciB8fCBtYXRjaCkge1xuICAgICAgICBkb25lKGVycm9yLCBtYXRjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJvdXRlcldhcm5pbmc7XG5leHBvcnRzLl9yZXNldFdhcm5lZCA9IF9yZXNldFdhcm5lZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB3YXJuZWQgPSB7fTtcblxuZnVuY3Rpb24gcm91dGVyV2FybmluZyhmYWxzZVRvV2FybiwgbWVzc2FnZSkge1xuICAvLyBPbmx5IGlzc3VlIGRlcHJlY2F0aW9uIHdhcm5pbmdzIG9uY2UuXG4gIGlmIChtZXNzYWdlLmluZGV4T2YoJ2RlcHJlY2F0ZWQnKSAhPT0gLTEpIHtcbiAgICBpZiAod2FybmVkW21lc3NhZ2VdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAnW3JlYWN0LXJvdXRlcl0gJyArIG1lc3NhZ2U7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBfd2FybmluZzIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIFtmYWxzZVRvV2FybiwgbWVzc2FnZV0uY29uY2F0KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gX3Jlc2V0V2FybmVkKCkge1xuICB3YXJuZWQgPSB7fTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VSb3V0ZXJIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB1c2VSb3V0ZXJIaXN0b3J5KGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKCgwLCBfdXNlQmFzZW5hbWUyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF91c2VRdWVyaWVzID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlUXVlcmllcycpO1xuXG52YXIgX3VzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUXVlcmllcyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGFib3V0IHJvdXRpbmcuXG4gKlxuICogRW5oYW5jZXMgaGlzdG9yeSBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICpcbiAqIC0gbGlzdGVuKChlcnJvciwgbmV4dFN0YXRlKSA9PiB7fSlcbiAqIC0gbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCAobmV4dExvY2F0aW9uKSA9PiB7fSlcbiAqIC0gbWF0Y2gobG9jYXRpb24sIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSA9PiB7fSlcbiAqIC0gaXNBY3RpdmUocGF0aG5hbWUsIHF1ZXJ5LCBpbmRleE9ubHk9ZmFsc2UpXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlcyhjcmVhdGVIaXN0b3J5KSB7XG4gIFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYHVzZVJvdXRlc2AgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXJgIGluc3RlYWQuJykgOiB2b2lkIDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIHJvdXRlcyA9IF9yZWYucm91dGVzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydyb3V0ZXMnXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkob3B0aW9ucyk7XG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgcm91dGVzKTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlUm91dGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoUm91dGVyO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSB7XG4gIHJldHVybiBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxuZnVuY3Rpb24gd2l0aFJvdXRlcihXcmFwcGVkQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIHZhciB3aXRoUmVmID0gb3B0aW9ucyAmJiBvcHRpb25zLndpdGhSZWY7XG5cbiAgdmFyIFdpdGhSb3V0ZXIgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICAgIGRpc3BsYXlOYW1lOiAnV2l0aFJvdXRlcicsXG5cbiAgICBjb250ZXh0VHlwZXM6IHsgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlIH0sXG4gICAgcHJvcFR5cGVzOiB7IHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZSB9LFxuXG4gICAgZ2V0V3JhcHBlZEluc3RhbmNlOiBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAhd2l0aFJlZiA/IFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICdgeyB3aXRoUmVmOiB0cnVlIH1gIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHdpdGhSb3V0ZXIoKSBjYWxsLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcm91dGVyID0gdGhpcy5wcm9wcy5yb3V0ZXIgfHwgdGhpcy5jb250ZXh0LnJvdXRlcjtcbiAgICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IHJvdXRlcjogcm91dGVyIH0pO1xuXG4gICAgICBpZiAod2l0aFJlZikge1xuICAgICAgICBwcm9wcy5yZWYgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIF90aGlzLndyYXBwZWRJbnN0YW5jZSA9IGM7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgfVxuICB9KTtcblxuICBXaXRoUm91dGVyLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuICBXaXRoUm91dGVyLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuXG4gIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMi5kZWZhdWx0KShXaXRoUm91dGVyLCBXcmFwcGVkQ29tcG9uZW50KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gdGh1bmtNaWRkbGV3YXJlKF9yZWYpIHtcbiAgdmFyIGRpc3BhdGNoID0gX3JlZi5kaXNwYXRjaDtcbiAgdmFyIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcblxuICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlKSA6IG5leHQoYWN0aW9uKTtcbiAgICB9O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRodW5rTWlkZGxld2FyZTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGFwcGx5TWlkZGxld2FyZTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IF9jb21wb3NlMlsnZGVmYXVsdCddLmFwcGx5KHVuZGVmaW5lZCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdG9yZSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGJpbmRBY3Rpb25DcmVhdG9ycztcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZnVuY3Rpb24gaW4gcmV0dXJuLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBhY3Rpb25DcmVhdG9ycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb25cbiAqIGNyZWF0b3IgZnVuY3Rpb25zLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpbiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhc2BcbiAqIHN5bnRheC4gWW91IG1heSBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggVGhlIGBkaXNwYXRjaGAgZnVuY3Rpb24gYXZhaWxhYmxlIG9uIHlvdXIgUmVkdXhcbiAqIHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFRoZSBvYmplY3QgbWltaWNraW5nIHRoZSBvcmlnaW5hbCBvYmplY3QsIGJ1dCB3aXRoXG4gKiBldmVyeSBhY3Rpb24gY3JlYXRvciB3cmFwcGVkIGludG8gdGhlIGBkaXNwYXRjaGAgY2FsbC4gSWYgeW91IHBhc3NlZCBhXG4gKiBmdW5jdGlvbiBhcyBgYWN0aW9uQ3JlYXRvcnNgLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYWxzbyBiZSBhIHNpbmdsZVxuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAnICsgKGFjdGlvbkNyZWF0b3JzID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGFjdGlvbkNyZWF0b3JzKSArICcuICcgKyAnRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj8nKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWN0aW9uQ3JlYXRvcnMpO1xuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNvbWJpbmVSZWR1Y2VycztcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uTmFtZSA9IGFjdGlvblR5cGUgJiYgJ1wiJyArIGFjdGlvblR5cGUudG9TdHJpbmcoKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XG5cbiAgcmV0dXJuICdHaXZlbiBhY3Rpb24gJyArIGFjdGlvbk5hbWUgKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLic7XG59XG5cbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbJ2RlZmF1bHQnXSkoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdW5leHBlY3RlZEtleUNhY2hlW2tleV07XG4gIH0pO1xuXG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2FuaXR5KHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKSgnTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIHZhciBzYW5pdHlFcnJvcjtcbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2FuaXR5KGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2FuaXR5RXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHNbMV07XG5cbiAgICBpZiAoc2FuaXR5RXJyb3IpIHtcbiAgICAgIHRocm93IHNhbml0eUVycm9yO1xuICAgIH1cblxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKSh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tpXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtrZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZVtrZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21wb3NlO1xuLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gIHZhciByZXN0ID0gZnVuY3Muc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xuICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xuICAgIH0sIGxhc3QuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkFjdGlvblR5cGVzID0gdW5kZWZpbmVkO1xuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlU3RvcmU7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlID0gcmVxdWlyZSgnc3ltYm9sLW9ic2VydmFibGUnKTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbE9ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG52YXIgQWN0aW9uVHlwZXMgPSBleHBvcnRzLkFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmhhbmNlciBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyWydkZWZhdWx0J10pKGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZltfc3ltYm9sT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbX3N5bWJvbE9ic2VydmFibGUyWydkZWZhdWx0J11dID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21wb3NlID0gZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBleHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IGV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gZXhwb3J0cy5jcmVhdGVTdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9jcmVhdGVTdG9yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVTdG9yZSk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzID0gcmVxdWlyZSgnLi9jb21iaW5lUmVkdWNlcnMnKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tYmluZVJlZHVjZXJzKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMgPSByZXF1aXJlKCcuL2JpbmRBY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaW5kQWN0aW9uQ3JlYXRvcnMpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZSA9IHJlcXVpcmUoJy4vYXBwbHlNaWRkbGV3YXJlJyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGx5TWlkZGxld2FyZSk7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLypcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4qL1xuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKSgnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydHMuY3JlYXRlU3RvcmUgPSBfY3JlYXRlU3RvcmUyWydkZWZhdWx0J107XG5leHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IF9jb21iaW5lUmVkdWNlcnMyWydkZWZhdWx0J107XG5leHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IF9iaW5kQWN0aW9uQ3JlYXRvcnMyWydkZWZhdWx0J107XG5leHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IF9hcHBseU1pZGRsZXdhcmUyWydkZWZhdWx0J107XG5leHBvcnRzLmNvbXBvc2UgPSBfY29tcG9zZTJbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn0iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4Jyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcG9ueWZpbGwgPSByZXF1aXJlKCcuL3BvbnlmaWxsJyk7XG5cbnZhciBfcG9ueWZpbGwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9ueWZpbGwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciByb290OyAvKiBnbG9iYWwgd2luZG93ICovXG5cblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gc2VsZjtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IG1vZHVsZTtcbn0gZWxzZSB7XG4gIHJvb3QgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufVxuXG52YXIgcmVzdWx0ID0gKDAsIF9wb255ZmlsbDJbJ2RlZmF1bHQnXSkocm9vdCk7XG5leHBvcnRzWydkZWZhdWx0J10gPSByZXN1bHQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1snZGVmYXVsdCddID0gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsO1xuZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIF9TeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIF9TeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoX1N5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBfU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdF9TeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTsiLCJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG4iLCJ2YXIgd2luZG93ICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2dsb2JhbCcpO1xudmFyIE1vY2tYTUxIdHRwUmVxdWVzdCAgPSByZXF1aXJlKCcuL2xpYi9Nb2NrWE1MSHR0cFJlcXVlc3QnKTtcbnZhciByZWFsICAgICAgICAgICAgICAgID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xudmFyIG1vY2sgICAgICAgICAgICAgICAgPSBNb2NrWE1MSHR0cFJlcXVlc3Q7XG5cbi8qKlxuICogTW9jayB1dGlsaXR5XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdFhNTEh0dHBSZXF1ZXN0OiBNb2NrWE1MSHR0cFJlcXVlc3QsXG5cblx0LyoqXG5cdCAqIFJlcGxhY2UgdGhlIG5hdGl2ZSBYSFIgd2l0aCB0aGUgbW9ja2VkIFhIUlxuXHQgKiBAcmV0dXJucyB7ZXhwb3J0c31cblx0ICovXG5cdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHR3aW5kb3cuWE1MSHR0cFJlcXVlc3QgPSBtb2NrO1xuXHRcdE1vY2tYTUxIdHRwUmVxdWVzdC5oYW5kbGVycyA9IFtdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXBsYWNlIHRoZSBtb2NrZWQgWEhSIHdpdGggdGhlIG5hdGl2ZSBYSFIgYW5kIHJlbW92ZSBhbnkgaGFuZGxlcnNcblx0ICogQHJldHVybnMge2V4cG9ydHN9XG5cdCAqL1xuXHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0TW9ja1hNTEh0dHBSZXF1ZXN0LmhhbmRsZXJzID0gW107XG5cdFx0d2luZG93LlhNTEh0dHBSZXF1ZXN0ID0gcmVhbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogTW9jayBhIHJlcXVlc3Rcblx0ICogQHBhcmFtICAge3N0cmluZ30gICAgW21ldGhvZF1cblx0ICogQHBhcmFtICAge3N0cmluZ30gICAgW3VybF1cblx0ICogQHBhcmFtICAge0Z1bmN0aW9ufSAgZm5cblx0ICogQHJldHVybnMge2V4cG9ydHN9XG5cdCAqL1xuXHRtb2NrOiBmdW5jdGlvbihtZXRob2QsIHVybCwgZm4pIHtcblx0XHR2YXIgaGFuZGxlcjtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uKHJlcSwgcmVzKSB7XG5cdFx0XHRcdGlmIChyZXEubWV0aG9kKCkgPT09IG1ldGhvZCAmJiByZXEudXJsKCkgPT09IHVybCkge1xuXHRcdFx0XHRcdHJldHVybiBmbihyZXEsIHJlcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGFuZGxlciA9IG1ldGhvZDtcblx0XHR9XG5cblx0XHRNb2NrWE1MSHR0cFJlcXVlc3QuYWRkSGFuZGxlcihoYW5kbGVyKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNb2NrIGEgR0VUIHJlcXVlc3Rcblx0ICogQHBhcmFtICAge1N0cmluZ30gICAgdXJsXG5cdCAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gIGZuXG5cdCAqIEByZXR1cm5zIHtleHBvcnRzfVxuXHQgKi9cblx0Z2V0OiBmdW5jdGlvbih1cmwsIGZuKSB7XG5cdFx0cmV0dXJuIHRoaXMubW9jaygnR0VUJywgdXJsLCBmbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1vY2sgYSBQT1NUIHJlcXVlc3Rcblx0ICogQHBhcmFtICAge1N0cmluZ30gICAgdXJsXG5cdCAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gIGZuXG5cdCAqIEByZXR1cm5zIHtleHBvcnRzfVxuXHQgKi9cblx0cG9zdDogZnVuY3Rpb24odXJsLCBmbikge1xuXHRcdHJldHVybiB0aGlzLm1vY2soJ1BPU1QnLCB1cmwsIGZuKTtcblx0fSxcblxuXHQvKipcblx0ICogTW9jayBhIFBVVCByZXF1ZXN0XG5cdCAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIHVybFxuXHQgKiBAcGFyYW0gICB7RnVuY3Rpb259ICBmblxuXHQgKiBAcmV0dXJucyB7ZXhwb3J0c31cblx0ICovXG5cdHB1dDogZnVuY3Rpb24odXJsLCBmbikge1xuXHRcdHJldHVybiB0aGlzLm1vY2soJ1BVVCcsIHVybCwgZm4pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNb2NrIGEgUEFUQ0ggcmVxdWVzdFxuXHQgKiBAcGFyYW0gICB7U3RyaW5nfSAgICB1cmxcblx0ICogQHBhcmFtICAge0Z1bmN0aW9ufSAgZm5cblx0ICogQHJldHVybnMge2V4cG9ydHN9XG5cdCAqL1xuXHRwYXRjaDogZnVuY3Rpb24odXJsLCBmbikge1xuXHRcdHJldHVybiB0aGlzLm1vY2soJ1BBVENIJywgdXJsLCBmbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1vY2sgYSBERUxFVEUgcmVxdWVzdFxuXHQgKiBAcGFyYW0gICB7U3RyaW5nfSAgICB1cmxcblx0ICogQHBhcmFtICAge0Z1bmN0aW9ufSAgZm5cblx0ICogQHJldHVybnMge2V4cG9ydHN9XG5cdCAqL1xuXHRkZWxldGU6IGZ1bmN0aW9uKHVybCwgZm4pIHtcblx0XHRyZXR1cm4gdGhpcy5tb2NrKCdERUxFVEUnLCB1cmwsIGZuKTtcblx0fVxuXG59O1xuIiwiXG4vKipcbiAqIFRoZSBtb2NrZWQgcmVxdWVzdCBkYXRhXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTW9ja1JlcXVlc3QoeGhyKSB7XG4gIHRoaXMuX3hociAgICAgICA9IHhoclxuICB0aGlzLl9tZXRob2QgICAgPSB4aHIubWV0aG9kO1xuICB0aGlzLl91cmwgICAgICAgPSB4aHIudXJsO1xuICB0aGlzLl9oZWFkZXJzICAgPSB7fTtcbiAgdGhpcy5oZWFkZXJzKHhoci5fcmVxdWVzdEhlYWRlcnMpO1xuICB0aGlzLmJvZHkoeGhyLmRhdGEpO1xufVxuXG4vKipcbiAqIEdldC9zZXQgdGhlIEhUVFAgbWV0aG9kXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5Nb2NrUmVxdWVzdC5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tZXRob2Q7XG59O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIEhUVFAgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5Nb2NrUmVxdWVzdC5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl91cmw7XG59O1xuXG4vKipcbiAqIEdldC9zZXQgYSBIVFRQIGhlYWRlclxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxuICogQHBhcmFtICAge3N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR8TW9ja1JlcXVlc3R9XG4gKi9cbk1vY2tSZXF1ZXN0LnByb3RvdHlwZS5oZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMuX2hlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQvc2V0IGFsbCBvZiB0aGUgSFRUUCBoZWFkZXJzXG4gKiBAcGFyYW0gICB7T2JqZWN0fSBbaGVhZGVyc11cbiAqIEByZXR1cm5zIHtPYmplY3R8TW9ja1JlcXVlc3R9XG4gKi9cbk1vY2tSZXF1ZXN0LnByb3RvdHlwZS5oZWFkZXJzID0gZnVuY3Rpb24oaGVhZGVycykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdGhpcy5oZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzO1xuICB9XG59O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIEhUVFAgYm9keVxuICogQHBhcmFtICAge3N0cmluZ30gW2JvZHldXG4gKiBAcmV0dXJucyB7c3RyaW5nfE1vY2tSZXF1ZXN0fVxuICovXG5Nb2NrUmVxdWVzdC5wcm90b3R5cGUuYm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fYm9keTtcbiAgfVxufTtcblxuLyoqXG4gKiBUcmlnZ2VyIHByb2dyZXNzIGV2ZW50XG4gKiBAcGFyYW0gICB7bnVtYmVyfSBbbG9hZGVkXVxuICogQHBhcmFtICAge251bWJlcn0gW3RvdGFsXVxuICogQHBhcmFtICAge2Jvb2xlYW59IFtsZW5ndGhDb21wdXRhYmxlXVxuICogQHJldHVybnMge31cbiAqL1xuTW9ja1JlcXVlc3QucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24obG9hZGVkLCB0b3RhbCwgbGVuZ3RoQ29tcHV0YWJsZSkge1xuICB0aGlzLl94aHIudHJpZ2dlcigncHJvZ3Jlc3MnLCB7XG4gICAgbGVuZ3RoQ29tcHV0YWJsZTogbGVuZ3RoQ29tcHV0YWJsZSB8fCB0cnVlLFxuICAgIGxvYWRlZDogbG9hZGVkLFxuICAgIHRvdGFsOiB0b3RhbFxuICB9KVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrUmVxdWVzdDtcbiIsIlxuLyoqXG4gKiBUaGUgbW9ja2VkIHJlc3BvbnNlIGRhdGFcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNb2NrUmVzcG9uc2UoKSB7XG4gIHRoaXMuX3N0YXR1cyAgICAgID0gMjAwO1xuICB0aGlzLl9oZWFkZXJzICAgICA9IHt9O1xuICB0aGlzLl9ib2R5ICAgICAgICA9ICcnO1xuICB0aGlzLl90aW1lb3V0ICAgICA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEdldC9zZXQgdGhlIEhUVFAgc3RhdHVzXG4gKiBAcGFyYW0gICB7bnVtYmVyfSBbY29kZV1cbiAqIEByZXR1cm5zIHtudW1iZXJ8TW9ja1Jlc3BvbnNlfVxuICovXG5Nb2NrUmVzcG9uc2UucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9zdGF0dXMgPSBjb2RlO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0L3NldCBhIEhUVFAgaGVhZGVyXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZHxNb2NrUmVzcG9uc2V9XG4gKi9cbk1vY2tSZXNwb25zZS5wcm90b3R5cGUuaGVhZGVyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0aGlzLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0L3NldCBhbGwgb2YgdGhlIEhUVFAgaGVhZGVyc1xuICogQHBhcmFtICAge09iamVjdH0gW2hlYWRlcnNdXG4gKiBAcmV0dXJucyB7T2JqZWN0fE1vY2tSZXNwb25zZX1cbiAqL1xuTW9ja1Jlc3BvbnNlLnByb3RvdHlwZS5oZWFkZXJzID0gZnVuY3Rpb24oaGVhZGVycykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdGhpcy5oZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzO1xuICB9XG59O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIEhUVFAgYm9keVxuICogQHBhcmFtICAge3N0cmluZ30gW2JvZHldXG4gKiBAcmV0dXJucyB7c3RyaW5nfE1vY2tSZXNwb25zZX1cbiAqL1xuTW9ja1Jlc3BvbnNlLnByb3RvdHlwZS5ib2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9ib2R5O1xuICB9XG59O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIEhUVFAgdGltZW91dFxuICogQHBhcmFtICAge2Jvb2xlYW58bnVtYmVyfSBbdGltZW91dF1cbiAqIEByZXR1cm5zIHtib29sZWFufG51bWJlcnxNb2NrUmVzcG9uc2V9XG4gKi9cbk1vY2tSZXNwb25zZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gdGltZW91dDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrUmVzcG9uc2U7XG4iLCJ2YXIgTW9ja1JlcXVlc3QgICA9IHJlcXVpcmUoJy4vTW9ja1JlcXVlc3QnKTtcbnZhciBNb2NrUmVzcG9uc2UgID0gcmVxdWlyZSgnLi9Nb2NrUmVzcG9uc2UnKTtcblxudmFyIG5vdEltcGxlbWVudGVkRXJyb3IgPSBuZXcgRXJyb3IoJ1RoaXMgZmVhdHVyZSBoYXNuXFwndCBiZWVuIGltcGxtZW50ZWQgeWV0LiBQbGVhc2Ugc3VibWl0IGFuIElzc3VlIG9yIFB1bGwgUmVxdWVzdCBvbiBHaXRodWIuJyk7XG5cbi8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0XG4vL2h0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy9cbi8vaHR0cDovL3d3dy53My5vcmcvVFIvMjAwNi9XRC1YTUxIdHRwUmVxdWVzdC0yMDA2MDQwNS9cblxuTW9ja1hNTEh0dHBSZXF1ZXN0LlNUQVRFX1VOU0VOVCAgICAgICAgICAgICA9IDA7XG5Nb2NrWE1MSHR0cFJlcXVlc3QuU1RBVEVfT1BFTkVEICAgICAgICAgICAgID0gMTtcbk1vY2tYTUxIdHRwUmVxdWVzdC5TVEFURV9IRUFERVJTX1JFQ0VJVkVEICAgPSAyO1xuTW9ja1hNTEh0dHBSZXF1ZXN0LlNUQVRFX0xPQURJTkcgICAgICAgICAgICA9IDM7XG5Nb2NrWE1MSHR0cFJlcXVlc3QuU1RBVEVfRE9ORSAgICAgICAgICAgICAgID0gNDtcblxuLyoqXG4gKiBUaGUgcmVxdWVzdCBoYW5kbGVyc1xuICogQHByaXZhdGVcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuTW9ja1hNTEh0dHBSZXF1ZXN0LmhhbmRsZXJzID0gW107XG5cbi8qKlxuICogQWRkIGEgcmVxdWVzdCBoYW5kbGVyXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb24oTW9ja1JlcXVlc3QsIE1vY2tSZXNwb25zZSl9IGZuXG4gKiBAcmV0dXJucyB7TW9ja1hNTEh0dHBSZXF1ZXN0fVxuICovXG5Nb2NrWE1MSHR0cFJlcXVlc3QuYWRkSGFuZGxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gIE1vY2tYTUxIdHRwUmVxdWVzdC5oYW5kbGVycy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHJlcXVlc3QgaGFuZGxlclxuICogQHBhcmFtICAge2Z1bmN0aW9uKE1vY2tSZXF1ZXN0LCBNb2NrUmVzcG9uc2UpfSBmblxuICogQHJldHVybnMge01vY2tYTUxIdHRwUmVxdWVzdH1cbiAqL1xuTW9ja1hNTEh0dHBSZXF1ZXN0LnJlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbihmbikge1xuICB0aHJvdyBub3RJbXBsZW1lbnRlZEVycm9yO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYSByZXF1ZXN0XG4gKiBAcGFyYW0gICB7TW9ja1JlcXVlc3R9IHJlcXVlc3RcbiAqIEByZXR1cm5zIHtNb2NrUmVzcG9uc2V8bnVsbH1cbiAqL1xuTW9ja1hNTEh0dHBSZXF1ZXN0LmhhbmRsZSA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcblxuICBmb3IgKHZhciBpPTA7IGk8TW9ja1hNTEh0dHBSZXF1ZXN0LmhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAvL2dldCB0aGUgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBhIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0XG4gICAgdmFyIHJlc3BvbnNlID0gTW9ja1hNTEh0dHBSZXF1ZXN0LmhhbmRsZXJzW2ldKHJlcXVlc3QsIG5ldyBNb2NrUmVzcG9uc2UoKSk7XG5cbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBNb2NrIFhNTEh0dHBSZXF1ZXN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTW9ja1hNTEh0dHBSZXF1ZXN0KCkge1xuICB0aGlzLnJlc2V0KCk7XG4gIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0gW107XG4gIHRoaXMudGltZW91dCA9IDA7XG59XG5cbi8qKlxuICogUmVzZXQgdGhlIHJlc3BvbnNlIHZhbHVlc1xuICogQHByaXZhdGVcbiAqL1xuTW9ja1hNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMuX3JlcXVlc3RIZWFkZXJzICA9IHt9O1xuICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSB7fTtcblxuICB0aGlzLnN0YXR1cyAgICAgICA9IDA7XG4gIHRoaXMuc3RhdHVzVGV4dCAgID0gJyc7XG5cbiAgdGhpcy5yZXNwb25zZSAgICAgPSBudWxsO1xuICB0aGlzLnJlc3BvbnNlVHlwZSA9IG51bGw7XG4gIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgdGhpcy5yZXNwb25zZVhNTCAgPSBudWxsO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSAgID0gTW9ja1hNTEh0dHBSZXF1ZXN0LlNUQVRFX1VOU0VOVDtcbn07XG5cbi8qKlxuICogVHJpZ2dlciBhbiBldmVudFxuICogQHBhcmFtICAge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm5zIHtNb2NrWE1MSHR0cFJlcXVlc3R9XG4gKi9cbk1vY2tYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50LCBldmVudERldGFpbHMpIHtcblxuICBpZiAodGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UpIHtcbiAgICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSgpO1xuICB9XG5cbiAgaWYgKHRoaXNbJ29uJytldmVudF0pIHtcbiAgICB0aGlzWydvbicrZXZlbnRdKCk7XG4gIH1cblxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmxlbmd0aDsgeCsrKSB7XG4gICAgdmFyIGV2ZW50TGlzdGVuZXIgPSB0aGlzLl9ldmVudExpc3RlbmVyc1t4XTtcblxuICAgIGlmIChldmVudExpc3RlbmVyLmV2ZW50ID09PSBldmVudCkge1xuICAgICAgdmFyIGV2ZW50TGlzdGVuZXJEZXRhaWxzID0gZXZlbnREZXRhaWxzIHx8IHt9O1xuICAgICAgZXZlbnRMaXN0ZW5lckRldGFpbHMuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgICBldmVudExpc3RlbmVyRGV0YWlscy50eXBlID0gZXZlbnQ7XG4gICAgICBldmVudExpc3RlbmVyLmxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnRMaXN0ZW5lckRldGFpbHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTW9ja1hNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCkge1xuICB0aGlzLnJlc2V0KCk7XG4gIHRoaXMubWV0aG9kICAgPSBtZXRob2Q7XG4gIHRoaXMudXJsICAgICAgPSB1cmw7XG4gIHRoaXMuYXN5bmMgICAgPSBhc3luYztcbiAgdGhpcy51c2VyICAgICA9IHVzZXI7XG4gIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgdGhpcy5kYXRhICAgICA9IG51bGw7XG4gIHRoaXMucmVhZHlTdGF0ZSA9IE1vY2tYTUxIdHRwUmVxdWVzdC5TVEFURV9PUEVORUQ7XG59O1xuXG5Nb2NrWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLnNldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLl9yZXF1ZXN0SGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xufTtcblxuTW9ja1hNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vdmVycmlkZU1pbWVUeXBlID0gZnVuY3Rpb24obWltZSkge1xuICB0aHJvdyBub3RJbXBsZW1lbnRlZEVycm9yO1xufTtcblxuTW9ja1hNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgc2VsZi5yZWFkeVN0YXRlID0gTW9ja1hNTEh0dHBSZXF1ZXN0LlNUQVRFX0xPQURJTkc7XG5cbiAgc2VsZi5fc2VuZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHJlc3BvbnNlID0gTW9ja1hNTEh0dHBSZXF1ZXN0LmhhbmRsZShuZXcgTW9ja1JlcXVlc3Qoc2VsZikpO1xuXG4gICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlIGluc3RhbmNlb2YgTW9ja1Jlc3BvbnNlKSB7XG5cbiAgICAgIHZhciB0aW1lb3V0ID0gcmVzcG9uc2UudGltZW91dCgpO1xuXG4gICAgICBpZiAodGltZW91dCkge1xuXG4gICAgICAgIC8vdHJpZ2dlciBhIHRpbWVvdXQgZXZlbnQgYmVjYXVzZSB0aGUgcmVxdWVzdCB0aW1lZCBvdXQgLSB3YWl0IGZvciB0aGUgdGltZW91dCB0aW1lIGJlY2F1c2UgbWFueSBsaWJzIGxpa2UganF1ZXJ5IGFuZCBzdXBlcmFnZW50IHVzZSBzZXRUaW1lb3V0IHRvIGRldGVjdCB0aGUgZXJyb3IgdHlwZVxuICAgICAgICBzZWxmLl9zZW5kVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5yZWFkeVN0YXRlID0gTW9ja1hNTEh0dHBSZXF1ZXN0LlNUQVRFX0RPTkU7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCd0aW1lb3V0Jyk7XG4gICAgICAgIH0sIHR5cGVvZih0aW1lb3V0KSA9PT0gJ251bWJlcicgPyB0aW1lb3V0IDogc2VsZi50aW1lb3V0KzEpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vbWFwIHRoZSByZXNwb25zZSB0byB0aGUgWEhSIG9iamVjdFxuICAgICAgICBzZWxmLnN0YXR1cyAgICAgICAgICAgICA9IHJlc3BvbnNlLnN0YXR1cygpO1xuICAgICAgICBzZWxmLl9yZXNwb25zZUhlYWRlcnMgICA9IHJlc3BvbnNlLmhlYWRlcnMoKTtcbiAgICAgICAgc2VsZi5yZXNwb25zZVR5cGUgICAgICAgPSAndGV4dCc7XG4gICAgICAgIHNlbGYucmVzcG9uc2UgICAgICAgICAgID0gcmVzcG9uc2UuYm9keSgpO1xuICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCAgICAgICA9IHJlc3BvbnNlLmJvZHkoKTsgLy9UT0RPOiBkZXRlY3QgYW4gb2JqZWN0IGFuZCByZXR1cm4gSlNPTiwgZGV0ZWN0IFhNTCBhbmQgcmV0dXJuIFhNTFxuICAgICAgICBzZWxmLnJlYWR5U3RhdGUgICAgICAgICA9IE1vY2tYTUxIdHRwUmVxdWVzdC5TVEFURV9ET05FO1xuXG4gICAgICAgIC8vdHJpZ2dlciBhIGxvYWQgZXZlbnQgYmVjYXVzZSB0aGUgcmVxdWVzdCB3YXMgcmVjZWl2ZWRcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdsb2FkJyk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vdHJpZ2dlciBhbiBlcnJvciBiZWNhdXNlIHRoZSByZXF1ZXN0IHdhcyBub3QgaGFuZGxlZFxuICAgICAgc2VsZi5yZWFkeVN0YXRlID0gTW9ja1hNTEh0dHBSZXF1ZXN0LlNUQVRFX0RPTkU7XG4gICAgICBzZWxmLnRyaWdnZXIoJ2Vycm9yJyk7XG5cbiAgICB9XG5cbiAgfSwgMCk7XG5cbn07XG5cbk1vY2tYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3NlbmRUaW1lb3V0KTtcblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID4gTW9ja1hNTEh0dHBSZXF1ZXN0LlNUQVRFX1VOU0VOVCAmJiB0aGlzLnJlYWR5U3RhdGUgPCBNb2NrWE1MSHR0cFJlcXVlc3QuU1RBVEVfRE9ORSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IE1vY2tYTUxIdHRwUmVxdWVzdC5TVEFURV9VTlNFTlQ7XG4gICAgdGhpcy50cmlnZ2VyKCdhYm9ydCcpO1xuICB9XG5cbn07XG5cbk1vY2tYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA8IE1vY2tYTUxIdHRwUmVxdWVzdC5TVEFURV9IRUFERVJTX1JFQ0VJVkVEKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaGVhZGVycyA9ICcnO1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX3Jlc3BvbnNlSGVhZGVycykge1xuICAgIGlmICh0aGlzLl9yZXNwb25zZUhlYWRlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGhlYWRlcnMgKz0gbmFtZSsnOiAnK3RoaXMuX3Jlc3BvbnNlSGVhZGVyc1tuYW1lXSsnXFxyXFxuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGVhZGVycztcbn07XG5cbk1vY2tYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbihuYW1lKSB7XG5cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA8IE1vY2tYTUxIdHRwUmVxdWVzdC5TVEFURV9IRUFERVJTX1JFQ0VJVkVEKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fcmVzcG9uc2VIZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgbnVsbDtcbn07XG5cbk1vY2tYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICB0aGlzLl9ldmVudExpc3RlbmVycy5wdXNoKHtcbiAgICBldmVudDogZXZlbnQsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufTtcblxuTW9ja1hNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHZhciBjdXJyZW50SW5kZXggPSAwO1xuXG4gIHdoaWxlIChjdXJyZW50SW5kZXggPCB0aGlzLl9ldmVudExpc3RlbmVycy5sZW5ndGgpIHtcbiAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW2N1cnJlbnRJbmRleF07XG4gICAgaWYgKGV2ZW50TGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50ICYmIGV2ZW50TGlzdGVuZXIubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5zcGxpY2UoY3VycmVudEluZGV4LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEluZGV4Kys7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tYTUxIdHRwUmVxdWVzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoXCJpcy1mdW5jdGlvblwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoXCJwYXJzZS1oZWFkZXJzXCIpXG52YXIgeHRlbmQgPSByZXF1aXJlKFwieHRlbmRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcbmNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG5jcmVhdGVYSFIuWERvbWFpblJlcXVlc3QgPSBcIndpdGhDcmVkZW50aWFsc1wiIGluIChuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KCkpID8gY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0IDogd2luZG93LlhEb21haW5SZXF1ZXN0XG5cbmZvckVhY2hBcnJheShbXCJnZXRcIiwgXCJwdXRcIiwgXCJwb3N0XCIsIFwicGF0Y2hcIiwgXCJoZWFkXCIsIFwiZGVsZXRlXCJdLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBjcmVhdGVYSFJbbWV0aG9kID09PSBcImRlbGV0ZVwiID8gXCJkZWxcIiA6IG1ldGhvZF0gPSBmdW5jdGlvbih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRvcihhcnJheVtpXSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKXtcbiAgICBmb3IodmFyIGkgaW4gb2JqKXtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IHVyaVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7dXJpOnVyaX1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IHh0ZW5kKG9wdGlvbnMsIHt1cmk6IHVyaX0pXG4gICAgfVxuXG4gICAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICByZXR1cm4gcGFyYW1zXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlWEhSKG9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcbiAgICB9XG5cbiAgICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYk9uY2UoZXJyLCByZXNwb25zZSwgYm9keSl7XG4gICAgICAgIGlmKCFjYWxsZWQpe1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIsIHJlc3BvbnNlLCBib2R5KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBsb2FkRnVuYygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQgfHwgZ2V0WG1sKHhocilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cblxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvckZ1bmMoZXZ0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKCEoZXZ0IGluc3RhbmNlb2YgRXJyb3IpKXtcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFcnJvcihcIlwiICsgKGV2dCB8fCBcIlVua25vd24gWE1MSHR0cFJlcXVlc3QgRXJyb3JcIikgKVxuICAgICAgICB9XG4gICAgICAgIGV2dC5zdGF0dXNDb2RlID0gMFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRGdW5jKCkge1xuICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgIHZhciBzdGF0dXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYob3B0aW9ucy51c2VYRFIgJiYgeGhyLnN0YXR1cz09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9JRTggQ09SUyBHRVQgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMgZmllbGQsIGJ1dCBib2R5IGlzIGZpbmVcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDApe1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMpeyAvL3JlbWVtYmVyIHhociBjYW4gaW4gZmFjdCBiZSBYRFIgZm9yIENPUlMgaW4gSUVcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihcIkludGVybmFsIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWERvbWFpblJlcXVlc3QoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleVxuICAgIHZhciBhYm9ydGVkXG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybFxuICAgIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIlxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMuZGF0YSB8fCBudWxsXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIgdGltZW91dFRpbWVyXG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmpzb24gIT09IGZhbHNlKSB7XG4gICAgICAgIGlzSnNvbiA9IHRydWVcbiAgICAgICAgaGVhZGVyc1tcImFjY2VwdFwiXSB8fCBoZWFkZXJzW1wiQWNjZXB0XCJdIHx8IChoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdIHx8IChoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uID09PSB0cnVlID8gYm9keSA6IG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvckZ1bmNcbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJRSBtdXN0IGRpZVxuICAgIH1cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB4aHIub250aW1lb3V0ID0gZXJyb3JGdW5jXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKVxuICAgIC8vaGFzIHRvIGJlIGFmdGVyIG9wZW5cbiAgICBpZighc3luYykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFsc1xuICAgIH1cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gICAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG4gICAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDAgKSB7XG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm5cbiAgICAgICAgICAgIGFib3J0ZWQgPSB0cnVlLy9JRTkgbWF5IHN0aWxsIGNhbGwgcmVhZHlzdGF0ZWNoYW5nZVxuICAgICAgICAgICAgeGhyLmFib3J0KFwidGltZW91dFwiKVxuICAgICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoXCJYTUxIdHRwUmVxdWVzdCB0aW1lb3V0XCIpXG4gICAgICAgICAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiXG4gICAgICAgICAgICBlcnJvckZ1bmMoZSlcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0IClcbiAgICB9XG5cbiAgICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgZm9yKGtleSBpbiBoZWFkZXJzKXtcbiAgICAgICAgICAgIGlmKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiAhaXNFbXB0eShvcHRpb25zLmhlYWRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cblxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKVxuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpXG5cbiAgICByZXR1cm4geGhyXG5cblxufVxuXG5mdW5jdGlvbiBnZXRYbWwoeGhyKSB7XG4gICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXG4gICAgfVxuICAgIHZhciBmaXJlZm94QnVnVGFrZW5FZmZlY3QgPSB4aHIuc3RhdHVzID09PSAyMDQgJiYgeGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIlxuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcIlwiICYmICFmaXJlZm94QnVnVGFrZW5FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsImNvbnN0IGlzQmFzaWNQcm9wZXJ0eSA9IChwcmVkaWNhdGVPYmplY3RNYXApID0+XG4gIFtcInRleHRcIiwgXCJzZWxlY3RcIiwgXCJtdWx0aXNlbGVjdFwiLCBcImRhdGFibGVcIiwgXCJuYW1lc1wiLCBcInNhbWVBc1wiXS5pbmRleE9mKHByZWRpY2F0ZU9iamVjdE1hcC5wcm9wZXJ0eVR5cGUpID4gLTE7XG5cbmNvbnN0IGNvbHVtbk1hcElzQ29tcGxldGUgPSAocHJlZGljYXRlT2JqZWN0TWFwKSA9PlxuICBwcmVkaWNhdGVPYmplY3RNYXAub2JqZWN0TWFwICYmXG4gIHR5cGVvZiBwcmVkaWNhdGVPYmplY3RNYXAub2JqZWN0TWFwLmNvbHVtbiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICBwcmVkaWNhdGVPYmplY3RNYXAub2JqZWN0TWFwLmNvbHVtbiAhPT0gbnVsbDtcblxuY29uc3Qgam9pbkNvbmRpdGlvbk1hcElzQ29tcGxldGUgPSAocHJlZGljYXRlT2JqZWN0TWFwKSA9PlxuICBwcmVkaWNhdGVPYmplY3RNYXAub2JqZWN0TWFwICYmXG4gICAgcHJlZGljYXRlT2JqZWN0TWFwLm9iamVjdE1hcC5wYXJlbnRUcmlwbGVzTWFwICYmXG4gICAgcHJlZGljYXRlT2JqZWN0TWFwLm9iamVjdE1hcC5qb2luQ29uZGl0aW9uICYmXG4gICAgdHlwZW9mIHByZWRpY2F0ZU9iamVjdE1hcC5vYmplY3RNYXAuam9pbkNvbmRpdGlvbi5wYXJlbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJlZGljYXRlT2JqZWN0TWFwLm9iamVjdE1hcC5qb2luQ29uZGl0aW9uLmNoaWxkICE9PSBcInVuZGVmaW5lZFwiO1xuXG5jb25zdCBwcm9wZXJ0eU1hcHBpbmdJc0NvbXBsZXRlID0gKHByZWRpY2F0ZU9iamVjdE1hcCkgPT4ge1xuICBpZiAodHlwZW9mIHByZWRpY2F0ZU9iamVjdE1hcCA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoaXNCYXNpY1Byb3BlcnR5KHByZWRpY2F0ZU9iamVjdE1hcCkpIHtcbiAgICByZXR1cm4gY29sdW1uTWFwSXNDb21wbGV0ZShwcmVkaWNhdGVPYmplY3RNYXApO1xuICB9XG5cbiAgaWYgKHByZWRpY2F0ZU9iamVjdE1hcC5wcm9wZXJ0eVR5cGUgPT09IFwicmVsYXRpb25cIikge1xuICAgIHJldHVybiBqb2luQ29uZGl0aW9uTWFwSXNDb21wbGV0ZShwcmVkaWNhdGVPYmplY3RNYXApO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgZ2V0Q29sdW1uVmFsdWUgPSAocHJlZGljYXRlT2JqZWN0TWFwKSA9PiB7XG4gIGlmICghcHJlZGljYXRlT2JqZWN0TWFwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaXNCYXNpY1Byb3BlcnR5KHByZWRpY2F0ZU9iamVjdE1hcCkpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlT2JqZWN0TWFwLm9iamVjdE1hcCAmJiBwcmVkaWNhdGVPYmplY3RNYXAub2JqZWN0TWFwLmNvbHVtbiA/IHByZWRpY2F0ZU9iamVjdE1hcC5vYmplY3RNYXAuY29sdW1uIDogbnVsbDtcbiAgfVxuXG4gIGlmIChwcmVkaWNhdGVPYmplY3RNYXAucHJvcGVydHlUeXBlID09PSBcInJlbGF0aW9uXCIpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlT2JqZWN0TWFwLm9iamVjdE1hcCAmJlxuICAgICAgcHJlZGljYXRlT2JqZWN0TWFwLm9iamVjdE1hcC5qb2luQ29uZGl0aW9uICYmXG4gICAgICBwcmVkaWNhdGVPYmplY3RNYXAub2JqZWN0TWFwLmpvaW5Db25kaXRpb24uY2hpbGQgPyBwcmVkaWNhdGVPYmplY3RNYXAub2JqZWN0TWFwLmpvaW5Db25kaXRpb24uY2hpbGQgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgeyBwcm9wZXJ0eU1hcHBpbmdJc0NvbXBsZXRlLCBpc0Jhc2ljUHJvcGVydHksIGdldENvbHVtblZhbHVlIH0iLCJpbXBvcnQgeyBvblVwbG9hZEZpbGVTZWxlY3QgfSBmcm9tIFwiLi9hY3Rpb25zL3VwbG9hZFwiXG5pbXBvcnQgeyBmZXRjaEJ1bGtVcGxvYWRlZE1ldGFkYXRhIH0gZnJvbSBcIi4vYWN0aW9ucy9mZXRjaC1idWxrdXBsb2FkZWQtbWV0YWRhdGFcIjtcbmltcG9ydCB7IHNlbGVjdENvbGxlY3Rpb24gfSBmcm9tIFwiLi9hY3Rpb25zL3NlbGVjdC1jb2xsZWN0aW9uXCI7XG5pbXBvcnQge1xuICBhZGRQcmVkaWNhdGVPYmplY3RNYXAsXG4gIHJlbW92ZVByZWRpY2F0ZU9iamVjdE1hcCxcbiAgYWRkQ3VzdG9tUHJvcGVydHksXG4gIHJlbW92ZUN1c3RvbVByb3BlcnR5LFxufSBmcm9tIFwiLi9hY3Rpb25zL3ByZWRpY2F0ZS1vYmplY3QtbWFwcGluZ3NcIjtcblxuaW1wb3J0IHsgcHVibGlzaE1hcHBpbmdzLCBzYXZlTWFwcGluZ1N0YXRlLCBzYXZlTmV3TWFwcGluZ1N0YXRlIH0gZnJvbSBcIi4vYWN0aW9ucy9wdWJsaXNoLW1hcHBpbmdzXCI7XG5cbmltcG9ydCB7IGRlbGV0ZVZyZSB9IGZyb20gXCIuL2FjdGlvbnMvZGVsZXRlLXZyZVwiO1xuaW1wb3J0IHtzYXZlRGF0YXNldFNldHRpbmdzfSBmcm9tIFwiLi9hY3Rpb25zL3VwbG9hZFwiO1xuaW1wb3J0IHt1cGxvYWRJbWFnZX0gZnJvbSBcIi4vYWN0aW9ucy91cGxvYWRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWN0aW9uc01ha2VyKG5hdmlnYXRlVG8sIGRpc3BhdGNoKSB7XG4gIHJldHVybiB7XG5cbiAgICAvLyBsb2FkaW5nIGltcG9ydCBkYXRhXG4gICAgb25VcGxvYWRGaWxlU2VsZWN0OiBvblVwbG9hZEZpbGVTZWxlY3QobmF2aWdhdGVUbywgZGlzcGF0Y2gpLFxuXG5cbiAgICBvbkNsZWFyRm9ybVNldHRpbmdEYXRhOiAoKSA9PiBkaXNwYXRjaCh7dHlwZTogXCJDTEVBUl9EQVRBU0VUX1NFVFRJTkdTXCJ9KSxcbiAgICBvblNldE5ld1ZyZU5hbWU6ICh2YWx1ZSkgPT4gZGlzcGF0Y2goe3R5cGU6IFwiU0VUX05FV19WUkVfTkFNRVwiLCBuZXdWcmVOYW1lOiB2YWx1ZX0pLFxuICAgIG9uU2V0TmV3RGVzY3JpcHRpb246ICh2YWx1ZSkgPT4gZGlzcGF0Y2goe3R5cGU6IFwiU0VUX0RFU0NSSVBUSU9OXCIsIGRlc2NyaXB0aW9uOiB2YWx1ZX0pLFxuICAgIG9uU2V0TmV3UHJvdmVuYW5jZTogKHZhbHVlKSA9PiBkaXNwYXRjaCh7dHlwZTogXCJTRVRfUFJPVkVOQU5DRVwiLCBwcm92ZW5hbmNlOiB2YWx1ZX0pLFxuICAgIG9uU2V0TmV3Q29sb3JDb2RlOiAodmFsdWUpID0+IGRpc3BhdGNoKHt0eXBlOiBcIlNFVF9DT0xPUl9DT0RFXCIsIGNvbG9yQ29kZTogdmFsdWV9KSxcbiAgICBvblVwbG9hZEltYWdlOiAodnJlSWQsIGZpbGVzKSA9PiBkaXNwYXRjaCh1cGxvYWRJbWFnZSh2cmVJZCwgZmlsZXMpKSxcbiAgICBvbkNsb3NlSW1hZ2VFcnJvcjogKCkgPT4gZGlzcGF0Y2goe3R5cGU6IFwiRElTTUlTU19JTUFHRV9FUlJPUlwifSksXG4gICAgb25TYXZlVnJlU2V0dGluZ3M6ICh2cmVJZCwgbmV4dCA9ICgpID0+IHt9KSA9PiBkaXNwYXRjaChzYXZlRGF0YXNldFNldHRpbmdzKHZyZUlkLCBuZXh0KSksXG5cbiAgICAvLyBGZXRjaGluZyByYXcgZGF0YVxuICAgIG9uU2VsZWN0Q29sbGVjdGlvbjogKGNvbGxlY3Rpb24pID0+IGRpc3BhdGNoKHNlbGVjdENvbGxlY3Rpb24oY29sbGVjdGlvbikpLFxuXG4gICAgb25Mb2FkTW9yZUNsaWNrOiAobmV4dFVybCwgY29sbGVjdGlvbikgPT4gZGlzcGF0Y2goc2VsZWN0Q29sbGVjdGlvbihjb2xsZWN0aW9uLCBuZXh0VXJsKSksXG5cbiAgICBvbkZldGNoQnVsa1VwbG9hZGVkTWV0YWRhdGE6ICh2cmVJZCkgPT4gZGlzcGF0Y2goZmV0Y2hCdWxrVXBsb2FkZWRNZXRhZGF0YSh2cmVJZCkpLFxuXG4gICAgLy8gQ2xvc2luZyBpbmZvcm1hdGl2ZSBtZXNzYWdlc1xuICAgIG9uQ2xvc2VNZXNzYWdlOiAobWVzc2FnZUlkKSA9PiBkaXNwYXRjaCh7dHlwZTogXCJUT0dHTEVfTUVTU0FHRVwiLCBtZXNzYWdlSWQ6IG1lc3NhZ2VJZH0pLFxuXG4gICAgLy8gRGVsZXRpbmcgb3duIHZyZXNcbiAgICBvbkRlbGV0ZVZyZUNsaWNrOiAodnJlSWQpID0+IGRpc3BhdGNoKHt0eXBlOiBcIlNIT1dfREVMRVRFX1ZSRV9NT0RBTFwiLCB2cmVJZDogdnJlSWR9KSxcblxuICAgIG9uQ29tZmlybURlbGV0ZVZyZTogKHZyZUlkLCB1c2VyQ29uZmlybWF0aW9uSW5wdXRWYWx1ZSkgPT4gZGlzcGF0Y2goZGVsZXRlVnJlKHZyZUlkLCB1c2VyQ29uZmlybWF0aW9uSW5wdXRWYWx1ZSkpLFxuXG4gICAgLy8gTWFwcGluZyBjb2xsZWN0aW9ucyBhcmNoZXR5cGVzXG4gICAgb25NYXBDb2xsZWN0aW9uQXJjaGV0eXBlOiAoY29sbGVjdGlvbiwgdmFsdWUpID0+XG4gICAgICBkaXNwYXRjaCh7dHlwZTogXCJNQVBfQ09MTEVDVElPTl9BUkNIRVRZUEVcIiwgY29sbGVjdGlvbjogY29sbGVjdGlvbiwgdmFsdWU6IHZhbHVlfSksXG5cblxuICAgIC8vIENvbm5lY3RpbmcgZGF0YVxuICAgIG9uQ29udGludWVNYXBwaW5nOiAodnJlSWQpID0+IGRpc3BhdGNoKGZldGNoQnVsa1VwbG9hZGVkTWV0YWRhdGEodnJlSWQsIG5hdmlnYXRlVG8pKSxcblxuICAgIG9uQWRkUHJlZGljYXRlT2JqZWN0TWFwOiAocHJlZGljYXRlTmFtZSwgb2JqZWN0TmFtZSwgcHJvcGVydHlUeXBlKSA9PlxuICAgICAgZGlzcGF0Y2goYWRkUHJlZGljYXRlT2JqZWN0TWFwKHByZWRpY2F0ZU5hbWUsIG9iamVjdE5hbWUsIHByb3BlcnR5VHlwZSkpLFxuXG4gICAgb25SZW1vdmVQcmVkaWNhdGVPYmplY3RNYXA6IChwcmVkaWNhdGVOYW1lLCBvYmplY3ROYW1lKSA9PiBkaXNwYXRjaChyZW1vdmVQcmVkaWNhdGVPYmplY3RNYXAocHJlZGljYXRlTmFtZSwgb2JqZWN0TmFtZSkpLFxuXG4gICAgb25BZGRDdXN0b21Qcm9wZXJ0eTogKG5hbWUsIHR5cGUsIHNvdXJjZUNvbHVtbiA9IG51bGwsIHRhcmdldENvbHVtbiA9IG51bGwpID0+XG4gICAgICBkaXNwYXRjaChhZGRDdXN0b21Qcm9wZXJ0eShuYW1lLCB0eXBlLCBzb3VyY2VDb2x1bW4sIHRhcmdldENvbHVtbikpLFxuXG4gICAgb25SZW1vdmVDdXN0b21Qcm9wZXJ0eTogKGluZGV4KSA9PiBkaXNwYXRjaChyZW1vdmVDdXN0b21Qcm9wZXJ0eShpbmRleCkpLFxuXG4gICAgb25TYXZlTWFwcGluZ1N0YXRlOiAoKSA9PiBkaXNwYXRjaChzYXZlTWFwcGluZ1N0YXRlKCkpLFxuXG4gICAgb25TYXZlTmV3TWFwcGluZ1N0YXRlOiAoKSA9PiBkaXNwYXRjaChzYXZlTmV3TWFwcGluZ1N0YXRlKG5hdmlnYXRlVG8pKSxcblxuICAgIG9uUHVibGlzaERhdGE6ICgpID0+IGRpc3BhdGNoKHB1Ymxpc2hNYXBwaW5ncyhuYXZpZ2F0ZVRvKSlcbiAgfTtcbn1cbiIsImltcG9ydCB4aHIgZnJvbSBcInhoclwiO1xuXG5jb25zdCBkZWxldGVWcmUgPSAodnJlSWQsIGNvbmZpcm1lZFZyZUlkKSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG5cbiAgaWYgKHZyZUlkICE9PSBjb25maXJtZWRWcmVJZCkgeyByZXR1cm47IH1cblxuICBjb25zdCB7XG4gICAgdXNlcmRhdGE6IHsgdXNlcklkIH0sXG4gIH0gPSBnZXRTdGF0ZSgpO1xuXG4gIGRpc3BhdGNoKHt0eXBlOiBcIkJFRk9SRV9ERUxFVEVfVlJFXCIsIHZyZUlkOiBjb25maXJtZWRWcmVJZH0pO1xuXG4gIHhocih7XG4gICAgdXJpOiBgJHtwcm9jZXNzLmVudi5zZXJ2ZXJ9L3YyLjEvYnVsay11cGxvYWQvJHtjb25maXJtZWRWcmVJZH1gLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQXV0aG9yaXphdGlvblwiOiB1c2VySWRcbiAgICB9LFxuICAgIG1ldGhvZDogXCJERUxFVEVcIlxuICB9LCAoZXJyLCByZXNwLCBib2R5KSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgZGlzcGF0Y2goe3R5cGU6IFwiREVMRVRFX1ZSRV9FUlJPUlwiLCBlcnI6IGVyciwgdnJlSWQ6IGNvbmZpcm1lZFZyZUlkfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXNwLnN0YXR1c0NvZGUgPT0gMjAwKSB7XG4gICAgICAgIGRpc3BhdGNoKHt0eXBlOiBcIkRFTEVURV9WUkVfU1VDQ0VTU1wiLCB2cmVJZDogY29uZmlybWVkVnJlSWR9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoKHt0eXBlOiBcIkRFTEVURV9WUkVfRVJST1JcIiwgdnJlSWQ6IGNvbmZpcm1lZFZyZUlkfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRpc3BhdGNoKHt0eXBlOiBcIkRFTEVURV9WUkVfRE9ORVwiLCB2cmVJZDogY29uZmlybWVkVnJlSWR9KTtcblxuICB9KTtcbn07XG5cbmV4cG9ydCB7IGRlbGV0ZVZyZSB9IiwiaW1wb3J0IHhociBmcm9tIFwieGhyXCI7XG5pbXBvcnQgeyBzZWxlY3RDb2xsZWN0aW9uIH0gZnJvbSBcIi4vc2VsZWN0LWNvbGxlY3Rpb25cIlxuaW1wb3J0IHsgZGVzZXJpYWxpemVTYXZlZFJtbE1hcHBpbmcgfSBmcm9tIFwiLi9wcmVkaWNhdGUtb2JqZWN0LW1hcHBpbmdzXCI7XG5cbmNvbnN0IGZldGNoQnVsa1VwbG9hZGVkTWV0YWRhdGEgPSAodnJlSWQsIG5hdmlnYXRlVG8pID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpICA9PiB7XG4gIGxldCBsb2NhdGlvbiA9IGAke3Byb2Nlc3MuZW52LnNlcnZlcn0vdjIuMS9idWxrLXVwbG9hZC8ke3ZyZUlkfWA7XG4gIHhoci5nZXQobG9jYXRpb24sIHtoZWFkZXJzOiB7XCJBdXRob3JpemF0aW9uXCI6IGdldFN0YXRlKCkudXNlcmRhdGEudXNlcklkfX0sIGZ1bmN0aW9uIChlcnIsIHJlc3AsIGJvZHkpIHtcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgIGRpc3BhdGNoKHt0eXBlOiBcIkZJTklTSF9VUExPQURcIiwgZGF0YTogcmVzcG9uc2VEYXRhfSk7XG5cbiAgICBpZiAocmVzcG9uc2VEYXRhLmNvbGxlY3Rpb25zICYmIHJlc3BvbnNlRGF0YS5jb2xsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGRpc3BhdGNoKHNlbGVjdENvbGxlY3Rpb24ocmVzcG9uc2VEYXRhLmNvbGxlY3Rpb25zWzBdLm5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2VEYXRhLnNhdmVkTWFwcGluZ1N0YXRlKSB7XG4gICAgICBkaXNwYXRjaChkZXNlcmlhbGl6ZVNhdmVkUm1sTWFwcGluZyhyZXNwb25zZURhdGEuc2F2ZWRNYXBwaW5nU3RhdGUpKTtcbiAgICB9XG5cbiAgICBpZiAobmF2aWdhdGVUbykge1xuICAgICAgaWYgKHJlc3BvbnNlRGF0YS5zYXZlZE1hcHBpbmdTdGF0ZSkge1xuICAgICAgICBuYXZpZ2F0ZVRvKFwibWFwRGF0YVwiLCBbdnJlSWRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdmlnYXRlVG8oXCJtYXBBcmNoZXR5cGVzXCIsIFt2cmVJZF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnQgeyBmZXRjaEJ1bGtVcGxvYWRlZE1ldGFkYXRhIH07IiwiaW1wb3J0IHhociBmcm9tIFwieGhyXCI7XG5cbmNvbnN0IGZldGNoTXlWcmVzID0gKHRva2VuLCBjYWxsYmFjaykgPT4gKGRpc3BhdGNoKSA9PiB7XG4gIHhocihwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL3N5c3RlbS91c2Vycy9tZS92cmVzXCIsIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkF1dGhvcml6YXRpb25cIjogdG9rZW5cbiAgICB9XG4gIH0sIChlcnIsIHJlc3AsIGJvZHkpID0+IHtcbiAgICBjb25zdCB2cmVEYXRhID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICBkaXNwYXRjaCh7dHlwZTogXCJSRUNFSVZFX01ZX1ZSRVNcIiwgZGF0YTogdG9rZW4sIHZyZURhdGE6IHZyZURhdGF9KTtcbiAgICBjYWxsYmFjayh2cmVEYXRhKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBmZXRjaE15VnJlcyB9IiwiaW1wb3J0IHtnZXRDb2x1bW5WYWx1ZX0gZnJvbSBcIi4uL2FjY2Vzc29ycy9wcm9wZXJ0eS1tYXBwaW5nc1wiO1xuaW1wb3J0IHtuYW1lU3BhY2VzfSBmcm9tIFwiLi4vdXRpbC9nZW5lcmF0ZS1ybWwtbWFwcGluZ1wiO1xuaW1wb3J0IHtkZWZhdWx0TmFtZXNwYWNlfSBmcm9tIFwiLi4vdXRpbC9nZW5lcmF0ZS1ybWwtbWFwcGluZ1wiO1xuXG5cbmNvbnN0IF9hZGRQcmVkaWNhdGVPYmplY3RNYXAgPSAoc3ViamVjdENvbGxlY3Rpb24sIHByZWRpY2F0ZSwgb2JqZWN0LCBwcm9wZXJ0eVR5cGUpID0+IChkaXNwYXRjaCkgPT4ge1xuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogXCJTRVRfUFJFRElDQVRFX09CSkVDVF9NQVBQSU5HXCIsXG4gICAgc3ViamVjdENvbGxlY3Rpb246IHN1YmplY3RDb2xsZWN0aW9uLFxuICAgIHByZWRpY2F0ZTogcHJlZGljYXRlLFxuICAgIG9iamVjdDogb2JqZWN0LFxuICAgIHByb3BlcnR5VHlwZTogcHJvcGVydHlUeXBlXG4gIH0pXG59O1xuXG5cbmNvbnN0IGFkZFByZWRpY2F0ZU9iamVjdE1hcCA9IChwcmVkaWNhdGUsIG9iamVjdCwgcHJvcGVydHlUeXBlKSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gIGNvbnN0IHthY3RpdmVDb2xsZWN0aW9uOiB7IG5hbWUgOiBzdWJqZWN0Q29sbGVjdGlvbiB9fSA9IGdldFN0YXRlKCk7XG5cbiAgZGlzcGF0Y2goX2FkZFByZWRpY2F0ZU9iamVjdE1hcChzdWJqZWN0Q29sbGVjdGlvbiwgcHJlZGljYXRlLCBvYmplY3QsIHByb3BlcnR5VHlwZSkpO1xufTtcblxuY29uc3QgcmVtb3ZlUHJlZGljYXRlT2JqZWN0TWFwID0gKHByZWRpY2F0ZSwgb2JqZWN0KSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gIGNvbnN0IHthY3RpdmVDb2xsZWN0aW9uOiB7IG5hbWUgOiBzdWJqZWN0Q29sbGVjdGlvbiB9fSA9IGdldFN0YXRlKCk7XG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IFwiUkVNT1ZFX1BSRURJQ0FURV9PQkpFQ1RfTUFQUElOR1wiLFxuICAgIHN1YmplY3RDb2xsZWN0aW9uOiBzdWJqZWN0Q29sbGVjdGlvbixcbiAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcbiAgICBvYmplY3Q6IG9iamVjdFxuICB9KTtcbn07XG5cbmNvbnN0IF9hZGRDdXN0b21Qcm9wZXJ0eSA9IChjb2xsZWN0aW9uTmFtZSwgbmFtZSwgdHlwZSwgc291cmNlQ29sdW1uID0gbnVsbCwgdGFyZ2V0Q29sdW1uID0gbnVsbCkgPT4gKGRpc3BhdGNoKSA9PiB7XG4gIGRpc3BhdGNoKHtcbiAgICB0eXBlOiBcIkFERF9DVVNUT01fUFJPUEVSVFlcIixcbiAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uTmFtZSxcbiAgICBwcm9wZXJ0eU5hbWU6IG5hbWUsXG4gICAgcHJvcGVydHlUeXBlOiB0eXBlXG4gIH0pO1xuXG4gIGlmICh0eXBlID09PSBcInJlbGF0aW9uXCIgJiYgc291cmNlQ29sdW1uICYmIHRhcmdldENvbHVtbikge1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IFwiU0VUX1BSRURJQ0FURV9PQkpFQ1RfTUFQUElOR1wiLFxuICAgICAgc3ViamVjdENvbGxlY3Rpb246IGNvbGxlY3Rpb25OYW1lLFxuICAgICAgcHJlZGljYXRlOiBuYW1lLFxuICAgICAgb2JqZWN0OiB7XG4gICAgICAgIGpvaW5Db25kaXRpb246IHtcbiAgICAgICAgICBjaGlsZDogc291cmNlQ29sdW1uLFxuICAgICAgICAgIHBhcmVudDogdGFyZ2V0Q29sdW1uLnNwbGl0KFwiIVwiKVsxXVxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRUcmlwbGVzTWFwOiB0YXJnZXRDb2x1bW4uc3BsaXQoXCIhXCIpWzBdXG4gICAgICB9LFxuICAgICAgcHJvcGVydHlUeXBlOiBcInJlbGF0aW9uXCJcbiAgICB9KTtcbiAgfVxufTtcblxuY29uc3QgYWRkQ3VzdG9tUHJvcGVydHkgPSAobmFtZSwgdHlwZSwgc291cmNlQ29sdW1uLCB0YXJnZXRDb2x1bW4pID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgY29uc3QgeyBhY3RpdmVDb2xsZWN0aW9uOiB7IG5hbWU6IGNvbGxlY3Rpb25OYW1lIH19ID0gZ2V0U3RhdGUoKTtcblxuICBkaXNwYXRjaChfYWRkQ3VzdG9tUHJvcGVydHkoY29sbGVjdGlvbk5hbWUsIG5hbWUsIHR5cGUsIHNvdXJjZUNvbHVtbiwgdGFyZ2V0Q29sdW1uKSk7XG59O1xuXG5jb25zdCByZW1vdmVDdXN0b21Qcm9wZXJ0eSA9IChpbmRleCkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICBjb25zdCB7XG4gICAgYWN0aXZlQ29sbGVjdGlvbjogeyBuYW1lOiBjb2xsZWN0aW9uTmFtZSB9LFxuICAgIHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzOiBhbGxQcmVkaWNhdGVPYmplY3RNYXBwaW5ncyxcbiAgICBjdXN0b21Qcm9wZXJ0aWVzOiBjdXN0b21Qcm9wZXJ0aWVzXG4gIH0gPSBnZXRTdGF0ZSgpO1xuXG4gIGNvbnN0IHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzID0gYWxsUHJlZGljYXRlT2JqZWN0TWFwcGluZ3NbY29sbGVjdGlvbk5hbWVdIHx8IFtdO1xuICBjb25zdCBjdXN0b21Qcm9wZXJ0eSA9IGN1c3RvbVByb3BlcnRpZXNbY29sbGVjdGlvbk5hbWVdW2luZGV4XTtcblxuICBjb25zdCBwcmVkaWNhdGVPYmplY3RNYXBwaW5nID0gcHJlZGljYXRlT2JqZWN0TWFwcGluZ3MuZmluZCgocG9tKSA9PiBwb20ucHJlZGljYXRlID09PSBjdXN0b21Qcm9wZXJ0eS5wcm9wZXJ0eU5hbWUpO1xuXG4gIGlmIChwcmVkaWNhdGVPYmplY3RNYXBwaW5nKSB7XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogXCJSRU1PVkVfUFJFRElDQVRFX09CSkVDVF9NQVBQSU5HXCIsXG4gICAgICBzdWJqZWN0Q29sbGVjdGlvbjogY29sbGVjdGlvbk5hbWUsXG4gICAgICBwcmVkaWNhdGU6IGN1c3RvbVByb3BlcnR5LnByb3BlcnR5TmFtZSxcbiAgICAgIG9iamVjdDogZ2V0Q29sdW1uVmFsdWUocHJlZGljYXRlT2JqZWN0TWFwcGluZylcbiAgICB9KTtcbiAgfVxuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogXCJSRU1PVkVfQ1VTVE9NX1BST1BFUlRZXCIsXG4gICAgY29sbGVjdGlvbjogY29sbGVjdGlvbk5hbWUsXG4gICAgaW5kZXg6IGluZGV4XG4gIH0pXG59O1xuXG5jb25zdCBzdHJpcE5hbWVzcGFjZSA9ICh1cmkpID0+IHtcbiAgY29uc3QgbnNMaXN0ID0gT2JqZWN0LmtleXMobmFtZVNwYWNlcykubWFwKChrKSA9PiBuYW1lU3BhY2VzW2tdKS5jb25jYXQoZGVmYXVsdE5hbWVzcGFjZSk7XG4gIGZvciAobGV0IGkgaW4gbnNMaXN0KSB7XG4gICAgaWYgKHVyaS5pbmRleE9mKG5zTGlzdFtpXSkgPiAtMSkge1xuICAgICAgcmV0dXJuIHVyaS5yZXBsYWNlKG5zTGlzdFtpXSwgXCJcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgZ2V0UHJvcGVydHlUeXBlID0gKHByZWRpY2F0ZSwga25vd25Qcm9wZXJ0aWVzKSA9PiB7XG4gIGlmIChuYW1lU3BhY2VzW3ByZWRpY2F0ZV0gPT09IFwiaHR0cDovL3d3dy50ZWktYy5vcmcvbnMvMS4wL1wiKSB7IHJldHVybiBcIm5hbWVzXCI7IH1cbiAgY29uc3Qga25vd25Qcm9wZXJ0eSA9IGtub3duUHJvcGVydGllcy5maW5kKChwcm9wKSA9PiBwcm9wLm5hbWUgPT09IHByZWRpY2F0ZSk7XG5cbiAgaWYgKGtub3duUHJvcGVydHkpIHtcbiAgICByZXR1cm4ga25vd25Qcm9wZXJ0eS50eXBlO1xuICB9XG4gIHJldHVybiBcInRleHRcIjtcbn07XG5cbmNvbnN0IGRlc2VyaWFsaXplU2F2ZWRSbWxNYXBwaW5nID0gKHNhdmVkTWFwcGluZ3MpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgY29uc3QgZ3JhcGggPSBzYXZlZE1hcHBpbmdzW1wiQGdyYXBoXCJdO1xuICBjb25zdCB7IGFyY2hldHlwZSA6IGFyY2hldHlwZVByb3BlcnRpZXMgfSA9IGdldFN0YXRlKCk7XG5cbiAgZm9yIChsZXQgaSBpbiBncmFwaCkge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25NYXBwaW5nID0gZ3JhcGhbaV07XG4gICAgY29uc3QgY29sbGVjdGlvbk5hbWUgPSBjb2xsZWN0aW9uTWFwcGluZ1tcInJtbDpsb2dpY2FsU291cmNlXCJdW1wicm1sOnNvdXJjZVwiXVtcInRpbTpyYXdDb2xsZWN0aW9uXCJdO1xuICAgIGNvbnN0IGFyY2hldHlwZU5hbWUgPSBzdHJpcE5hbWVzcGFjZShjb2xsZWN0aW9uTWFwcGluZ1tcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDEvcmRmLXNjaGVtYSNzdWJDbGFzc09mXCJdKSArIFwic1wiO1xuXG4gICAgZGlzcGF0Y2goe3R5cGU6IFwiTUFQX0NPTExFQ1RJT05fQVJDSEVUWVBFXCIsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb25OYW1lLCB2YWx1ZTogYXJjaGV0eXBlTmFtZX0pO1xuXG4gICAgY29uc3Qga25vd25Qcm9wZXJ0aWVzID0gYXJjaGV0eXBlUHJvcGVydGllc1thcmNoZXR5cGVOYW1lXVxuICAgICAgLmZpbHRlcigocHJvcCkgPT4gcHJvcC50eXBlICE9PSBcInJlbGF0aW9uXCIpXG4gICAgICAuY29uY2F0KHtuYW1lOiBcInNhbWVBc1wiLCB0eXBlOiBcInNhbWVBc1wifSk7XG5cbiAgICBjb2xsZWN0aW9uTWFwcGluZy5wcmVkaWNhdGVPYmplY3RNYXAuZm9yRWFjaCgocHJlZGljYXRlT2JqZWN0TWFwcGluZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGVPYmplY3RNYXBwaW5nLm9iamVjdE1hcCA9PT0gXCJ1bmRlZmluZWRcIikgeyByZXR1cm47IH1cbiAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHN0cmlwTmFtZXNwYWNlKHByZWRpY2F0ZU9iamVjdE1hcHBpbmcucHJlZGljYXRlKTtcbiAgICAgIGNvbnN0IHsgb2JqZWN0TWFwIH0gPSBwcmVkaWNhdGVPYmplY3RNYXBwaW5nO1xuXG4gICAgICBpZiAob2JqZWN0TWFwLmNvbHVtbikge1xuICAgICAgICBkaXNwYXRjaChfYWRkUHJlZGljYXRlT2JqZWN0TWFwKGNvbGxlY3Rpb25OYW1lLCBwcmVkaWNhdGUsIG9iamVjdE1hcC5jb2x1bW4sIGdldFByb3BlcnR5VHlwZShwcmVkaWNhdGUsIGtub3duUHJvcGVydGllcykpKTtcblxuICAgICAgICBpZiAoZ2V0UHJvcGVydHlUeXBlKHByZWRpY2F0ZSwga25vd25Qcm9wZXJ0aWVzKSAhPT0gXCJuYW1lc1wiICYmIGtub3duUHJvcGVydGllcy5tYXAoKHByb3ApID0+IHByb3AubmFtZSkuaW5kZXhPZihwcmVkaWNhdGUpIDwgMCkge1xuICAgICAgICAgIGRpc3BhdGNoKF9hZGRDdXN0b21Qcm9wZXJ0eShjb2xsZWN0aW9uTmFtZSwgcHJlZGljYXRlLCBcInRleHRcIikpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0TWFwLmpvaW5Db25kaXRpb24gJiYgb2JqZWN0TWFwLnBhcmVudFRyaXBsZXNNYXApIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q29sbGVjdGlvbiA9IHN0cmlwTmFtZXNwYWNlKG9iamVjdE1hcC5wYXJlbnRUcmlwbGVzTWFwKS5yZXBsYWNlKC8uK1xcLy8sXCJcIilcbiAgICAgICAgZGlzcGF0Y2goX2FkZEN1c3RvbVByb3BlcnR5KGNvbGxlY3Rpb25OYW1lLCBwcmVkaWNhdGUsIFwicmVsYXRpb25cIiwgb2JqZWN0TWFwLmpvaW5Db25kaXRpb24uY2hpbGQsIGAke3RhcmdldENvbGxlY3Rpb259ISR7b2JqZWN0TWFwLmpvaW5Db25kaXRpb24ucGFyZW50fWApKTtcbiAgICAgIH1cbiAgICB9KVxuXG4gIH1cbn07XG5cbmV4cG9ydCB7IGFkZFByZWRpY2F0ZU9iamVjdE1hcCwgcmVtb3ZlUHJlZGljYXRlT2JqZWN0TWFwLCBhZGRDdXN0b21Qcm9wZXJ0eSwgcmVtb3ZlQ3VzdG9tUHJvcGVydHksIGRlc2VyaWFsaXplU2F2ZWRSbWxNYXBwaW5nIH1cbiIsImltcG9ydCBnZW5lcmF0ZVJtbE1hcHBpbmcgZnJvbSBcIi4uL3V0aWwvZ2VuZXJhdGUtcm1sLW1hcHBpbmdcIjtcbmltcG9ydCB7ZmV0Y2hNeVZyZXN9IGZyb20gXCIuL2ZldGNoLW15LXZyZXNcIjtcbmltcG9ydCB4aHIgZnJvbSBcInhoclwiXG5pbXBvcnQge3NlbGVjdENvbGxlY3Rpb259IGZyb20gXCIuL3NlbGVjdC1jb2xsZWN0aW9uXCI7XG5cbmNvbnN0IHNhdmVNYXBwaW5nU3RhdGUgPSAobmF2aWdhdGVUbyA9IG51bGwsIHJlZGlyZWN0VG8gPSBudWxsKSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBpbXBvcnREYXRhOiB7IHZyZSwgc2F2ZU1hcHBpbmdVcmwgfSxcbiAgICBtYXBwaW5nczogeyBjb2xsZWN0aW9ucyB9LFxuICAgIHVzZXJkYXRhOiB7IHVzZXJJZCB9LFxuICAgIHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzXG4gIH0gPSBnZXRTdGF0ZSgpO1xuXG4gIGNvbnN0IGpzb25MZCA9IGdlbmVyYXRlUm1sTWFwcGluZyh2cmUsIGNvbGxlY3Rpb25zLCBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncyk7XG4gIGRpc3BhdGNoKHt0eXBlOiBcIlNBVkVfTUFQUElOR19TVEFSVFwifSk7XG4gIHhocih7XG4gICAgdXJsOiBzYXZlTWFwcGluZ1VybCxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQXV0aG9yaXphdGlvblwiOiB1c2VySWQsXG4gICAgICBcIkNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2xkK2pzb25cIlxuICAgIH0sXG4gICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoanNvbkxkKVxuICB9LCAoZXJyLCByZXNwLCBib2R5KSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgZGlzcGF0Y2goe3R5cGU6IFwiU0FWRV9IQURfRVJST1JcIn0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwYXRjaCh7dHlwZTogXCJTQVZFX1NVQ0NFRURFRFwifSk7XG4gICAgICBpZiAocmVkaXJlY3RUbykge1xuICAgICAgICBuYXZpZ2F0ZVRvKHJlZGlyZWN0VG8sIFt2cmUsIFwiYXNkXCJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGF0Y2goe3R5cGU6IFwiU0FWRV9GSU5JU0hFRFwifSk7XG4gIH0pXG59O1xuXG5jb25zdCBwdWJsaXNoTWFwcGluZ3MgPSAobmF2aWdhdGVUbykgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICBjb25zdCB7XG4gICAgaW1wb3J0RGF0YTogeyB2cmUsIGV4ZWN1dGVNYXBwaW5nVXJsIH0sXG4gICAgbWFwcGluZ3M6IHsgY29sbGVjdGlvbnMgfSxcbiAgICB1c2VyZGF0YTogeyB1c2VySWQgfSxcbiAgICBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncyxcbiAgICBhY3RpdmVDb2xsZWN0aW9uXG4gIH0gPSBnZXRTdGF0ZSgpO1xuXG4gIGNvbnN0IGpzb25MZCA9IGdlbmVyYXRlUm1sTWFwcGluZyh2cmUsIGNvbGxlY3Rpb25zLCBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncyk7XG5cbiAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoanNvbkxkLCBudWxsLCAyKSk7XG5cbiAgZGlzcGF0Y2goc2F2ZU1hcHBpbmdTdGF0ZSgpKTtcbiAgZGlzcGF0Y2goe3R5cGU6IFwiUFVCTElTSF9TVEFSVFwifSk7XG4gIGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXEub3BlbihcIlBPU1RcIiwgZXhlY3V0ZU1hcHBpbmdVcmwpO1xuICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkF1dGhvcml6YXRpb25cIiwgdXNlcklkKTtcbiAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9sZCtqc29uXCIpO1xuXG4gIGxldCBwb3MgPSAwO1xuICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlRGF0YSgpIHtcbiAgICBpZiAocmVxLnJlYWR5U3RhdGUgIT0gbnVsbCAmJiAocmVxLnJlYWR5U3RhdGUgPCAzIHx8IHJlcS5zdGF0dXMgIT0gMjAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdQYXJ0ID0gcmVxLnJlc3BvbnNlVGV4dC5zdWJzdHIocG9zKTtcbiAgICBwb3MgPSByZXEucmVzcG9uc2VUZXh0Lmxlbmd0aDtcbiAgICBuZXdQYXJ0LnNwbGl0KFwiXFxuXCIpLmZvckVhY2goKGxpbmUsIGlkeCkgPT4ge1xuICAgICAgaWYgKGlkeCAlIDEyNSA9PT0gMCAmJiBsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGlzcGF0Y2goe3R5cGU6IFwiUFVCTElTSF9TVEFUVVNfVVBEQVRFXCIsIGRhdGE6IGxpbmV9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHJlcS5yZXNwb25zZVRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdID09PSBcInN1Y2Nlc3NcIikge1xuICAgICAgZGlzcGF0Y2goe3R5cGU6IFwiUFVCTElTSF9TVUNDRUVERURcIn0pO1xuICAgICAgZGlzcGF0Y2goZmV0Y2hNeVZyZXModXNlcklkLCAoKSA9PiBuYXZpZ2F0ZVRvKFwicm9vdFwiKSkpO1xuICAgICAgeGhyLmdldChwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL3N5c3RlbS92cmVzXCIsIChlcnIsIHJlc3AsIGJvZHkpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe3R5cGU6IFwiU0VUX1BVQkxJQ19WUkVTXCIsIHBheWxvYWQ6IEpTT04ucGFyc2UoYm9keSl9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwYXRjaCh7dHlwZTogXCJQVUJMSVNIX0hBRF9FUlJPUlwifSk7XG4gICAgICBkaXNwYXRjaChzZWxlY3RDb2xsZWN0aW9uKGFjdGl2ZUNvbGxlY3Rpb24ubmFtZSwgbnVsbCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGRpc3BhdGNoKHt0eXBlOiBcIlBVQkxJU0hfRklOSVNIRURcIn0pO1xuICB9O1xuICByZXEuc2VuZChKU09OLnN0cmluZ2lmeShqc29uTGQpKTtcbn07XG5cbmNvbnN0IHNhdmVOZXdNYXBwaW5nU3RhdGUgPSAobmF2aWdhdGVUbykgPT4gKGRpc3BhdGNoKSA9PiB7XG4gIGRpc3BhdGNoKHt0eXBlOiBcIkNMRUFSX1BSRURJQ0FURV9PQkpFQ1RfTUFQUElOR1NcIn0pO1xuXG4gIGRpc3BhdGNoKHNhdmVNYXBwaW5nU3RhdGUobmF2aWdhdGVUbywgXCJtYXBEYXRhXCIpKTtcbn07XG5cbmV4cG9ydCB7IHB1Ymxpc2hNYXBwaW5ncywgc2F2ZU1hcHBpbmdTdGF0ZSwgc2F2ZU5ld01hcHBpbmdTdGF0ZSB9XG4iLCJpbXBvcnQgeGhyIGZyb20gXCJ4aHJcIjtcblxuY29uc3Qgc2VsZWN0Q29sbGVjdGlvbiA9IChjb2xsZWN0aW9uLCBhbHRVcmwgPSBudWxsLCBvbmx5RXJyb3JzID0gZmFsc2UpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgY29uc3QgeyBpbXBvcnREYXRhOiB7IGNvbGxlY3Rpb25zIH0sIHVzZXJkYXRhOiB7IHVzZXJJZCB9fSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IHNlbGVjdGVkQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zLmZpbmQoKGNvbCkgPT4gY29sLm5hbWUgPT09IGNvbGxlY3Rpb24pO1xuXG4gIGlmICh1c2VySWQgJiYgY29sbGVjdGlvbnMgJiYgc2VsZWN0ZWRDb2xsZWN0aW9uICYmIHNlbGVjdGVkQ29sbGVjdGlvbi5kYXRhVXJsKSB7XG4gICAgZGlzcGF0Y2goe3R5cGU6IFwiQUNUSVZFX0NPTExFQ1RJT05fUEVORElOR1wifSk7XG4gICAgeGhyLmdldCgoYWx0VXJsIHx8IHNlbGVjdGVkQ29sbGVjdGlvbi5kYXRhVXJsKSArIChvbmx5RXJyb3JzID8gXCI/b25seUVycm9ycz10cnVlXCIgOiBcIlwiKSwge1xuICAgICAgaGVhZGVyczogeyBcIkF1dGhvcml6YXRpb25cIjogdXNlcklkIH1cbiAgICB9LCAoZXJyLCByZXNwLCBib2R5KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRpc3BhdGNoKHt0eXBlOiBcIkFDVElWRV9DT0xMRUNUSU9OX0ZFVENIX0VSUk9SXCIsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIGVycm9yOiBlcnJ9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGlzcGF0Y2goe3R5cGU6IFwiUkVDRUlWRV9BQ1RJVkVfQ09MTEVDVElPTlwiLCBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLCBkYXRhOiBKU09OLnBhcnNlKGJvZHkpfSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIGRpc3BhdGNoKHt0eXBlOiBcIkFDVElWRV9DT0xMRUNUSU9OX0ZFVENIX0VSUk9SXCIsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sIGVycm9yOiBlfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGlzcGF0Y2goe3R5cGU6IFwiQUNUSVZFX0NPTExFQ1RJT05fRE9ORVwifSk7XG4gICAgfSk7XG4gIH1cbn07XG5cblxuZXhwb3J0IHsgc2VsZWN0Q29sbGVjdGlvbiB9IiwiaW1wb3J0IHhociBmcm9tIFwieGhyXCI7XG5pbXBvcnQgeyBzZWxlY3RDb2xsZWN0aW9uIH0gZnJvbSBcIi4vc2VsZWN0LWNvbGxlY3Rpb25cIjtcbmltcG9ydCB7IGZldGNoTXlWcmVzIH0gZnJvbSBcIi4vZmV0Y2gtbXktdnJlc1wiO1xuXG5cbmNvbnN0IG9uVXBsb2FkRmlsZVNlbGVjdCA9IChuYXZpZ2F0ZVRvLCBkaXNwYXRjaCkgPT4gKGZpbGVzLCB7IHZyZU5hbWUsIHZyZUlkLCByZWRpcmVjdFRvIH0pID0+IHtcblxuICBsZXQgZmlsZSA9IGZpbGVzWzBdO1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgaWYgKCF2cmVJZCAmJiB2cmVOYW1lKSB7XG4gICAgLy8gU2V0IGEgbmFtZSBvbiBmaXJzdCB1cGxvYWRcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJ2cmVOYW1lXCIsIHZyZU5hbWUpO1xuICB9IGVsc2UgaWYgKHZyZUlkKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJldXBsb2FkXG4gICAgZm9ybURhdGEuYXBwZW5kKFwidnJlSWRcIiwgdnJlSWQpO1xuICB9XG4gIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSk7XG5cbiAgZGlzcGF0Y2goe3R5cGU6IFwiU1RBUlRfVVBMT0FEXCIsIHVwbG9hZGVkRmlsZU5hbWU6IGZpbGUubmFtZX0pO1xuICBkaXNwYXRjaChmdW5jdGlvbiAoZGlzcGF0Y2gsIGdldFN0YXRlKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgaWYgKHZyZUlkKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgcmUtdXBsb2FkIG9mIHRoZSBkYXRhXG4gICAgICByZXEub3BlbignUFVUJywgcHJvY2Vzcy5lbnYuc2VydmVyICsgXCIvdjIuMS9idWxrLXVwbG9hZFwiLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxLm9wZW4oJ1BPU1QnLCBwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL2J1bGstdXBsb2FkXCIsIHRydWUpO1xuICAgIH1cbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkF1dGhvcml6YXRpb25cIiwgc3RhdGUudXNlcmRhdGEudXNlcklkKTtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgaXNSZWRpcmVjdGVkVG9TZXR0aW5ncyA9IGZhbHNlO1xuICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVEYXRhKCkge1xuICAgICAgaWYgKCFpc1JlZGlyZWN0ZWRUb1NldHRpbmdzKSB7XG4gICAgICAgIGlzUmVkaXJlY3RlZFRvU2V0dGluZ3MgPSB0cnVlO1xuICAgICAgICBkaXNwYXRjaChmZXRjaE15VnJlcyhzdGF0ZS51c2VyZGF0YS51c2VySWQsICh2cmVEYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKHZyZUlkKSB7XG4gICAgICAgICAgICBuYXZpZ2F0ZVRvKHJlZGlyZWN0VG8gfHwgXCJlZGl0RGF0YXNldFwiLCBbdnJlSWRdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZyZU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZyZUlkRnJvbUxhYmVsID0gT2JqZWN0LmtleXModnJlRGF0YS5taW5lKVxuICAgICAgICAgICAgICAubWFwKGtleSA9PiB2cmVEYXRhLm1pbmVba2V5XSkuZmluZCh2cmUgPT4gdnJlLmxhYmVsID09PSB2cmVOYW1lKS5uYW1lO1xuICAgICAgICAgICAgbmF2aWdhdGVUbyhyZWRpcmVjdFRvIHx8IFwiZWRpdERhdGFzZXRcIiwgW3ZyZUlkRnJvbUxhYmVsXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBpZiAocmVxLnJlYWR5U3RhdGUgIT0gbnVsbCAmJiAocmVxLnJlYWR5U3RhdGUgPCAzIHx8IHJlcS5zdGF0dXMgIT0gMjAwKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBuZXdQYXJ0ID0gcmVxLnJlc3BvbnNlVGV4dC5zdWJzdHIocG9zKTtcbiAgICAgIHBvcyA9IHJlcS5yZXNwb25zZVRleHQubGVuZ3RoO1xuICAgICAgbmV3UGFydC5zcGxpdChcIlxcblwiKS5mb3JFYWNoKChsaW5lLCBpZHgpID0+IHtcbiAgICAgICAgaWYgKGlkeCAlIDIxID09PSAwKSB7IGRpc3BhdGNoKHt0eXBlOiBcIlVQTE9BRF9TVEFUVVNfVVBEQVRFXCIsIGRhdGE6IGxpbmV9KTsgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgbG9jYXRpb24gPSByZXEuZ2V0UmVzcG9uc2VIZWFkZXIoXCJsb2NhdGlvblwiKTtcbiAgICAgIHhoci5nZXQobG9jYXRpb24sIHtoZWFkZXJzOiB7XCJBdXRob3JpemF0aW9uXCI6IHN0YXRlLnVzZXJkYXRhLnVzZXJJZH19LCBmdW5jdGlvbiAoZXJyLCByZXNwLCBib2R5KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgIGRpc3BhdGNoKHt0eXBlOiBcIkZJTklTSF9VUExPQURcIiwgZGF0YTogcmVzcG9uc2VEYXRhLCB1cGxvYWRlZEZpbGVOYW1lOiBmaWxlLm5hbWV9KTtcbiAgICAgICAgZGlzcGF0Y2goZmV0Y2hNeVZyZXMoc3RhdGUudXNlcmRhdGEudXNlcklkLCAoKSA9PiB7IH0pKTtcbiAgICAgICAgeGhyLmdldChwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL3N5c3RlbS92cmVzXCIsIChlcnIsIHJlc3AsIGJvZHkpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaCh7dHlwZTogXCJTRVRfUFVCTElDX1ZSRVNcIiwgcGF5bG9hZDogSlNPTi5wYXJzZShib2R5KX0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlRGF0YS5jb2xsZWN0aW9ucyAmJiByZXNwb25zZURhdGEuY29sbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgZGlzcGF0Y2goc2VsZWN0Q29sbGVjdGlvbihyZXNwb25zZURhdGEuY29sbGVjdGlvbnNbMF0ubmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJlcS5zZW5kKGZvcm1EYXRhKTtcbiAgfSk7XG59O1xuXG5jb25zdCB1cGxvYWRJbWFnZSA9ICh2cmVJZCwgZmlsZXMpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgY29uc3QgeyB1c2VyZGF0YTogeyB1c2VySWQgfSB9ID0gZ2V0U3RhdGUoKTtcblxuICBjb25zdCBmaWxlID0gZmlsZXNbMF07XG4gIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSk7XG5cbiAgcmVxLm9wZW4oJ1BPU1QnLCBgJHtwcm9jZXNzLmVudi5zZXJ2ZXJ9L3YyLjEvYnVsay11cGxvYWQvJHt2cmVJZH0vaW1hZ2VgLCB0cnVlKTtcbiAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJBdXRob3JpemF0aW9uXCIsIHVzZXJJZCk7XG4gIGRpc3BhdGNoKHt0eXBlOiBcIklNQUdFX1VQTE9BRF9TVEFSVEVEXCJ9KTtcbiAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA+PSAzMDAgfHwgdGhpcy5zdGF0dXMgPCAyMDApIHtcbiAgICAgIGRpc3BhdGNoKHt0eXBlOiBcIklNQUdFX1VQTE9BRF9FUlJPUlwiLCBtZXNzYWdlOiB0aGlzLnJlc3BvbnNlVGV4dH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwYXRjaCh7dHlwZTogXCJJTUFHRV9VUExPQURfU1VDQ0VTU1wifSk7XG4gICAgICBkaXNwYXRjaChmZXRjaE15VnJlcyh1c2VySWQsICgpID0+IHsgfSkpO1xuICAgICAgeGhyLmdldChwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL3N5c3RlbS92cmVzXCIsIChlcnIsIHJlc3AsIGJvZHkpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goe3R5cGU6IFwiU0VUX1BVQkxJQ19WUkVTXCIsIHBheWxvYWQ6IEpTT04ucGFyc2UoYm9keSl9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaCh7dHlwZTogXCJJTUFHRV9VUExPQURfRklOSVNIRURcIn0pO1xuICB9O1xuXG4gIHJlcS5zZW5kKGZvcm1EYXRhKTtcblxufTtcblxuY29uc3Qgc2F2ZURhdGFzZXRTZXR0aW5ncyA9ICh2cmVJZCwgbmV4dCA9ICgpID0+IHt9KSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gIGNvbnN0IHsgZGF0YXNldFNldHRpbmdzLCB1c2VyZGF0YTogeyB1c2VySWQgfSB9ID0gZ2V0U3RhdGUoKTtcbiAgeGhyKHtcbiAgICB1cmw6IGAke3Byb2Nlc3MuZW52LnNlcnZlcn0vdjIuMS9idWxrLXVwbG9hZC8ke3ZyZUlkfWAsXG4gICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJBdXRob3JpemF0aW9uXCI6IHVzZXJJZFxuICAgIH0sXG4gICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbGFiZWw6IGRhdGFzZXRTZXR0aW5ncy5uZXdWcmVOYW1lLFxuICAgICAgcHJvdmVuYW5jZTogZGF0YXNldFNldHRpbmdzLnByb3ZlbmFuY2UsXG4gICAgICBjb2xvckNvZGU6IGRhdGFzZXRTZXR0aW5ncy5jb2xvckNvZGUsXG4gICAgICBkZXNjcmlwdGlvbjogZGF0YXNldFNldHRpbmdzLmRlc2NyaXB0aW9uXG4gICAgfSlcbiAgfSwgKGVyciwgcmVzcCwgYm9keSkgPT4ge1xuICAgIGRpc3BhdGNoKGZldGNoTXlWcmVzKHVzZXJJZCwgKCkgPT4geyB9KSk7XG4gICAgeGhyLmdldChwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL3N5c3RlbS92cmVzXCIsIChlcnIsIHJlc3AsIGJvZHkpID0+IHtcbiAgICAgIGRpc3BhdGNoKHt0eXBlOiBcIlNFVF9QVUJMSUNfVlJFU1wiLCBwYXlsb2FkOiBKU09OLnBhcnNlKGJvZHkpfSk7XG4gICAgfSk7XG4gICAgbmV4dCgpO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IG9uVXBsb2FkRmlsZVNlbGVjdCwgc2F2ZURhdGFzZXRTZXR0aW5ncywgdXBsb2FkSW1hZ2UgfTsiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgU2VsZWN0RmllbGQgZnJvbSBcIi4uL2ZpZWxkcy9zZWxlY3QtZmllbGRcIjtcblxuY2xhc3MgQWRkUHJvcGVydHkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG5ld05hbWU6IFwiXCIsXG4gICAgICBuZXdUeXBlOiBudWxsXG4gICAgfTtcbiAgfVxuXG5cbiAgb25FbnRlcihuZXdOYW1lLCBuZXdUeXBlKSB7XG4gICAgaWYgKG5ld1R5cGUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe25ld05hbWU6IG51bGwsIG5ld1R5cGU6IG51bGx9KTtcbiAgICAgIHRoaXMucHJvcHMub25BZGRDdXN0b21Qcm9wZXJ0eShuZXdOYW1lLCBuZXdUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBuZXdOYW1lLCBuZXdUeXBlIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgb25BZGRDdXN0b21Qcm9wZXJ0eSB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyBzbWFsbC1tYXJnaW5cIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMiBwYWQtNi0xMlwiPlxuICAgICAgICAgIDxzdHJvbmc+QWRkIGEgbmV3IHByb3BlcnR5PC9zdHJvbmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS02XCIgPlxuICAgICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgPFNlbGVjdEZpZWxkXG4gICAgICAgICAgICAgIHZhbHVlPXtuZXdUeXBlfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiB0aGlzLnNldFN0YXRlKHtuZXdUeXBlOiB2YWx1ZSwgbmV3TmFtZTogbmV3TmFtZX0pfVxuICAgICAgICAgICAgICBvbkNsZWFyPXsoKSA9PiB0aGlzLnNldFN0YXRlKHtuZXdUeXBlOiBudWxsfSl9PlxuICAgICAgICAgICAgICA8c3BhbiB0eXBlPVwicGxhY2Vob2xkZXJcIj5DaG9vc2UgYSB0eXBlLi4uPC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiB2YWx1ZT1cInRleHRcIj5UZXh0PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiB2YWx1ZT1cImRhdGFibGVcIj5EYXRhYmxlPC9zcGFuPlxuICAgICAgICAgICAgPC9TZWxlY3RGaWVsZD5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0yXCI+XG4gICAgICAgICAgPGlucHV0IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGV2KSA9PiB0aGlzLnNldFN0YXRlKHtuZXdOYW1lOiBldi50YXJnZXQudmFsdWV9KX1cbiAgICAgICAgICAgICAgICAgIG9uS2V5UHJlc3M9eyhldikgPT4gZXYua2V5ID09PSBcIkVudGVyXCIgPyB0aGlzLm9uRW50ZXIobmV3TmFtZSwgbmV3VHlwZSkgOiBmYWxzZX1cbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUHJvcGVydHkgbmFtZVwiXG4gICAgICAgICAgICAgICAgICB2YWx1ZT17bmV3TmFtZX0gLz5cbiAgICAgICAgPC9kaXY+XG5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0yXCI+XG5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInB1bGwtcmlnaHQgYnRuIGJ0bi1kZWZhdWx0XCIgZGlzYWJsZWQ9eyEobmV3TmFtZSAmJiBuZXdUeXBlKX1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bmV3TmFtZTogbnVsbCwgbmV3VHlwZTogbnVsbH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkFkZEN1c3RvbVByb3BlcnR5KG5ld05hbWUsIG5ld1R5cGUpO1xuICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICBBZGQgcHJvcGVydHlcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWRkUHJvcGVydHk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgU2VsZWN0RmllbGQgZnJvbSBcIi4uL2ZpZWxkcy9zZWxlY3QtZmllbGRcIjtcbmltcG9ydCBDb2x1bW5TZWxlY3QgZnJvbSBcIi4vY29sdW1uLXNlbGVjdFwiO1xuXG5jbGFzcyBBZGRSZWxhdGlvbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbmV3UmVsYXRpb246IG51bGwsXG4gICAgICBzZWxlY3RlZFNvdXJjZUNvbHVtbjogbnVsbCxcbiAgICAgIHNlbGVjdGVkVGFyZ2V0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbmV3UmVsYXRpb24sIHNlbGVjdGVkU291cmNlQ29sdW1uLCBzZWxlY3RlZFRhcmdldENvbHVtbiB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IG9uQWRkQ3VzdG9tUHJvcGVydHksIGFyY2hldHlwZUZpZWxkcywgYXZhaWxhYmxlQXJjaGV0eXBlcywgY29sdW1ucywgYXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCByZWxhdGlvblR5cGVPcHRpb25zID0gYXJjaGV0eXBlRmllbGRzXG4gICAgICAuZmlsdGVyKChwcm9wKSA9PiBwcm9wLnR5cGUgPT09IFwicmVsYXRpb25cIilcbiAgICAgIC5maWx0ZXIoKHByb3ApID0+IGF2YWlsYWJsZUFyY2hldHlwZXMuaW5kZXhPZihwcm9wLnJlbGF0aW9uLnRhcmdldENvbGxlY3Rpb24pID4gLTEpXG4gICAgICAubWFwKChwcm9wKSA9PiA8c3BhbiBrZXk9e3Byb3AubmFtZX0gdmFsdWU9e3Byb3AubmFtZX0+e3Byb3AubmFtZX08L3NwYW4+KTtcblxuICAgIGNvbnN0IHJlbGF0aW9uVHlwZUluZm8gPSBuZXdSZWxhdGlvblxuICAgICAgPyBhcmNoZXR5cGVGaWVsZHMuZmluZCgoYWYpID0+IGFmLm5hbWUgPT09IG5ld1JlbGF0aW9uKVxuICAgICAgOiBudWxsO1xuXG4gICAgY29uc3QgdGFyZ2V0Q29sbGVjdGlvbkNvbHVtbnMgPSByZWxhdGlvblR5cGVJbmZvXG4gICAgICA/IGF2YWlsYWJsZUNvbGxlY3Rpb25Db2x1bW5zUGVyQXJjaGV0eXBlW3JlbGF0aW9uVHlwZUluZm8ucmVsYXRpb24udGFyZ2V0Q29sbGVjdGlvbl1cbiAgICAgICAgICAubWFwKCh0YXJnZXRDb2xsZWN0aW9uQ29scykgPT4gdGFyZ2V0Q29sbGVjdGlvbkNvbHMuY29sdW1ucy5tYXAoKGNvbHVtbikgPT4gYCR7dGFyZ2V0Q29sbGVjdGlvbkNvbHMuY29sbGVjdGlvbk5hbWV9ISR7Y29sdW1ufWApKVxuICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKSA6IG51bGw7XG5cbiAgICBjb25zdCB0YXJnZXRDb2x1bW5TZWxlY3QgPSB0YXJnZXRDb2xsZWN0aW9uQ29sdW1uc1xuICAgICAgPyA8Q29sdW1uU2VsZWN0IGNvbHVtbnM9e3RhcmdldENvbGxlY3Rpb25Db2x1bW5zfSBzZWxlY3RlZENvbHVtbj17c2VsZWN0ZWRUYXJnZXRDb2x1bW59XG4gICAgICAgICAgdmFsdWVQcmVmaXg9XCIodGFyZ2V0KSBcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VsZWN0IGEgdGFyZ2V0IGNvbHVtbi4uLlwiXG4gICAgICAgICAgb25DbGVhckNvbHVtbj17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7c2VsZWN0ZWRUYXJnZXRDb2x1bW46IG51bGx9KX1cbiAgICAgICAgICBvbkNvbHVtblNlbGVjdD17KGNvbHVtbikgPT4gdGhpcy5zZXRTdGF0ZSh7c2VsZWN0ZWRUYXJnZXRDb2x1bW46IGNvbHVtbn0pfSAvPlxuICAgICAgOiBudWxsO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93IHNtYWxsLW1hcmdpblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0yIHBhZC02LTEyXCI+XG4gICAgICAgICAgPHN0cm9uZz5BZGQgYSByZWxhdGlvbjwvc3Ryb25nPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tM1wiPlxuICAgICAgICAgIDxDb2x1bW5TZWxlY3QgY29sdW1ucz17Y29sdW1uc30gc2VsZWN0ZWRDb2x1bW49e3NlbGVjdGVkU291cmNlQ29sdW1ufVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVQcmVmaXg9XCIoc291cmNlKSBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJTZWxlY3QgYSBzb3VyY2UgY29sdW1uLi4uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xlYXJDb2x1bW49eygpID0+IHRoaXMuc2V0U3RhdGUoe3NlbGVjdGVkU291cmNlQ29sdW1uOiBudWxsfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbHVtblNlbGVjdD17KGNvbHVtbikgPT4gdGhpcy5zZXRTdGF0ZSh7c2VsZWN0ZWRTb3VyY2VDb2x1bW46IGNvbHVtbn0pfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tM1wiPlxuICAgICAgICAgICAgPFNlbGVjdEZpZWxkXG4gICAgICAgICAgICAgIHZhbHVlPXtuZXdSZWxhdGlvbn1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyh2YWx1ZSkgPT4gdGhpcy5zZXRTdGF0ZSh7bmV3UmVsYXRpb246IHZhbHVlfSl9XG4gICAgICAgICAgICAgIG9uQ2xlYXI9eygpID0+IHRoaXMuc2V0U3RhdGUoe25ld1JlbGF0aW9uOiBudWxsfSl9PlxuICAgICAgICAgICAgICA8c3BhbiB0eXBlPVwicGxhY2Vob2xkZXJcIj5DaG9vc2UgYSByZWxhdGlvbiB0eXBlLi4uPC9zcGFuPlxuICAgICAgICAgICAgICB7cmVsYXRpb25UeXBlT3B0aW9uc31cbiAgICAgICAgICAgIDwvU2VsZWN0RmllbGQ+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0zXCI+XG4gICAgICAgICAge3RhcmdldENvbHVtblNlbGVjdH1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMVwiPlxuXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJwdWxsLXJpZ2h0IGJ0biBidG4tZGVmYXVsdFwiIGRpc2FibGVkPXshKG5ld1JlbGF0aW9uICYmIHNlbGVjdGVkU291cmNlQ29sdW1uICYmIHNlbGVjdGVkVGFyZ2V0Q29sdW1uKX1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bmV3UmVsYXRpb246IG51bGwsIHNlbGVjdGVkU291cmNlQ29sdW1uOiBudWxsLCBzZWxlY3RlZFRhcmdldENvbHVtbjogbnVsbH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkFkZEN1c3RvbVByb3BlcnR5KG5ld1JlbGF0aW9uLCBcInJlbGF0aW9uXCIsIHNlbGVjdGVkU291cmNlQ29sdW1uLCBzZWxlY3RlZFRhcmdldENvbHVtbik7XG4gICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgIEFkZCByZWxhdGlvblxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBZGRSZWxhdGlvbjtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBQcm9wZXJ0eUZvcm0gZnJvbSBcIi4vcHJvcGVydHktZm9ybVwiO1xuaW1wb3J0IEFkZFByb3BlcnR5IGZyb20gXCIuL2FkZC1wcm9wZXJ0eVwiO1xuaW1wb3J0IEFkZFJlbGF0aW9uIGZyb20gXCIuL2FkZC1yZWxhdGlvblwiO1xuXG5jbGFzcyBDb2xsZWN0aW9uRm9ybSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgb25BZGRQcmVkaWNhdGVPYmplY3RNYXAsIG9uUmVtb3ZlUHJlZGljYXRlT2JqZWN0TWFwLFxuICAgICAgb25BZGRDdXN0b21Qcm9wZXJ0eSwgb25SZW1vdmVDdXN0b21Qcm9wZXJ0eSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHtcbiAgICAgIGFyY2hldHlwZUZpZWxkcyxcbiAgICAgIGF2YWlsYWJsZUFyY2hldHlwZXMsXG4gICAgICBjb2x1bW5zLFxuICAgICAgYXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGUsXG4gICAgICB0YXJnZXRhYmxlVnJlc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFjb2x1bW5zKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29uc3QgeyBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncywgY3VzdG9tUHJvcGVydGllcyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGFyY2hlVHlwZVByb3BGaWVsZHMgPSBhcmNoZXR5cGVGaWVsZHMuZmlsdGVyKChhZikgPT4gYWYudHlwZSAhPT0gXCJyZWxhdGlvblwiKTtcblxuICAgIGNvbnN0IHByb3BlcnR5Rm9ybXMgPSBhcmNoZVR5cGVQcm9wRmllbGRzXG4gICAgICAubWFwKChhZiwgaSkgPT4gKFxuICAgICAgICA8UHJvcGVydHlGb3JtIGtleT17aX0gbmFtZT17YWYubmFtZX0gdHlwZT17YWYudHlwZX0gY3VzdG9tPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZU9iamVjdE1hcD17cHJlZGljYXRlT2JqZWN0TWFwcGluZ3MuZmluZCgocG9tKSA9PiBwb20ucHJlZGljYXRlID09PSBhZi5uYW1lKX1cbiAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncz17cHJlZGljYXRlT2JqZWN0TWFwcGluZ3N9XG4gICAgICAgICAgICAgICAgICAgICAgb25BZGRQcmVkaWNhdGVPYmplY3RNYXA9e29uQWRkUHJlZGljYXRlT2JqZWN0TWFwfVxuICAgICAgICAgICAgICAgICAgICAgIG9uUmVtb3ZlUHJlZGljYXRlT2JqZWN0TWFwPXtvblJlbW92ZVByZWRpY2F0ZU9iamVjdE1hcH0gLz5cbiAgICAgICkpO1xuXG4gICAgY29uc3QgY3VzdG9tUHJvcGVydHlGb3JtcyA9IGN1c3RvbVByb3BlcnRpZXNcbiAgICAgIC5tYXAoKGN1c3RvbVByb3AsIGkpID0+IChcbiAgICAgICAgPFByb3BlcnR5Rm9ybSBrZXk9e2l9IG5hbWU9e2N1c3RvbVByb3AucHJvcGVydHlOYW1lfSB0eXBlPXtjdXN0b21Qcm9wLnByb3BlcnR5VHlwZX0gY3VzdG9tPXt0cnVlfSBjdXN0b21JbmRleD17aX1cbiAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZU9iamVjdE1hcD17cHJlZGljYXRlT2JqZWN0TWFwcGluZ3MuZmluZCgocG9tKSA9PiBwb20ucHJlZGljYXRlID09PSBjdXN0b21Qcm9wLnByb3BlcnR5TmFtZSl9XG4gICAgICAgICAgICAgICAgICAgICAgcHJlZGljYXRlT2JqZWN0TWFwcGluZ3M9e3ByZWRpY2F0ZU9iamVjdE1hcHBpbmdzfVxuICAgICAgICAgICAgICAgICAgICAgIG9uQWRkUHJlZGljYXRlT2JqZWN0TWFwPXtvbkFkZFByZWRpY2F0ZU9iamVjdE1hcH1cbiAgICAgICAgICAgICAgICAgICAgICBvblJlbW92ZVByZWRpY2F0ZU9iamVjdE1hcD17b25SZW1vdmVQcmVkaWNhdGVPYmplY3RNYXB9XG4gICAgICAgICAgICAgICAgICAgICAgb25SZW1vdmVDdXN0b21Qcm9wZXJ0eT17b25SZW1vdmVDdXN0b21Qcm9wZXJ0eX1cbiAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVDb2xsZWN0aW9uQ29sdW1uc1BlckFyY2hldHlwZT17YXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGV9XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25UeXBlSW5mbz17YXJjaGV0eXBlRmllbGRzLmZpbmQoKGFmKSA9PiBhZi5uYW1lID09PSBjdXN0b21Qcm9wLnByb3BlcnR5TmFtZSl9XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0YWJsZVZyZXM9e3RhcmdldGFibGVWcmVzfVxuICAgICAgICAvPlxuICAgICAgKSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJhc2ljLW1hcmdpblwiPlxuICAgICAgICA8UHJvcGVydHlGb3JtIG5hbWU9XCJzYW1lQXNcIiB0eXBlPVwic2FtZUFzXCIgY3VzdG9tPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zPXtjb2x1bW5zfVxuICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZU9iamVjdE1hcD17cHJlZGljYXRlT2JqZWN0TWFwcGluZ3MuZmluZCgocG9tKSA9PiBwb20ucHJlZGljYXRlID09PSBcInNhbWVBc1wiKX1cbiAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncz17cHJlZGljYXRlT2JqZWN0TWFwcGluZ3N9XG4gICAgICAgICAgICAgICAgICAgICAgb25BZGRQcmVkaWNhdGVPYmplY3RNYXA9e29uQWRkUHJlZGljYXRlT2JqZWN0TWFwfVxuICAgICAgICAgICAgICAgICAgICAgIG9uUmVtb3ZlUHJlZGljYXRlT2JqZWN0TWFwPXtvblJlbW92ZVByZWRpY2F0ZU9iamVjdE1hcH1cbiAgICAgICAgLz5cbiAgICAgICAge3Byb3BlcnR5Rm9ybXN9XG4gICAgICAgIHtjdXN0b21Qcm9wZXJ0eUZvcm1zfVxuICAgICAgICA8QWRkUHJvcGVydHkgb25BZGRDdXN0b21Qcm9wZXJ0eT17b25BZGRDdXN0b21Qcm9wZXJ0eX0gLz5cbiAgICAgICAgPEFkZFJlbGF0aW9uXG4gICAgICAgICAgYXJjaGV0eXBlRmllbGRzPXthcmNoZXR5cGVGaWVsZHN9XG4gICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICBhdmFpbGFibGVBcmNoZXR5cGVzPXthdmFpbGFibGVBcmNoZXR5cGVzfVxuICAgICAgICAgIG9uQWRkQ3VzdG9tUHJvcGVydHk9e29uQWRkQ3VzdG9tUHJvcGVydHl9XG4gICAgICAgICAgYXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGU9e2F2YWlsYWJsZUNvbGxlY3Rpb25Db2x1bW5zUGVyQXJjaGV0eXBlfVxuXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxlY3Rpb25Gb3JtOyIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBTZWxlY3RGaWVsZCBmcm9tIFwiLi4vZmllbGRzL3NlbGVjdC1maWVsZFwiO1xuXG5cbmNsYXNzIENvbHVtblNlbGVjdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb2x1bW5zLCBzZWxlY3RlZENvbHVtbiwgb25Db2x1bW5TZWxlY3QsIG9uQ2xlYXJDb2x1bW4sIHBsYWNlaG9sZGVyLCB2YWx1ZVByZWZpeCB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8U2VsZWN0RmllbGQgdmFsdWU9e3NlbGVjdGVkQ29sdW1ufSBzdHlsZT17e2Rpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJ9fVxuICAgICAgICAgICAgICAgICAgIHZhbHVlUHJlZml4PXt2YWx1ZVByZWZpeH1cbiAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGNvbHVtbikgPT4gb25Db2x1bW5TZWxlY3QoY29sdW1uKX1cbiAgICAgICAgICAgICAgICAgICBvbkNsZWFyPXsoKSA9PiBvbkNsZWFyQ29sdW1uKHNlbGVjdGVkQ29sdW1uKX0+XG5cbiAgICAgICAgPHNwYW4gdHlwZT1cInBsYWNlaG9sZGVyXCIgY2xhc3NOYW1lPVwiZnJvbS1leGNlbFwiPlxuICAgICAgICAgIDxpbWcgc3JjPVwiaW1hZ2VzL2ljb24tZXhjZWwuc3ZnXCIgYWx0PVwiXCIvPiB7cGxhY2Vob2xkZXIgfHwgXCJTZWxlY3QgYW4gZXhjZWwgY29sdW1uXCJ9XG4gICAgICAgIDwvc3Bhbj5cblxuICAgICAgICB7Y29sdW1ucy5tYXAoKGNvbHVtbikgPT4gKFxuICAgICAgICAgIDxzcGFuIGtleT17Y29sdW1ufSB2YWx1ZT17Y29sdW1ufSBjbGFzc05hbWU9XCJmcm9tLWV4Y2VsXCI+XG4gICAgICAgICAgICA8aW1nIHNyYz1cImltYWdlcy9pY29uLWV4Y2VsLnN2Z1wiIGFsdD1cIlwiLz57XCIgXCJ9XG4gICAgICAgICAgICB7dmFsdWVQcmVmaXggJiYgY29sdW1uID09PSBzZWxlY3RlZENvbHVtbiA/IHZhbHVlUHJlZml4IDogXCJcIn1cbiAgICAgICAgICAgIHtjb2x1bW59XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICApKX1cbiAgICAgIDwvU2VsZWN0RmllbGQ+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2x1bW5TZWxlY3Q7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgQ29sdW1uU2VsZWN0IGZyb20gXCIuL2NvbHVtbi1zZWxlY3RcIjtcbmltcG9ydCBjYW1lbDJsYWJlbCBmcm9tIFwiLi4vLi4vdXRpbC9jYW1lbDJsYWJlbFwiO1xuaW1wb3J0IHtnZXRDb2x1bW5WYWx1ZX0gZnJvbSBcIi4uLy4uL2FjY2Vzc29ycy9wcm9wZXJ0eS1tYXBwaW5nc1wiO1xuXG5cbmNvbnN0IGdldE9iamVjdEZvclByZWRpY2F0ZSA9IChwcmVkaWNhdGVPYmplY3RNYXBwaW5ncywgcHJlZGljYXRlKSA9PlxuICBwcmVkaWNhdGVPYmplY3RNYXBwaW5nc1xuICAgIC5maWx0ZXIoKHBvbSkgPT4gcG9tLnByZWRpY2F0ZSA9PT0gcHJlZGljYXRlKVxuICAgIC5tYXAoKHBvbSkgPT4gZ2V0Q29sdW1uVmFsdWUocG9tKSlbMF07XG5cbmNsYXNzIE5hbWVzRm9ybSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb2x1bW5zLCBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncywgb25Db2x1bW5TZWxlY3QsIG9uQ2xlYXJDb2x1bW4gfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBmb3JtUm93cyA9IFtcImZvcmVuYW1lXCIsIFwic3VybmFtZVwiLCBcIm5hbWVMaW5rXCIsIFwiZ2VuTmFtZVwiLCBcInJvbGVOYW1lXCJdXG4gICAgICAubWFwKChwcmVkaWNhdGUpID0+IChcbiAgICAgICAgPGRpdiBrZXk9e3ByZWRpY2F0ZX0gY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9e3tkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLCBwYWRkaW5nTGVmdDogXCIxMnB4XCIsIHdpZHRoOiBcIjkycHhcIn19PlxuICAgICAgICAgICAge2NhbWVsMmxhYmVsKHByZWRpY2F0ZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxDb2x1bW5TZWxlY3QgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQ29sdW1uPXtnZXRPYmplY3RGb3JQcmVkaWNhdGUocHJlZGljYXRlT2JqZWN0TWFwcGluZ3MsIHByZWRpY2F0ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbHVtblNlbGVjdD17KHZhbHVlKSA9PiBvbkNvbHVtblNlbGVjdCh2YWx1ZSwgcHJlZGljYXRlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xlYXJDb2x1bW49eyh2YWx1ZSkgPT4gb25DbGVhckNvbHVtbih2YWx1ZSwgcHJlZGljYXRlKX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj4pXG4gICAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIHtmb3JtUm93c31cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTmFtZXNGb3JtO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgQ29sdW1uU2VsZWN0IGZyb20gXCIuL2NvbHVtbi1zZWxlY3RcIjtcbmltcG9ydCBOYW1lc0Zvcm0gZnJvbSBcIi4vbmFtZXMtZm9ybVwiO1xuaW1wb3J0IFJlbGF0aW9uRm9ybSBmcm9tIFwiLi9yZWxhdGlvbi1mb3JtXCI7XG5pbXBvcnQgeyBwcm9wZXJ0eU1hcHBpbmdJc0NvbXBsZXRlIH0gZnJvbSBcIi4uLy4uL2FjY2Vzc29ycy9wcm9wZXJ0eS1tYXBwaW5nc1wiXG5pbXBvcnQgeyBnZXRDb2x1bW5WYWx1ZSB9IGZyb20gXCIuLi8uLi9hY2Nlc3NvcnMvcHJvcGVydHktbWFwcGluZ3NcIjtcbmltcG9ydCBjYW1lbDJsYWJlbCBmcm9tIFwiLi4vLi4vdXRpbC9jYW1lbDJsYWJlbFwiO1xuXG5jb25zdCB0eXBlTWFwID0ge1xuICB0ZXh0OiAocHJvcHMpID0+IDxDb2x1bW5TZWxlY3Qgey4uLnByb3BzfSAvPixcbiAgZGF0YWJsZTogKHByb3BzKSA9PiA8Q29sdW1uU2VsZWN0IHsuLi5wcm9wc30gLz4sXG4gIHNlbGVjdDogKHByb3BzKSA9PiA8Q29sdW1uU2VsZWN0IHsuLi5wcm9wc30gLz4sXG4gIHNhbWVBczogKHByb3BzKSA9PiA8Q29sdW1uU2VsZWN0IHsuLi5wcm9wc30gLz4sXG4gIG5hbWVzOiAocHJvcHMpID0+IDxOYW1lc0Zvcm0gey4uLnByb3BzfSAvPixcbiAgcmVsYXRpb246IChwcm9wcykgPT4gPFJlbGF0aW9uRm9ybSB7Li4ucHJvcHN9IC8+LFxuICBcInJlbGF0aW9uLXRvLWV4aXN0aW5nXCI6IChwcm9wcykgPT4gPFJlbGF0aW9uVG9FeGlzdGluZ0Zvcm0gey4uLnByb3BzfSAvPixcbiAgbXVsdGlzZWxlY3Q6IChwcm9wcykgPT4gPENvbHVtblNlbGVjdCB7Li4ucHJvcHN9IC8+LFxufTtcblxuY29uc3QgaXNDb21wbGV0ZUZvck5hbWVzID0gKHR5cGUsIHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzKSA9PlxuICB0eXBlID09PSBcIm5hbWVzXCIgJiYgcHJlZGljYXRlT2JqZWN0TWFwcGluZ3NcbiAgICAuZmlsdGVyKChwb20pID0+IFtcImZvcmVuYW1lXCIsIFwic3VybmFtZVwiLCBcIm5hbWVMaW5rXCIsIFwiZ2VuTmFtZVwiLCBcInJvbGVOYW1lXCJdLmluZGV4T2YocG9tLnByZWRpY2F0ZSkgPiAtMSlcbiAgICAuZmlsdGVyKChwb20pID0+IHByb3BlcnR5TWFwcGluZ0lzQ29tcGxldGUocG9tKSlcbiAgICAubGVuZ3RoID4gMDtcblxuY2xhc3MgUHJvcGVydHlGb3JtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICByZW5kZXIoKSB7XG5cbiAgICBjb25zdCB7IG9uQWRkUHJlZGljYXRlT2JqZWN0TWFwLCBvblJlbW92ZVByZWRpY2F0ZU9iamVjdE1hcCwgb25SZW1vdmVDdXN0b21Qcm9wZXJ0eSxcbiAgICAgIGF2YWlsYWJsZUNvbGxlY3Rpb25Db2x1bW5zUGVyQXJjaGV0eXBlLCByZWxhdGlvblR5cGVJbmZvLCB0YXJnZXRhYmxlVnJlcyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHsgbmFtZTogcHJlZGljYXRlTmFtZSwgdHlwZSwgY3VzdG9tLCBjdXN0b21JbmRleCwgY29sdW1ucywgcHJlZGljYXRlT2JqZWN0TWFwLCBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGZvcm1Db21wb25lbnQgPSB0eXBlTWFwW3R5cGVdXG4gICAgICA/IHR5cGVNYXBbdHlwZV0oe1xuICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxuICAgICAgICBzZWxlY3RlZENvbHVtbjogZ2V0Q29sdW1uVmFsdWUocHJlZGljYXRlT2JqZWN0TWFwKSxcbiAgICAgICAgcHJlZGljYXRlT2JqZWN0TWFwOiBwcmVkaWNhdGVPYmplY3RNYXAsXG4gICAgICAgIHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzOiBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncyxcbiAgICAgICAgYXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGU6IGF2YWlsYWJsZUNvbGxlY3Rpb25Db2x1bW5zUGVyQXJjaGV0eXBlLFxuICAgICAgICByZWxhdGlvblR5cGVJbmZvOiByZWxhdGlvblR5cGVJbmZvLFxuICAgICAgICB0YXJnZXRhYmxlVnJlczogdGFyZ2V0YWJsZVZyZXMsXG4gICAgICAgIG9uQ29sdW1uU2VsZWN0OiAodmFsdWUsIHByZWRpY2F0ZSkgPT4gb25BZGRQcmVkaWNhdGVPYmplY3RNYXAocHJlZGljYXRlIHx8IHByZWRpY2F0ZU5hbWUsIHZhbHVlLCB0eXBlKSxcbiAgICAgICAgb25DbGVhckNvbHVtbjogKHZhbHVlLCBwcmVkaWNhdGUpID0+IG9uUmVtb3ZlUHJlZGljYXRlT2JqZWN0TWFwKHByZWRpY2F0ZSB8fCBwcmVkaWNhdGVOYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG4gICAgICA6IDxzcGFuPnR5cGUgbm90IHlldCBzdXBwb3J0ZWQ6IDxzcGFuIHN0eWxlPXt7Y29sb3I6IFwicmVkXCJ9fT57dHlwZX08L3NwYW4+PC9zcGFuPjtcblxuICAgIGNvbnN0IHVuQ29uZmlybUJ1dHRvbiA9IHByb3BlcnR5TWFwcGluZ0lzQ29tcGxldGUocHJlZGljYXRlT2JqZWN0TWFwKSB8fCBpc0NvbXBsZXRlRm9yTmFtZXModHlwZSwgcHJlZGljYXRlT2JqZWN0TWFwcGluZ3MpXG4gICAgICA/ICg8YnV0dG9uIGNsYXNzTmFtZT1cImJ0biBidG4tYmxhbmtcIiBvbkNsaWNrPXsoKSA9PiBvblJlbW92ZVByZWRpY2F0ZU9iamVjdE1hcChwcmVkaWNhdGVOYW1lLCBnZXRDb2x1bW5WYWx1ZShwcmVkaWNhdGVPYmplY3RNYXApKX0+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaGktc3VjY2VzcyBnbHlwaGljb24gZ2x5cGhpY29uLW9rXCIgLz5cbiAgICAgICAgPC9idXR0b24+KSA6IG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3cgc21hbGwtbWFyZ2luXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTIgcGFkLTYtMTJcIj5cbiAgICAgICAgICA8c3Ryb25nPntjYW1lbDJsYWJlbChwcmVkaWNhdGVOYW1lKX08L3N0cm9uZz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJwdWxsLXJpZ2h0XCIgc3R5bGU9e3tmb250U2l6ZTogXCIwLjdlbVwifX0+KHt0eXBlfSk8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS04XCI+XG4gICAgICAgICAge2Zvcm1Db21wb25lbnR9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0xXCI+XG4gICAgICAgICAgeyBjdXN0b21cbiAgICAgICAgICAgID8gKDxidXR0b24gY2xhc3NOYW1lPVwiYnRuIGJ0bi1ibGFuayBwdWxsLXJpZ2h0XCIgdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IG9uUmVtb3ZlQ3VzdG9tUHJvcGVydHkoY3VzdG9tSW5kZXgpfT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlXCIvPlxuICAgICAgICAgIDwvYnV0dG9uPilcbiAgICAgICAgICAgIDogbnVsbCB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0xIGhpLXN1Y2Nlc3NcIj5cbiAgICAgICAgICB7dW5Db25maXJtQnV0dG9ufVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvcGVydHlGb3JtOyIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBDb2x1bW5TZWxlY3QgZnJvbSBcIi4vY29sdW1uLXNlbGVjdFwiO1xuXG5jb25zdCBnZXRTZWxlY3RlZFRhcmdldENvbHVtbiA9IChvYmplY3RNYXApID0+XG4gIG9iamVjdE1hcC5qb2luQ29uZGl0aW9uICYmIG9iamVjdE1hcC5qb2luQ29uZGl0aW9uLnBhcmVudCAmJiBvYmplY3RNYXAucGFyZW50VHJpcGxlc01hcFxuICAgID8gYCR7b2JqZWN0TWFwLnBhcmVudFRyaXBsZXNNYXB9ISR7b2JqZWN0TWFwLmpvaW5Db25kaXRpb24ucGFyZW50fWBcbiAgICA6IG51bGw7XG5cbmNsYXNzIFJlbGF0aW9uRm9ybSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgb25Db2x1bW5TZWxlY3QsIHByZWRpY2F0ZU9iamVjdE1hcDogb3B0aW9uYWxQcmVkaWNhdGVPYmplY3RNYXAsIGF2YWlsYWJsZUNvbGxlY3Rpb25Db2x1bW5zUGVyQXJjaGV0eXBlLCByZWxhdGlvblR5cGVJbmZvIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qgb2JqZWN0TWFwID0gKG9wdGlvbmFsUHJlZGljYXRlT2JqZWN0TWFwIHx8IHt9KS5vYmplY3RNYXAgfHwge307XG5cbiAgICBjb25zdCBzb3VyY2VDb2x1bW5Qcm9wcyA9IHtcbiAgICAgIC4uLnRoaXMucHJvcHMsXG4gICAgICB2YWx1ZVByZWZpeDogXCIoc291cmNlKSBcIixcbiAgICAgIHBsYWNlaG9sZGVyOiBcIlNlbGVjdCBhIHNvdXJjZSBjb2x1bW4uLi5cIixcbiAgICAgIG9uQ29sdW1uU2VsZWN0OiAodmFsdWUpID0+IG9uQ29sdW1uU2VsZWN0KHtcbiAgICAgICAgLi4uKG9iamVjdE1hcCB8fCB7fSksXG4gICAgICAgIGpvaW5Db25kaXRpb246IHtcbiAgICAgICAgICAuLi4oKG9iamVjdE1hcCB8fCB7fSkuam9pbkNvbmRpdGlvbiB8fCB7fSksXG4gICAgICAgICAgY2hpbGQ6IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcblxuICAgIGNvbnN0IHRhcmdldENvbGxlY3Rpb25Db2x1bW5zID0gYXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGVbcmVsYXRpb25UeXBlSW5mby5yZWxhdGlvbi50YXJnZXRDb2xsZWN0aW9uXVxuICAgICAgLm1hcCgodGFyZ2V0Q29sbGVjdGlvbkNvbHMpID0+IHRhcmdldENvbGxlY3Rpb25Db2xzLmNvbHVtbnMubWFwKChjb2x1bW4pID0+IGAke3RhcmdldENvbGxlY3Rpb25Db2xzLmNvbGxlY3Rpb25OYW1lfSEke2NvbHVtbn1gKSlcbiAgICAgIC5yZWR1Y2UoKGEsYikgPT4gYS5jb25jYXQoYikpO1xuXG4gICAgY29uc3QgdGFyZ2V0Q29sdW1uUHJvcHMgPSB7XG4gICAgICB2YWx1ZVByZWZpeDogXCIodGFyZ2V0KSBcIixcbiAgICAgIGNvbHVtbnM6IHRhcmdldENvbGxlY3Rpb25Db2x1bW5zLFxuICAgICAgc2VsZWN0ZWRDb2x1bW46IGdldFNlbGVjdGVkVGFyZ2V0Q29sdW1uKG9iamVjdE1hcCksXG4gICAgICBwbGFjZWhvbGRlcjogXCJTZWxlY3QgYSB0YXJnZXQgY29sdW1uLi4uXCIsXG4gICAgICBvbkNvbHVtblNlbGVjdDogKHZhbHVlKSA9PiBvbkNvbHVtblNlbGVjdCh7XG4gICAgICAgIC4uLihvYmplY3RNYXAgfHwge30pLFxuICAgICAgICBqb2luQ29uZGl0aW9uOiB7XG4gICAgICAgICAgLi4uKChvYmplY3RNYXAgfHwge30pLmpvaW5Db25kaXRpb24gfHwge30pLFxuICAgICAgICAgIHBhcmVudDogdmFsdWUuc3BsaXQoXCIhXCIpWzFdXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudFRyaXBsZXNNYXA6IHZhbHVlLnNwbGl0KFwiIVwiKVswXVxuICAgICAgfSlcbiAgICB9O1xuXG5cblxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxDb2x1bW5TZWxlY3Qgey4uLnNvdXJjZUNvbHVtblByb3BzfSAvPlxuICAgICAgICA8Q29sdW1uU2VsZWN0IHsuLi50YXJnZXRDb2x1bW5Qcm9wc30gLz5cblxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbGF0aW9uRm9ybTsiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgRGF0YXNldENhcmRzIGZyb20gXCIuL2RhdGFzZXQtY2FyZHNcIlxuaW1wb3J0IEZpcnN0VXBsb2FkIGZyb20gXCIuL2ZpcnN0VXBsb2FkXCI7XG5pbXBvcnQgRGVsZXRlVnJlQ29uZmlybWF0aW9uRm9ybSBmcm9tIFwiLi9kZWxldGUtdnJlLWNvbmZpcm1hdGlvbi1mb3JtXCI7XG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4vZmllbGRzL21vZGFsXCI7XG5pbXBvcnQgTWVzc2FnZSBmcm9tIFwiLi9tZXNzYWdlXCI7XG5pbXBvcnQgeyB1cmxzIH0gZnJvbSBcIi4uL3JvdXRlclwiO1xuaW1wb3J0IHsgTGluayB9IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcblxuZnVuY3Rpb24gQ29sbGVjdGlvbk92ZXJ2aWV3KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvbkNvbnRpbnVlTWFwcGluZyxcbiAgICBvbkRlbGV0ZVZyZUNsaWNrLFxuICAgIG9uQ29tZmlybURlbGV0ZVZyZSxcbiAgICBvbkNsb3NlTWVzc2FnZVxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3Qge1xuICAgIHVzZXJJZCxcbiAgICB2cmVzLFxuICAgIHNlYXJjaEd1aVVybCxcbiAgICBzaG93RGVsZXRlVnJlTW9kYWxGb3IsXG4gICAgc2hvd0RlbGV0ZVZyZUZhaWxlZE1lc3NhZ2UsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBoYXNPd25WcmVzID0gKHZyZXMgJiYgT2JqZWN0LmtleXModnJlcykubGVuZ3RoID4gMCkgPiAwO1xuXG4gIGNvbnN0IHVwbG9hZEJ1dHRvbiA9IChcbiAgICA8TGluayB0bz17dXJscy5uZXdEYXRhc2V0KCl9IGNsYXNzTmFtZT17YGJ0biBidG4tbGcgYnRuLXByaW1hcnkgJHtoYXNPd25WcmVzID8gXCJwdWxsLXJpZ2h0XCIgOiBcIlwifWB9PlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1jbG91ZC11cGxvYWRcIiAvPntcIiBcIn1cbiAgICAgIHtoYXNPd25WcmVzID8gXCJVcGxvYWQgbmV3IGRhdGFzZXRcIiA6IFwiVXBsb2FkIHlvdXIgZmlyc3QgZGF0YXNldFwifVxuICAgIDwvTGluaz5cbiAgKTtcblxuICBjb25zdCBkZWxldGVWcmVGYWlsZWRNZXNzYWdlID0gc2hvd0RlbGV0ZVZyZUZhaWxlZE1lc3NhZ2UgPyAoXG4gICAgPE1lc3NhZ2UgYWxlcnRMZXZlbD1cImRhbmdlclwiIGRpc21pc3NpYmxlPXt0cnVlfSBvbkNsb3NlTWVzc2FnZT17KCkgPT4gb25DbG9zZU1lc3NhZ2UoXCJzaG93RGVsZXRlVnJlRmFpbGVkTWVzc2FnZVwiKX0+XG4gICAgICBGYWlsZWQgdG8gZGVsZXRlIGRhdGFzZXRcbiAgICA8L01lc3NhZ2U+XG4gICkgOiBudWxsO1xuXG4gIGNvbnN0IGRlbGV0ZVZyZU1vZGFsID0gc2hvd0RlbGV0ZVZyZU1vZGFsRm9yXG4gICAgPyAoXG4gICAgICA8TW9kYWwgb25DbG9zZT17KCkgPT4gb25EZWxldGVWcmVDbGljayhudWxsKX0gaGVhZGVyPVwiRGVsZXRlIGRhdGFzZXRcIj5cbiAgICAgICAgPERlbGV0ZVZyZUNvbmZpcm1hdGlvbkZvcm0gdnJlSWQ9e3Nob3dEZWxldGVWcmVNb2RhbEZvcn0gb25Db21maXJtRGVsZXRlVnJlPXtvbkNvbWZpcm1EZWxldGVWcmV9IG9uQ2xvc2U9eygpID0+IG9uRGVsZXRlVnJlQ2xpY2sobnVsbCl9IC8+XG4gICAgICA8L01vZGFsPlxuICAgIClcbiAgICA6IG51bGw7XG5cblxuICByZXR1cm4gaGFzT3duVnJlc1xuICAgID8gKFxuICAgICAgPGRpdj5cbiAgICAgICAge2RlbGV0ZVZyZU1vZGFsfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgICAgIHtkZWxldGVWcmVGYWlsZWRNZXNzYWdlfVxuICAgICAgICAgIDxEYXRhc2V0Q2FyZHMgdXNlcklkPXt1c2VySWR9IGNhcHRpb249XCJNeSBkYXRhc2V0c1wiIHZyZXM9e3ZyZXN9IG1pbmU9e3RydWV9IHNlYXJjaEd1aVVybD17c2VhcmNoR3VpVXJsfVxuICAgICAgICAgICAgb25EZWxldGVWcmVDbGljaz17b25EZWxldGVWcmVDbGlja30gb25Db250aW51ZU1hcHBpbmc9e29uQ29udGludWVNYXBwaW5nfT5cbiAgICAgICAgICAgIHt1cGxvYWRCdXR0b259XG4gICAgICAgICAgPC9EYXRhc2V0Q2FyZHM+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICkgOiAoXG4gICAgPEZpcnN0VXBsb2FkIHsuLi5wcm9wc30+XG4gICAgICB7dXBsb2FkQnV0dG9ufVxuICAgIDwvRmlyc3RVcGxvYWQ+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxlY3Rpb25PdmVydmlldzsiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgSGVhZGVyQ2VsbCBmcm9tIFwiLi90YWJsZS9oZWFkZXItY2VsbFwiO1xuaW1wb3J0IERhdGFSb3cgZnJvbSBcIi4vdGFibGUvZGF0YS1yb3dcIjtcblxuY2xhc3MgQ29sbGVjdGlvblRhYmxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgcm93cywgaGVhZGVycywgbmV4dFVybCB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhYmxlLXJlc3BvbnNpdmVcIj5cbiAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLW9idHJ1c2l2ZVwiPlxuICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAge2hlYWRlcnMubWFwKChoZWFkZXIpID0+IChcbiAgICAgICAgICAgICAgICA8SGVhZGVyQ2VsbCBrZXk9e2hlYWRlci5uYW1lfSBoZWFkZXI9e2hlYWRlci5uYW1lfSBpc0NvbmZpcm1lZD17aGVhZGVyLmlzQ29uZmlybWVkfSAvPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICB7cm93cy5tYXAoKHJvdywgaSkgPT4gPERhdGFSb3cga2V5PXtpfSByb3c9e3Jvd30gLz4pfVxuICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgIDwvdGFibGU+XG4gICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5vbkxvYWRNb3JlQ2xpY2sgJiYgdGhpcy5wcm9wcy5vbkxvYWRNb3JlQ2xpY2sobmV4dFVybCl9XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFuZXh0VXJsfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0biBidG4tZGVmYXVsdCBwdWxsLXJpZ2h0XCI+bW9yZS4uLjwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2xsZWN0aW9uVGFibGU7IiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGN4IGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbmNsYXNzIENvbGxlY3Rpb25UYWJzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb2xsZWN0aW9uVGFicywgb25TZWxlY3RDb2xsZWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJhc2ljLW1hcmdpblwiPlxuICAgICAgICA8dWwgY2xhc3NOYW1lPVwibmF2IG5hdi10YWJzXCIgcm9sZT1cInRhYmxpc3RcIj5cbiAgICAgICAgICB7Y29sbGVjdGlvblRhYnMubWFwKChjb2xsZWN0aW9uVGFiKSA9PiAoXG4gICAgICAgICAgICA8bGkga2V5PXtjb2xsZWN0aW9uVGFiLmNvbGxlY3Rpb25OYW1lfSBjbGFzc05hbWU9e2N4KHthY3RpdmU6IGNvbGxlY3Rpb25UYWIuYWN0aXZlfSl9PlxuICAgICAgICAgICAgICA8YSBvbkNsaWNrPXsoKSA9PiBjb2xsZWN0aW9uVGFiLmFjdGl2ZSA/IGZhbHNlIDogb25TZWxlY3RDb2xsZWN0aW9uKGNvbGxlY3Rpb25UYWIuY29sbGVjdGlvbk5hbWUpfVxuICAgICAgICAgICAgICAgICBzdHlsZT17e2N1cnNvcjogY29sbGVjdGlvblRhYi5hY3RpdmUgPyBcImRlZmF1bHRcIiA6IFwicG9pbnRlclwifX0+XG4gICAgICAgICAgICAgICAge2NvbGxlY3Rpb25UYWIuYXJjaGV0eXBlTmFtZX17XCIgXCJ9XG4gICAgICAgICAgICAgICAge2NvbGxlY3Rpb25UYWIuY29tcGxldGUgPyA8c3BhbiBjbGFzc05hbWU9XCJnbHlwaGljb24gZ2x5cGhpY29uLW9rXCIgLz4gOiBudWxsfVxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImV4Y2VsLXRhYlwiPjxpbWcgc3JjPVwiaW1hZ2VzL2ljb24tZXhjZWwuc3ZnXCIgY2xhc3NOYW1lPVwiZXhjZWwtaWNvblwiIGFsdD1cIlwiLz4ge2NvbGxlY3Rpb25UYWIuY29sbGVjdGlvbk5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgQ29sbGVjdGlvblRhYnM7IiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IENvbGxlY3Rpb25UYWJzIGZyb20gXCIuL2NvbGxlY3Rpb24tdGFic1wiO1xuaW1wb3J0IE1lc3NhZ2UgZnJvbSBcIi4vbWVzc2FnZVwiO1xuaW1wb3J0IENvbGxlY3Rpb25UYWJsZSBmcm9tIFwiLi9jb2xsZWN0aW9uLXRhYmxlXCJcbmltcG9ydCBDb2xsZWN0aW9uRm9ybSBmcm9tIFwiLi9jb2xsZWN0aW9uLWZvcm0vY29sbGVjdGlvbi1mb3JtXCI7XG5pbXBvcnQgVXBsb2FkQnV0dG9uIGZyb20gXCIuL3VwbG9hZC1idXR0b25cIjtcblxuY2xhc3MgQ29ubmVjdERhdGEgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgY29uc3QgeyBvbkZldGNoQnVsa1VwbG9hZGVkTWV0YWRhdGEsIG9uU2VsZWN0Q29sbGVjdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGZpcnN0TWFwcGVkQ29sbGVjdGlvbiB9ID0gbmV4dFByb3BzO1xuXG4gICAgaWYgKHRoaXMucHJvcHMucGFyYW1zLnZyZUlkICE9PSBuZXh0UHJvcHMucGFyYW1zLnZyZUlkKSB7XG4gICAgICAvLyBUcmlnZ2VycyBmZXRjaCBkYXRhIGZyb20gc2VydmVyIGJhc2VkIG9uIHZyZUlkIGZyb20gcm91dGUuXG4gICAgICBvbkZldGNoQnVsa1VwbG9hZGVkTWV0YWRhdGEobmV4dFByb3BzLnBhcmFtcy52cmVJZCk7XG4gICAgfSBlbHNlIGlmIChmaXJzdE1hcHBlZENvbGxlY3Rpb24pIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbGxlY3Rpb24gaXMgbm90IG1hcHBlZCwgc2hvdyB0aGUgZmlyc3Qgb25lIHRoYXQgX2lzXyBtYXBwZWRcbiAgICAgIG9uU2VsZWN0Q29sbGVjdGlvbihmaXJzdE1hcHBlZENvbGxlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRmV0Y2hCdWxrVXBsb2FkZWRNZXRhZGF0YSwgdGFicywgdnJlLCB2cmVJZCxcbiAgICAgIGZpcnN0TWFwcGVkQ29sbGVjdGlvbiwgb25TZWxlY3RDb2xsZWN0aW9uXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAodGFicy5sZW5ndGggPT09IDAgfHwgdnJlICE9PSB2cmVJZCkge1xuICAgICAgLy8gVHJpZ2dlcnMgZmV0Y2ggZGF0YSBmcm9tIHNlcnZlciBiYXNlZCBvbiB2cmVJZCBmcm9tIHJvdXRlLlxuICAgICAgb25GZXRjaEJ1bGtVcGxvYWRlZE1ldGFkYXRhKHZyZUlkKTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0TWFwcGVkQ29sbGVjdGlvbikge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnRseSBhY3RpdmUgY29sbGVjdGlvbiBpcyBub3QgbWFwcGVkLCBzaG93IHRoZSBmaXJzdCBvbmUgdGhhdCBfaXNfIG1hcHBlZFxuICAgICAgb25TZWxlY3RDb2xsZWN0aW9uKGZpcnN0TWFwcGVkQ29sbGVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgb25DbG9zZU1lc3NhZ2UsIG9uU2VsZWN0Q29sbGVjdGlvbiwgb25Mb2FkTW9yZUNsaWNrLCBvblB1Ymxpc2hEYXRhLCBvblVwbG9hZEZpbGVTZWxlY3QsIG9uU2F2ZU1hcHBpbmdTdGF0ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHsgb25BZGRQcmVkaWNhdGVPYmplY3RNYXAsIG9uUmVtb3ZlUHJlZGljYXRlT2JqZWN0TWFwLCBvbkFkZEN1c3RvbVByb3BlcnR5LCBvblJlbW92ZUN1c3RvbVByb3BlcnR5IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qge1xuICAgICAgcGFyYW1zOiB7IHZyZUlkIH0sXG4gICAgICB2cmUsXG4gICAgICB0YWJzLFxuICAgICAgc2hvd0NvbGxlY3Rpb25zQXJlQ29ubmVjdGVkTWVzc2FnZSxcbiAgICAgIHVwbG9hZGVkRmlsZW5hbWUsXG4gICAgICBwdWJsaXNoRW5hYmxlZCxcbiAgICAgIHB1Ymxpc2hTdGF0dXMsXG4gICAgICBwdWJsaXNoRXJyb3JzLFxuICAgICAgaGFzTWFwcGluZ0Vycm9ycyxcbiAgICAgIHVwbG9hZFN0YXR1cyxcbiAgICAgIGF2YWlsYWJsZUFyY2hldHlwZXMsXG4gICAgICBjdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgYXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGUsXG4gICAgICBybWxQcmV2aWV3RGF0YSxcbiAgICAgIHRhcmdldGFibGVWcmVzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyB0YWJsZSB2aWV3IHByb3BlcnRpZXNcbiAgICBjb25zdCB7IHJvd3MsIGhlYWRlcnMsIG5leHRVcmwsIGFjdGl2ZUNvbGxlY3Rpb24gfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBmb3JtIHZpZXcgcHJvcGVydGllc1xuICAgIGNvbnN0IHsgYXJjaGV0eXBlRmllbGRzLCBjb2x1bW5zLCBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncyB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghYXJjaGV0eXBlRmllbGRzIHx8IHRhYnMubGVuZ3RoID09PSAwIHx8IHZyZSAhPT0gdnJlSWQpIHsgcmV0dXJuIG51bGw7IH1cblxuXG4gICAgY29uc3Qgcm1sUHJldmlld0Jsb2NrID0gcm1sUHJldmlld0RhdGEgPyAoXG4gICAgICA8ZGl2IHN0eWxlPXt7cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgekluZGV4OiBcIjEwXCIsIHdpZHRoOiBcIjEwMCVcIiwgdG9wOiBcIjkwcHhcIn19PlxuICAgICAgICA8cHJlIHN0eWxlPXt7d2lkdGg6IFwiODAlXCIsIG1hcmdpbjogXCIwIGF1dG9cIiwgYmFja2dyb3VuZENvbG9yOiBcIiNkZGRcIn19PlxuICAgICAgICAgIHtKU09OLnN0cmluZ2lmeShybWxQcmV2aWV3RGF0YSwgbnVsbCwgMil9XG4gICAgICAgIDwvcHJlPlxuICAgICAgPC9kaXY+XG4gICAgKSA6IG51bGw7XG5cbiAgICBjb25zdCBwdWJsaXNoRmFpbGVkTWVzc2FnZSA9IHB1Ymxpc2hFcnJvcnMgfHwgaGFzTWFwcGluZ0Vycm9ycyA/IChcbiAgICAgIDxNZXNzYWdlIGFsZXJ0TGV2ZWw9XCJkYW5nZXJcIiBkaXNtaXNzaWJsZT17ZmFsc2V9PlxuICAgICAgICA8VXBsb2FkQnV0dG9uIGNsYXNzTmFtZXM9e1tcImJ0blwiLCBcImJ0bi1kYW5nZXJcIiwgXCJwdWxsLXJpZ2h0XCIsIFwiYnRuLXhzXCJdfSBsYWJlbD1cIlJlLXVwbG9hZFwiXG4gICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RQYXRoPVwibWFwQXJjaGV0eXBlc1wiXG4gICAgICAgICAgICAgICAgICAgICAgb25VcGxvYWRGaWxlU2VsZWN0PXtvblVwbG9hZEZpbGVTZWxlY3R9IHVwbG9hZFN0YXR1cz17dXBsb2FkU3RhdHVzfVxuICAgICAgICAgICAgICAgICAgICAgIHZyZUlkPXt2cmV9XG4gICAgICAgIC8+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImdseXBoaWNvbiBnbHlwaGljb24tZXhjbGFtYXRpb24tc2lnblwiIC8+e1wiIFwifVxuICAgICAgICBQdWJsaXNoIGZhaWxlZC4gUGxlYXNlIGZpeCB0aGUgbWFwcGluZ3Mgb3IgcmUtdXBsb2FkIHRoZSBkYXRhLlxuICAgICAgPC9NZXNzYWdlPlxuICAgICkgOiBudWxsO1xuXG4gICAgY29uc3QgY29sbGVjdGlvbnNBcmVDb25uZWN0ZWRNZXNzYWdlID0gc2hvd0NvbGxlY3Rpb25zQXJlQ29ubmVjdGVkTWVzc2FnZSAmJiB1cGxvYWRlZEZpbGVuYW1lID9cbiAgICAgIDxNZXNzYWdlIGFsZXJ0TGV2ZWw9XCJpbmZvXCIgZGlzbWlzc2libGU9e3RydWV9IG9uQ2xvc2VNZXNzYWdlPXsoKSA9PiBvbkNsb3NlTWVzc2FnZShcInNob3dDb2xsZWN0aW9uc0FyZUNvbm5lY3RlZE1lc3NhZ2VcIil9PlxuICAgICAgICB7dGFicy5tYXAoKHRhYikgPT4gPGVtIGtleT17dGFiLmNvbGxlY3Rpb25OYW1lfT57dGFiLmNvbGxlY3Rpb25OYW1lfTwvZW0+KVxuICAgICAgICAgIC5yZWR1Y2UoKGFjY3UsIGVsZW0pID0+IGFjY3UgPT09IG51bGwgPyBbZWxlbV0gOiBbLi4uYWNjdSwgJyBhbmQgJywgZWxlbV0sIG51bGwpXG4gICAgICAgIH0gZnJvbSA8ZW0+e3VwbG9hZGVkRmlsZW5hbWV9PC9lbT4ge3RhYnMubGVuZ3RoID09PSAxID8gXCJpc1wiIDogXCJhcmVcIiB9IGNvbm5lY3RlZCB0byB0aGUgVGltYnVjdG9vIEFyY2hldHlwZXMuXG4gICAgICA8L01lc3NhZ2U+IDogbnVsbDtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICB7cm1sUHJldmlld0Jsb2NrfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBiYXNpYy1tYXJnaW5cIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwic21hbGwtbWFyZ2luXCI+VXBsb2FkIGFuZCBjb25uZWN0IHlvdXIgZGF0YXNldDwvaDI+XG4gICAgICAgICAge2NvbGxlY3Rpb25zQXJlQ29ubmVjdGVkTWVzc2FnZX1cbiAgICAgICAgICB7cHVibGlzaEZhaWxlZE1lc3NhZ2V9XG4gICAgICAgICAgPHA+Q29ubmVjdCB0aGUgZXhjZWwgY29sdW1ucyB0byB0aGUgcHJvcGVydGllcyBvZiB0aGUgQXJjaGV0eXBlczwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxDb2xsZWN0aW9uVGFicyBjb2xsZWN0aW9uVGFicz17dGFic30gb25TZWxlY3RDb2xsZWN0aW9uPXtvblNlbGVjdENvbGxlY3Rpb259IC8+XG4gICAgICAgIDxDb2xsZWN0aW9uRm9ybSBhcmNoZXR5cGVGaWVsZHM9e2FyY2hldHlwZUZpZWxkc30gY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUFyY2hldHlwZXM9e2F2YWlsYWJsZUFyY2hldHlwZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVDb2xsZWN0aW9uQ29sdW1uc1BlckFyY2hldHlwZT17YXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGV9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21Qcm9wZXJ0aWVzPXtjdXN0b21Qcm9wZXJ0aWVzfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25BZGRDdXN0b21Qcm9wZXJ0eT17b25BZGRDdXN0b21Qcm9wZXJ0eX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVtb3ZlQ3VzdG9tUHJvcGVydHk9e29uUmVtb3ZlQ3VzdG9tUHJvcGVydHl9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncz17cHJlZGljYXRlT2JqZWN0TWFwcGluZ3N9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkFkZFByZWRpY2F0ZU9iamVjdE1hcD17b25BZGRQcmVkaWNhdGVPYmplY3RNYXB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlbW92ZVByZWRpY2F0ZU9iamVjdE1hcD17b25SZW1vdmVQcmVkaWNhdGVPYmplY3RNYXB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRhYmxlVnJlcz17dGFyZ2V0YWJsZVZyZXN9IC8+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgYmlnLW1hcmdpblwiPlxuICAgICAgICAgIDxidXR0b24gb25DbGljaz17b25QdWJsaXNoRGF0YX0gY2xhc3NOYW1lPVwiYnRuIGJ0bi13YXJuaW5nIGJ0bi1sZyBwdWxsLXJpZ2h0XCIgdHlwZT1cImJ1dHRvblwiIGRpc2FibGVkPXshcHVibGlzaEVuYWJsZWR9PlxuICAgICAgICAgICAge3B1Ymxpc2hTdGF0dXN9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvblNhdmVNYXBwaW5nU3RhdGV9IGNsYXNzTmFtZT1cImJ0biBidG4tZGVmYXVsdCBidG4tbGcgcHVsbC1yaWdodFwiIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IFwiNHB4XCJ9fSBkaXNhYmxlZD17IXB1Ymxpc2hFbmFibGVkfT5cbiAgICAgICAgICAgIFNhdmVcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgYmlnLW1hcmdpblwiPlxuICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZyb20tZXhjZWxcIj5cbiAgICAgICAgICAgIDxpbWcgc3JjPVwiaW1hZ2VzL2ljb24tZXhjZWwuc3ZnXCIgYWx0PVwiXCIvPntcIiBcIn1cbiAgICAgICAgICAgIDxlbT57YWN0aXZlQ29sbGVjdGlvbn08L2VtPiB7dXBsb2FkZWRGaWxlbmFtZSA/IGBmcm9tICR7dXBsb2FkZWRGaWxlbmFtZX1gIDogXCJcIn1cbiAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICA8Q29sbGVjdGlvblRhYmxlXG4gICAgICAgICAgICByb3dzPXtyb3dzfVxuICAgICAgICAgICAgaGVhZGVycz17aGVhZGVyc31cbiAgICAgICAgICAgIG5leHRVcmw9e25leHRVcmx9XG4gICAgICAgICAgICBvbkxvYWRNb3JlQ2xpY2s9eyh1cmwpID0+IG9uTG9hZE1vcmVDbGljayh1cmwsIGFjdGl2ZUNvbGxlY3Rpb24pfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdERhdGE7IiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFNlbGVjdEZpZWxkIGZyb20gXCIuL2ZpZWxkcy9zZWxlY3QtZmllbGRcIjtcbmltcG9ydCBNZXNzYWdlIGZyb20gXCIuL21lc3NhZ2VcIjtcbmltcG9ydCB7IHVybHMgfSBmcm9tIFwiLi4vcm91dGVyXCI7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuaW1wb3J0IENvbGxlY3Rpb25UYWJsZSBmcm9tIFwiLi9jb2xsZWN0aW9uLXRhYmxlXCI7XG5cbmNsYXNzIENvbm5lY3RUb0FyY2hldHlwZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGNvbnN0IHsgb25GZXRjaEJ1bGtVcGxvYWRlZE1ldGFkYXRhIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIFRyaWdnZXJzIGZldGNoIGRhdGEgZnJvbSBzZXJ2ZXIgYmFzZWQgb24gdnJlSWQgZnJvbSByb3V0ZS5cbiAgICBpZiAodGhpcy5wcm9wcy5wYXJhbXMudnJlSWQgIT09IG5leHRQcm9wcy5wYXJhbXMudnJlSWQpIHtcbiAgICAgIG9uRmV0Y2hCdWxrVXBsb2FkZWRNZXRhZGF0YShuZXh0UHJvcHMucGFyYW1zLnZyZUlkKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7IG9uRmV0Y2hCdWxrVXBsb2FkZWRNZXRhZGF0YSwgY29sbGVjdGlvbnMsIHZyZSwgdnJlSWQgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFjb2xsZWN0aW9ucyB8fCB2cmUgIT09IHZyZUlkKSB7XG4gICAgICBvbkZldGNoQnVsa1VwbG9hZGVkTWV0YWRhdGEodnJlSWQpO1xuICAgIH1cbiAgfVxuXG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZyZUlkLCAvLyBmcm9tIHBhcmFtc1xuICAgICAgdnJlLCAvLyBmcm9tIHNlcnZlciByZXNwb25zZVxuICAgICAgYXJjaGV0eXBlLFxuICAgICAgY29sbGVjdGlvbnMsXG4gICAgICBtYXBwaW5ncyxcbiAgICAgIHJtbFByZXZpZXdEYXRhXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBhY3Rpb25zXG4gICAgY29uc3QgeyBvbkNsb3NlTWVzc2FnZSwgb25NYXBDb2xsZWN0aW9uQXJjaGV0eXBlLCBvblNlbGVjdENvbGxlY3Rpb24sIG9uTG9hZE1vcmVDbGljaywgb25TYXZlTmV3TWFwcGluZ1N0YXRlIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIG1lc3NhZ2VzXG4gICAgY29uc3QgeyBzaG93RmlsZUlzVXBsb2FkZWRNZXNzYWdlLCB1cGxvYWRlZEZpbGVOYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgIC8vIHRhYmxlIHZpZXcgcHJvcGVydGllc1xuICAgIGNvbnN0IHsgcm93cywgaGVhZGVycywgbmV4dFVybCwgYWN0aXZlQ29sbGVjdGlvbiB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghY29sbGVjdGlvbnMgfHwgdnJlICE9PSB2cmVJZCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgY29uc3QgY29sbGVjdGlvbnNBcmVNYXBwZWQgPSBPYmplY3Qua2V5cyhtYXBwaW5ncy5jb2xsZWN0aW9ucykubGVuZ3RoID4gMCAmJlxuICAgICAgT2JqZWN0LmtleXMobWFwcGluZ3MuY29sbGVjdGlvbnMpLm1hcCgoa2V5KSA9PiBtYXBwaW5ncy5jb2xsZWN0aW9uc1trZXldLmFyY2hldHlwZU5hbWUpLmZpbHRlcih2YWwgPT4gdmFsICE9PSBudWxsKS5sZW5ndGggPiAwO1xuXG4gICAgY29uc3QgZmlsZUlzVXBsb2FkZWRNZXNzYWdlID0gc2hvd0ZpbGVJc1VwbG9hZGVkTWVzc2FnZSAmJiB1cGxvYWRlZEZpbGVOYW1lID8gKFxuICAgICAgPE1lc3NhZ2UgYWxlcnRMZXZlbD1cImluZm9cIiBkaXNtaXNzaWJsZT17dHJ1ZX0gb25DbG9zZU1lc3NhZ2U9eygpID0+IG9uQ2xvc2VNZXNzYWdlKFwic2hvd0ZpbGVJc1VwbG9hZGVkTWVzc2FnZVwiKX0+XG4gICAgICAgIDxlbT57dXBsb2FkZWRGaWxlTmFtZX08L2VtPiBpcyB1cGxvYWRlZC5cbiAgICAgIDwvTWVzc2FnZT5cbiAgICApIDogbnVsbDtcblxuICAgIGNvbnN0IHJtbFByZXZpZXdCbG9jayA9IHJtbFByZXZpZXdEYXRhID8gKFxuICAgICAgPGRpdiBzdHlsZT17e3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIHpJbmRleDogXCIxMFwiLCB3aWR0aDogXCIxMDAlXCIsIHRvcDogXCI5MHB4XCJ9fT5cbiAgICAgICAgPHByZSBzdHlsZT17e3dpZHRoOiBcIjgwJVwiLCBtYXJnaW46IFwiMCBhdXRvXCIsIGJhY2tncm91bmRDb2xvcjogXCIjZGRkXCJ9fT5cbiAgICAgICAgICB7SlNPTi5zdHJpbmdpZnkocm1sUHJldmlld0RhdGEsIG51bGwsIDIpfVxuICAgICAgICA8L3ByZT5cbiAgICAgIDwvZGl2PlxuICAgICkgOiBudWxsO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIHtybWxQcmV2aWV3QmxvY2t9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJhc2ljLW1hcmdpblwiPlxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJzbWFsbC1tYXJnaW5cIj5VcGxvYWQgYW5kIGNvbm5lY3QgeW91ciBkYXRhc2V0PC9oMj5cbiAgICAgICAgICB7ZmlsZUlzVXBsb2FkZWRNZXNzYWdlfVxuICAgICAgICAgIDxwPldlIGZvdW5kIHtjb2xsZWN0aW9ucy5sZW5ndGh9IGNvbGxlY3Rpb25zIGluIHRoZSBmaWxlLiBDb25uZWN0IHRoZSB0YWJzIHRvIHRoZSBUaW1idWN0b28gQXJjaGV0eXBlcy48L3A+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJhc2ljLW1hcmdpblwiPlxuICAgICAgICAgIHtjb2xsZWN0aW9ucy5tYXAoKHNoZWV0KSA9PiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiIGtleT17c2hlZXQubmFtZX0+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLTJcIj5cbiAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJmcm9tLWV4Y2VsXCIgc3R5bGU9e3tjdXJzb3I6IFwicG9pbnRlclwifX1cbiAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzaGVldC5uYW1lID09PSBhY3RpdmVDb2xsZWN0aW9uID8gZmFsc2UgOiBvblNlbGVjdENvbGxlY3Rpb24oc2hlZXQubmFtZSl9PlxuICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJpbWFnZXMvaWNvbi1leGNlbC5zdmdcIiBhbHQ9XCJcIi8+IHtzaGVldC5uYW1lfSB7c2hlZXQubmFtZSA9PT0gYWN0aXZlQ29sbGVjdGlvbiA/IFwiKlwiIDogXCJcIn1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC04XCI+XG4gICAgICAgICAgICAgICAgPFNlbGVjdEZpZWxkXG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KHZhbHVlKSA9PiBvbk1hcENvbGxlY3Rpb25BcmNoZXR5cGUoc2hlZXQubmFtZSwgdmFsdWUpfVxuICAgICAgICAgICAgICAgICAgb25DbGVhcj17KCkgPT4gb25NYXBDb2xsZWN0aW9uQXJjaGV0eXBlKHNoZWV0Lm5hbWUsIG51bGwpIH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlPXttYXBwaW5ncy5jb2xsZWN0aW9uc1tzaGVldC5uYW1lXS5hcmNoZXR5cGVOYW1lfT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gdHlwZT1cInBsYWNlaG9sZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgQ29ubmVjdCA8ZW0+e3NoZWV0Lm5hbWV9PC9lbT4gdG8gYSBUaW1idWN0b28gYXJjaGV0eXBlLlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICB7T2JqZWN0LmtleXMoYXJjaGV0eXBlKS5maWx0ZXIoKGRvbWFpbikgPT4gZG9tYWluICE9PSBcInJlbGF0aW9uc1wiKS5zb3J0KCkubWFwKChvcHRpb24pID0+IChcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4ga2V5PXtvcHRpb259IHZhbHVlPXtvcHRpb259PntvcHRpb259XG4gICAgICAgICAgICAgICAgICAgICAgPGJyIC8+PHNwYW4gc3R5bGU9e3tjb2xvcjogXCIjNjY2XCIsIGZvbnRTaXplOiBcIjAuNmVtXCJ9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIFByb3BlcnRpZXM6IHthcmNoZXR5cGVbb3B0aW9uXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChwcm9wKSA9PiBwcm9wLnR5cGUgIT09IFwicmVsYXRpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgocHJvcCkgPT4gYCR7cHJvcC5uYW1lfSAoJHtwcm9wLnR5cGV9KWApLmpvaW4oXCIsIFwiKX1cbiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvU2VsZWN0RmllbGQ+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7IG1hcHBpbmdzLmNvbGxlY3Rpb25zW3NoZWV0Lm5hbWVdLmFyY2hldHlwZU5hbWUgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMSBoaS1zdWNjZXNzXCIga2V5PXtzaGVldC5uYW1lfT5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImdseXBoaWNvbiBnbHlwaGljb24tb2sgcHVsbC1yaWdodFwiLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKSA6IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSl9XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJhc2ljLW1hcmdpblwiPlxuICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQ9eyFjb2xsZWN0aW9uc0FyZU1hcHBlZH0gb25DbGljaz17b25TYXZlTmV3TWFwcGluZ1N0YXRlfSBjbGFzc05hbWU9XCJidG4gYnRuLXN1Y2Nlc3NcIj5cbiAgICAgICAgICAgIENvbm5lY3RcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJpZy1tYXJnaW5cIj5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmcm9tLWV4Y2VsXCI+XG4gICAgICAgICAgICA8aW1nIHNyYz1cImltYWdlcy9pY29uLWV4Y2VsLnN2Z1wiIGFsdD1cIlwiLz57XCIgXCJ9XG4gICAgICAgICAgICA8ZW0+e2FjdGl2ZUNvbGxlY3Rpb259PC9lbT4ge3VwbG9hZGVkRmlsZU5hbWUgPyBgZnJvbSAke3VwbG9hZGVkRmlsZU5hbWV9YCA6IFwiXCJ9XG4gICAgICAgICAgPC9wPlxuXG4gICAgICAgICAgPENvbGxlY3Rpb25UYWJsZVxuICAgICAgICAgICAgcm93cz17cm93c31cbiAgICAgICAgICAgIGhlYWRlcnM9e2hlYWRlcnN9XG4gICAgICAgICAgICBuZXh0VXJsPXtuZXh0VXJsfVxuICAgICAgICAgICAgb25Mb2FkTW9yZUNsaWNrPXsodXJsKSA9PiBvbkxvYWRNb3JlQ2xpY2sodXJsLCBhY3RpdmVDb2xsZWN0aW9uKX0gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdFRvQXJjaGV0eXBlOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRGF0YVNldENhcmQgZnJvbSAnLi9kYXRhc2V0Q2FyZC5qc3gnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcm9wcykge1xuICBjb25zdCB7IHZyZXMsIGNhcHRpb24sIHVzZXJJZCwgc2VhcmNoR3VpVXJsLCBtaW5lLCBvbkNvbnRpbnVlTWFwcGluZywgb25EZWxldGVWcmVDbGljayB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJiYXNpYy1tYXJnaW5cIj5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgICA8aDM+e2NhcHRpb259PC9oMz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJiaWctbWFyZ2luXCI+XG4gICAgICAgIHsgT2JqZWN0LmtleXModnJlcykuZmlsdGVyKCh2cmUpID0+ICF2cmVzW3ZyZV0uZGVsZXRlUGVuZGluZykubWFwKCh2cmUpID0+IChcbiAgICAgICAgICA8RGF0YVNldENhcmQga2V5PXt2cmV9IG1pbmU9e21pbmV9IHB1Ymxpc2hlZD17dnJlc1t2cmVdLnB1Ymxpc2hlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgcHVibGlzaFN0YXRlPXt2cmVzW3ZyZV0ucHVibGlzaFN0YXRlfVxuICAgICAgICAgICAgICAgICAgICAgICB2cmVNZXRhZGF0YT17dnJlc1t2cmVdLnZyZU1ldGFkYXRhfVxuICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hHdWlVcmw9e3NlYXJjaEd1aVVybH1cbiAgICAgICAgICAgICAgICAgICAgICAgb25Db250aW51ZU1hcHBpbmc9e29uQ29udGludWVNYXBwaW5nfSBvbkRlbGV0ZVZyZUNsaWNrPXtvbkRlbGV0ZVZyZUNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ9e3VzZXJJZH0gdnJlSWQ9e3ZyZXNbdnJlXS5uYW1lfSBjYXB0aW9uPXt2cmVzW3ZyZV0ubGFiZWx9IC8+XG4gICAgICAgICkpfVxuICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufTsiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgVXBsb2FkQnV0dG9uIGZyb20gXCIuL3VwbG9hZC1idXR0b25cIjtcbmltcG9ydCBQdWJsaXNoU3RhdGUgZnJvbSBcIi4uL3V0aWwvcHVibGlzaC1zdGF0ZVwiO1xuaW1wb3J0IE1lc3NhZ2UgZnJvbSBcIi4vbWVzc2FnZVwiO1xuaW1wb3J0IGF2YWlsYWJsZUNvbG9yQ29kZXMgZnJvbSBcIi4uL3V0aWwvY29sb3ItY29kZXNcIjtcblxuY29uc3QgZ2V0TWFwcGluZ1N0YXRlID0gKHB1Ymxpc2hTdGF0ZSwgdXBsb2FkU3RhdHVzKSA9PiB7XG4gIHN3aXRjaCAocHVibGlzaFN0YXRlKSB7XG4gICAgY2FzZSBQdWJsaXNoU3RhdGUuTUFQUElOR19DUkVBVElPTjpcbiAgICBjYXNlIFB1Ymxpc2hTdGF0ZS5NQVBQSU5HX0NSRUFUSU9OX0FGVEVSX0VSUk9SUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWVFZGl0RGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb250aW51ZURpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZWRpdERpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZWRpdFBsYWNlSG9sZGVyOiBudWxsLFxuICAgICAgICBzdGF0dXNNZXNzYWdlOiBcIlVwbG9hZCBpcyBmaW5pc2hlZC4gUGxlYXNlIGVudGVyIHNvbWUgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgeW91ciBwcm9qZWN0XCIsXG4gICAgICAgIHRpdGxlOiBcIkRhdGFzZXQgc2V0dGluZ3NcIixcbiAgICAgICAgdXBsb2FkQnV0dG9uU3RhdHVzOiB1cGxvYWRTdGF0dXMgfHwgbnVsbCxcbiAgICAgICAgdXBsb2FkQnV0dG9uTGFiZWw6IFwiVXBsb2FkIGEgbmV3IGZpbGVcIlxuICAgICAgfTtcbiAgICBjYXNlIFB1Ymxpc2hTdGF0ZS5VUExPQURJTkc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lRWRpdERpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgY29udGludWVEaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgZWRpdERpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZWRpdFBsYWNlSG9sZGVyOiBudWxsLFxuICAgICAgICBzdGF0dXNNZXNzYWdlOiBcIlVwbG9hZGluZyBkYXRhXCIsXG4gICAgICAgIHRpdGxlOiBcIkRhdGFzZXQgc2V0dGluZ3NcIixcbiAgICAgICAgdXBsb2FkQnV0dG9uU3RhdHVzOiB1cGxvYWRTdGF0dXMgfHwgXCJVcGxvYWRpbmcgcGxlYXNlIHdhaXQuLi5cIlxuICAgICAgfTtcbiAgICBjYXNlIFB1Ymxpc2hTdGF0ZS5NQVBQSU5HX0VYRUNVVElPTjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWVFZGl0RGlzYWJsZWQ6IHRydWUsXG4gICAgICAgIGNvbnRpbnVlRGlzYWJsZWQ6IHRydWUsXG4gICAgICAgIGVkaXREaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgZWRpdFBsYWNlSG9sZGVyOiBcIlRoaXMgZGF0YXNldCBpcyBjdXJyZW50bHkgYmVpbmcgcHVibGlzaGVkIGFuIG1heSBub3QgYmUgZWRpdGVkXCIsXG4gICAgICAgIHN0YXR1c01lc3NhZ2U6IFwiVGhpcyBkYXRhc2V0IGlzIGN1cnJlbnRseSBiZWluZyBwdWJsaXNoZWQgYW4gbWF5IG5vdCBiZSBlZGl0ZWRcIixcbiAgICAgICAgdGl0bGU6IFwiRGF0YXNldCBzZXR0aW5nc1wiLFxuICAgICAgICB1cGxvYWRCdXR0b25TdGF0dXM6IFwiVGhpcyBkYXRhc2V0IGlzIGN1cnJlbnRseSBiZWluZyBwdWJsaXNoZWQgYW4gbWF5IG5vdCBiZSBlZGl0ZWRcIlxuICAgICAgfTtcbiAgICBjYXNlIFB1Ymxpc2hTdGF0ZS5BVkFJTEFCTEU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lRWRpdERpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgY29udGludWVEaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgZWRpdERpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZWRpdFBsYWNlSG9sZGVyOiBudWxsLFxuICAgICAgICBzdGF0dXNNZXNzYWdlOiB1cGxvYWRTdGF0dXMgfHwgXCJUaGlzIGRhdGFzZXQgaXMgYWxyZWFkeSBwdWJsaXNoZWQuIFlvdSBjYW4gZWRpdCB0aGUgc2V0dGluZ3MgZnJvbSBoZXJlLlwiLFxuICAgICAgICB0aXRsZTogXCJEYXRhc2V0IHNldHRpbmdzXCIsXG4gICAgICAgIHVwbG9hZEJ1dHRvblN0YXR1czogXCJUaGlzIGRhdGFzZXQgaXMgYWxyZWFkeSBwdWJsaXNoZWRcIixcbiAgICAgICAgdXBsb2FkQnV0dG9uTGFiZWw6IFwiUmUtVXBsb2FkIChkZWxldGVzIGN1cnJlbnRseSBwdWJsaXNoZWQgZGF0YSlcIlxuICAgICAgfVxuICB9XG4gIHJldHVybiAge1xuICAgIG5hbWVFZGl0RGlzYWJsZWQ6IGZhbHNlLFxuICAgIGNvbnRpbnVlRGlzYWJsZWQ6IHRydWUsXG4gICAgZWRpdERpc2FibGVkOiB0cnVlLFxuICAgIGVkaXRQbGFjZWhvbGRlcjogXCJQbGVhc2UgdXBsb2FkIGEgZGF0YXNldCBmaXJzdC4uLlwiLFxuICAgIHVwbG9hZEJ1dHRvblN0YXR1czogdXBsb2FkU3RhdHVzIHx8IG51bGwsXG4gICAgc3RhdHVzTWVzc2FnZTogXCJUbyBjcmVhdGUgZSBuZXcgZGF0YXNldCwgcGxlYXNlIGVudGVyIHNvbWUgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgeW91ciBwcm9qZWN0XCIsXG4gICAgdGl0bGU6IFwiQ3JlYXRlIGEgbmV3IGRhdGFzZXRcIixcbiAgICB1cGxvYWRCdXR0b25MYWJlbDogXCJCcm93c2UuLi5cIlxuICB9XG59O1xuXG5cbmNsYXNzIERhdGFzZXRTZXR0aW5ncyBleHRlbmRzICBSZWFjdC5Db21wb25lbnQge1xuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy52cmVJZCAhPT0gdGhpcy5wcm9wcy52cmVJZCkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNsZWFyRm9ybVNldHRpbmdEYXRhKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5wcm9wcy5vbkNsZWFyRm9ybVNldHRpbmdEYXRhKCk7XG4gIH1cblxuICBvbkNoYW5nZShldikge1xuICAgIGNvbnN0IHNhbml0aXplZCA9IGV2LnRhcmdldC52YWx1ZVxuICAgICAgLnJlcGxhY2UoL1teYS16QS1aXFxzXFwtXSsvLCBcIlwiKVxuICAgICAgLnJlcGxhY2UoL15cXHMqLywgXCJcIik7XG5cbiAgICB0aGlzLnByb3BzLm9uU2V0TmV3VnJlTmFtZShzYW5pdGl6ZWQpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld1ZyZU5hbWUsXG4gICAgICBuZXdEZXNjcmlwdGlvbixcbiAgICAgIG5ld1Byb3ZlbmFuY2UsXG4gICAgICBuZXdDb2xvckNvZGUsXG4gICAgICBvblVwbG9hZEZpbGVTZWxlY3QsXG4gICAgICB1cGxvYWRTdGF0dXMsXG4gICAgICBwdWJsaXNoU3RhdGUsXG4gICAgICB2cmVJZCxcbiAgICAgIHVwbG9hZGVkRmlsZU5hbWUsXG4gICAgICBvbkNvbnRpbnVlTWFwcGluZyxcbiAgICAgIG9uU2F2ZVZyZVNldHRpbmdzLFxuICAgICAgb25TZXROZXdEZXNjcmlwdGlvbixcbiAgICAgIG9uU2V0TmV3UHJvdmVuYW5jZSxcbiAgICAgIG9uU2V0TmV3Q29sb3JDb2RlLFxuICAgICAgb25VcGxvYWRJbWFnZSxcbiAgICAgIG9uQ2xvc2VJbWFnZUVycm9yLFxuICAgICAgaW1hZ2VVcGxvYWRTdGF0dXMsXG4gICAgICBpbWFnZVVwbG9hZEVycm9yTWVzc2FnZSxcbiAgICAgIGltYWdlVXJsLFxuICAgICAgdXBsb2FkZWRGaWxlbmFtZUZyb21WcmVcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGZpbmFsVnJlTmFtZSA9IG5ld1ZyZU5hbWUgP1xuICAgICAgbmV3VnJlTmFtZS5yZXBsYWNlKC9cXHMqJC8sIFwiXCIpIDogbnVsbDtcblxuICAgIGNvbnN0IHtcbiAgICAgIG5hbWVFZGl0RGlzYWJsZWQsXG4gICAgICBjb250aW51ZURpc2FibGVkLFxuICAgICAgZWRpdFBsYWNlaG9sZGVyLFxuICAgICAgZWRpdERpc2FibGVkLFxuICAgICAgc3RhdHVzTWVzc2FnZSxcbiAgICAgIHRpdGxlLFxuICAgICAgdXBsb2FkQnV0dG9uU3RhdHVzLFxuICAgICAgdXBsb2FkQnV0dG9uTGFiZWxcbiAgICB9ID0gZ2V0TWFwcGluZ1N0YXRlKHB1Ymxpc2hTdGF0ZSwgdXBsb2FkU3RhdHVzKTtcblxuICAgIGNvbnN0IGltYWdlRXJyb3IgPSBpbWFnZVVwbG9hZEVycm9yTWVzc2FnZVxuICAgICAgPyA8TWVzc2FnZSBhbGVydExldmVsPVwiZGFuZ2VyXCIgb25DbG9zZU1lc3NhZ2U9e29uQ2xvc2VJbWFnZUVycm9yfSBkaXNtaXNzaWJsZT17dHJ1ZX0+e2ltYWdlVXBsb2FkRXJyb3JNZXNzYWdlfTwvTWVzc2FnZT5cbiAgICAgIDogbnVsbDtcblxuICAgIGNvbnN0IGltYWdlVGFnID0gaW1hZ2VVcmxcbiAgICAgID8gPGltZyBzcmM9e2ltYWdlVXJsfSBzdHlsZT17e21heFdpZHRoOiBcIjEwMCVcIn19IC8+XG4gICAgICA6IG51bGw7XG5cbiAgICBjb25zdCBpbWFnZVN0eWxlID0gaW1hZ2VVcmwgPyB7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJHtpbWFnZVVybH0pYCxcbiAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJjZW50ZXIgY2VudGVyXCIsXG4gICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgICAgYmFja2dyb3VuZEJsZW5kTW9kZTogXCJtdWx0aXBseVwiLFxuICAgICAgYmFja2dyb3VuZFNpemU6IFwiMTI1JSBhdXRvXCIsXG4gICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0gOiB7fTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBiYXNpYy1tYXJnaW5cIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwic21hbGwtbWFyZ2luXCI+XG4gICAgICAgICAgICB7dGl0bGV9XG4gICAgICAgICAgPC9oMj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC05XCI+XG4gICAgICAgICAgICB7c3RhdHVzTWVzc2FnZX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC0zIGFsZXJ0IGFsZXJ0LWluZm8gYWxlcnQtZGlzbWlzc2libGVcIiByb2xlPVwiYWxlcnRcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImdseXBoaWNvbiBnbHlwaGljb24tcGxheS1jaXJjbGVcIi8+IFdhdGNoIGEgMyBtaW4gdmlkZW8gdG8gY3JlYXRlIGEgbmV3IGRhdGFzZXQuXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIGJhc2ljLW1hcmdpblwiPlxuICAgICAgICAgIDxoND5UaXRsZTwvaDQ+XG4gICAgICAgICAgPGlucHV0IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIHR5cGU9XCJ0ZXh0XCIgZGlzYWJsZWQ9e25hbWVFZGl0RGlzYWJsZWR9IHBsYWNlaG9sZGVyPVwiRW50ZXIgZGF0YXNldCBuYW1lXCIgdmFsdWU9e25ld1ZyZU5hbWUgfHwgXCJcIn0gb25DaGFuZ2U9e3RoaXMub25DaGFuZ2UuYmluZCh0aGlzKX0gLz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgYmFzaWMtbWFyZ2luXCI+XG4gICAgICAgICAgPGg0PlVwbG9hZCBFeGNlbCBmaWxlPC9oND5cbiAgICAgICAgICAgIDxVcGxvYWRCdXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lcz17W1wiYnRuXCIsIFwiYnRuLXByaW1hcnlcIl19XG4gICAgICAgICAgICAgIHVwbG9hZFN0YXR1cz17ZmluYWxWcmVOYW1lID09PSBudWxsID8gXCJQbGVhc2UgZW50ZXIgYSB0aXRsZSBmaXJzdC4uLlwiIDogdXBsb2FkQnV0dG9uU3RhdHVzfVxuICAgICAgICAgICAgICB2cmVOYW1lPXt2cmVJZCA/IG51bGwgOiBmaW5hbFZyZU5hbWV9XG4gICAgICAgICAgICAgIHZyZUlkPXt2cmVJZH1cbiAgICAgICAgICAgICAgbGFiZWw9e3VwbG9hZEJ1dHRvbkxhYmVsfVxuICAgICAgICAgICAgICBmbG9hdD1cImxlZnRcIlxuICAgICAgICAgICAgICBvblVwbG9hZEZpbGVTZWxlY3Q9e29uVXBsb2FkRmlsZVNlbGVjdH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiBkaXNhYmxlZD17dHJ1ZX0gdmFsdWU9e3VwbG9hZGVkRmlsZU5hbWUgfHwgdXBsb2FkZWRGaWxlbmFtZUZyb21WcmV9IHN0eWxlPXt7bWF4V2lkdGg6IFwiNDAwcHhcIn19IC8+XG4gICAgICAgIDwvZGl2PlxuXG5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBiYXNpYy1tYXJnaW5cIj5cbiAgICAgICAgICA8aDQ+RGVzY3JpcHRpb248L2g0PlxuICAgICAgICAgIDx0ZXh0YXJlYSBkaXNhYmxlZD17ZWRpdERpc2FibGVkfSB2YWx1ZT17bmV3RGVzY3JpcHRpb259IG9uQ2hhbmdlPXsoZXYpID0+IHsgb25TZXROZXdEZXNjcmlwdGlvbihldi50YXJnZXQudmFsdWUpfX1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2VkaXRQbGFjZWhvbGRlciB8fCBcIkVudGVyIGEgZGVzY3JpcHRpb24uLi5cIn0gY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgcm93cz1cIjNcIiAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBiYXNpYy1tYXJnaW5cIj5cbiAgICAgICAgICA8aDQ+UHJvdmVuYW5jZTwvaDQ+XG4gICAgICAgICAgPHRleHRhcmVhIGRpc2FibGVkPXtlZGl0RGlzYWJsZWR9IHZhbHVlPXtuZXdQcm92ZW5hbmNlfSBvbkNoYW5nZT17KGV2KSA9PiB7IG9uU2V0TmV3UHJvdmVuYW5jZShldi50YXJnZXQudmFsdWUpfX1cbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9e2VkaXRQbGFjZWhvbGRlciB8fCBcIkVudGVyIHByb3ZlbmFuY2UuLi5cIn0gY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgcm93cz1cIjNcIiAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciBiYXNpYy1tYXJnaW5cIj5cbiAgICAgICAgICB7aW1hZ2VFcnJvcn1cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgICA8aDQ+Q29sb3I8L2g0PlxuICAgICAgICAgICAgICB7ZWRpdERpc2FibGVkXG4gICAgICAgICAgICAgICAgPyA8ZGl2PntlZGl0UGxhY2Vob2xkZXJ9PC9kaXY+XG4gICAgICAgICAgICAgICAgOiBhdmFpbGFibGVDb2xvckNvZGVzLm1hcCgoY29sb3JDb2RlKSA9PlxuICAgICAgICAgICAgICAgIDxhIGtleT17Y29sb3JDb2RlfSBzdHlsZT17e2Zsb2F0OiBcImxlZnRcIiwgd2lkdGg6IFwiNDBweFwiLCBjdXJzb3I6IFwicG9pbnRlclwiLCBmb250V2VpZ2h0OiBjb2xvckNvZGUgPT09IG5ld0NvbG9yQ29kZSA/IFwiNTAwXCIgOiBcIjMwMFwifX0gb25DbGljaz17KCkgPT4gb25TZXROZXdDb2xvckNvZGUoY29sb3JDb2RlKX0+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17e2JvcmRlclJhZGl1czogY29sb3JDb2RlID09PSBuZXdDb2xvckNvZGUgPyBcIjhweFwiIDogXCIxMnB4XCIsIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsIGJvcmRlcjogYDhweCBzb2xpZCAke2NvbG9yQ29kZSA9PT0gbmV3Q29sb3JDb2RlID8gYCMke2NvbG9yQ29kZX1gIDogXCJ3aGl0ZVwifWAsIHdpZHRoOiBcIjQwcHhcIiwgaGVpZ2h0OiBcIjQwcHhcIiwgYmFja2dyb3VuZENvbG9yOiBgIyR7Y29sb3JDb2RlfWB9fSAvPntcIiBcIn1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZC1kYXRhc2V0XCIgc3R5bGU9e3tjbGVhcjogXCJsZWZ0XCIsIG1hcmdpblRvcDogXCIyMHB4XCJ9fT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHRpdGxlPXtmaW5hbFZyZU5hbWV9IHN0eWxlPXt7Li4uaW1hZ2VTdHlsZSwgYmFja2dyb3VuZENvbG9yOiBuZXdDb2xvckNvZGUgPyBgIyR7bmV3Q29sb3JDb2RlfWAgOiBcIiNlNmU2ZTZcIn19XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYXJkLWRhdGFzZXQgYnRuIGJ0bi1kZWZhdWx0IGV4cGxvcmVcIj5cbiAgICAgICAgICAgICAgICAgIDxzdHJvbmcgc3R5bGU9e3tkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLCBvdmVyZmxvdzogXCJoaWRkZW5cIiwgd2lkdGg6IFwiOTAlXCIsIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsIHRleHRPdmVyZmxvdzogXCJlbGxpcHNpc1wifX0+XG4gICAgICAgICAgICAgICAgICAgIHtmaW5hbFZyZU5hbWV9XG4gICAgICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC02XCI+XG4gICAgICAgICAgICAgIDxoND5EYXRhc2V0IGlsbHVzdHJhdGlvbjwvaDQ+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICA8VXBsb2FkQnV0dG9uXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWVzPXtbXCJidG5cIiwgXCJidG4tcHJpbWFyeVwiXX1cbiAgICAgICAgICAgICAgICAgIHZyZUlkPXt2cmVJZH1cbiAgICAgICAgICAgICAgICAgIGFjY2VwdD1cImltYWdlL2pwZWcsaW1hZ2UvZ2lmLGltYWdlL3BuZ1wiXG4gICAgICAgICAgICAgICAgICB1cGxvYWRTdGF0dXM9e2ltYWdlVXBsb2FkU3RhdHVzIHx8IGVkaXRQbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgIGxhYmVsPVwiQnJvd3NlLi4uXCJcbiAgICAgICAgICAgICAgICAgIGZsb2F0PVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICBvblVwbG9hZEZpbGVTZWxlY3Q9eyhmaWxlcykgPT4gb25VcGxvYWRJbWFnZSh2cmVJZCwgZmlsZXMpfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7aW1hZ2VUYWd9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXIgYmFzaWMtbWFyZ2luXCI+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLWRlZmF1bHQgcHVsbC1yaWdodFwiIGRpc2FibGVkPXtjb250aW51ZURpc2FibGVkfSBvbkNsaWNrPXsoKSA9PiBvblNhdmVWcmVTZXR0aW5ncyh2cmVJZCwgKCkgPT4gb25Db250aW51ZU1hcHBpbmcodnJlSWQpKX0+XG4gICAgICAgICAgICBTYXZlIHNldHRpbmdzIGFuZCBjb250aW51ZSB0byBtYXBwaW5nXG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLWRlZmF1bHQgcHVsbC1yaWdodFwiIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IFwiNHB4XCJ9fSBkaXNhYmxlZD17ZWRpdERpc2FibGVkfSBvbkNsaWNrPXsoKSA9PiBvblNhdmVWcmVTZXR0aW5ncyh2cmVJZCl9PlxuICAgICAgICAgICAgU2F2ZSBzZXR0aW5nc1xuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cblxuXG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YXNldFNldHRpbmdzOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHVibGlzaFN0YXRlIGZyb20gXCIuLi91dGlsL3B1Ymxpc2gtc3RhdGVcIjtcbmltcG9ydCB7IExpbmsgfSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5pbXBvcnQgeyB1cmxzIH0gZnJvbSBcIi4uL3JvdXRlclwiO1xuXG5jb25zdCBnZXRNYXBwaW5nU3RhdGUgPSAocHVibGlzaFN0YXRlKSA9PiB7XG4gIHN3aXRjaCAocHVibGlzaFN0YXRlKSB7XG4gICAgY2FzZSBQdWJsaXNoU3RhdGUuTUFQUElOR19DUkVBVElPTjogcmV0dXJuIHt0ZXh0OiBcIkZpbmlzaCBtYXBwaW5nXCIsIGRpc2FibGVkOiBmYWxzZX07XG4gICAgY2FzZSBQdWJsaXNoU3RhdGUuTUFQUElOR19DUkVBVElPTl9BRlRFUl9FUlJPUlM6IHJldHVybiB7dGV4dDogXCJGaXggbWFwcGluZ3NcIiwgZGlzYWJsZWQ6IGZhbHNlfTtcbiAgICBjYXNlIFB1Ymxpc2hTdGF0ZS5VUExPQURJTkc6IHJldHVybiB7dGV4dDogXCJVcGxvYWRpbmcuLi5cIiwgZGlzYWJsZWQ6IHRydWV9O1xuICAgIGNhc2UgUHVibGlzaFN0YXRlLk1BUFBJTkdfRVhFQ1VUSU9OOiByZXR1cm4ge3RleHQ6IFwiUHVibGlzaGluZ1wiLCBkaXNhYmxlZDogdHJ1ZX07XG4gIH1cbiAgcmV0dXJuIHt0ZXh0OiBcIlwiLCBkaXNhYmxlZDogXCJcIn07XG59O1xuXG5mdW5jdGlvbiBEYXRhU2V0Q2FyZChwcm9wcykge1xuICB2YXIgc2VhcmNoVXJsID0gcHJvcHMuc2VhcmNoR3VpVXJsO1xuXG5cbiAgY29uc3QgeyBjb2xvckNvZGUsIGltYWdlIH0gPSBwcm9wcy52cmVNZXRhZGF0YTtcblxuICBjb25zdCBpbWFnZVN0eWxlID0gaW1hZ2UgPyB7XG4gICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7aW1hZ2V9KWAsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcImNlbnRlciBjZW50ZXJcIixcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgIGJhY2tncm91bmRCbGVuZE1vZGU6IFwibXVsdGlwbHlcIixcbiAgICBiYWNrZ3JvdW5kU2l6ZTogXCIxMjUlIGF1dG9cIixcbiAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gIH0gOiB7fTtcbiAgaWYgKHByb3BzLm1pbmUgJiYgIXByb3BzLnB1Ymxpc2hlZCkge1xuICAgIGNvbnN0IHt0ZXh0LCBkaXNhYmxlZH0gPSBnZXRNYXBwaW5nU3RhdGUocHJvcHMucHVibGlzaFN0YXRlKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWRhdGFzZXRcIiBzdHlsZT17e2hlaWdodDogXCIyODBweFwifX0+XG4gICAgICAgIDxidXR0b24gdGl0bGU9e3Byb3BzLmNhcHRpb259IGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICBzdHlsZT17ey4uLmltYWdlU3R5bGUsIGJhY2tncm91bmRDb2xvcjogY29sb3JDb2RlID8gYCMke2NvbG9yQ29kZX1gIDogXCIjZTZlNmU2XCJ9fVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhcmQtZGF0YXNldCBidG4gYnRuLWRlZmF1bHQgZXhwbG9yZVwiIG9uQ2xpY2s9eygpID0+IHByb3BzLm9uQ29udGludWVNYXBwaW5nKHByb3BzLnZyZUlkKX0+XG4gICAgICAgICAge3RleHR9PGJyIC8+XG4gICAgICAgICAgPHN0cm9uZyBzdHlsZT17e2Rpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsIG92ZXJmbG93OiBcImhpZGRlblwiLCB3aWR0aDogXCI5MCVcIiwgd2hpdGVTcGFjZTogXCJub3dyYXBcIiwgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCJ9fT5cbiAgICAgICAgICAgIHtwcm9wcy5jYXB0aW9uLnJlcGxhY2UoL15bXl9dK18rLywgXCJcIil9XG4gICAgICAgICAgPC9zdHJvbmc+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICB7cHJvcHMudXNlcklkXG4gICAgICAgICAgPyAoXG4gICAgICAgICAgPExpbmsgY2xhc3NOYW1lPVwiY2FyZC1kYXRhc2V0IGJ0biBidG4tZGVmYXVsdFwiIHRvPXt1cmxzLmVkaXREYXRhc2V0KHByb3BzLnZyZUlkKX0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJnbHlwaGljb24gZ2x5cGhpY29uLXdyZW5jaFwiIC8+e1wiIFwifVxuICAgICAgICAgICAgU2V0dGluZ3NcbiAgICAgICAgICA8L0xpbms+XG4gICAgICAgICkgOiBudWxsXG4gICAgICAgIH1cbiAgICAgICAge3Byb3BzLnVzZXJJZFxuICAgICAgICAgID8gKFxuICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZD17ZGlzYWJsZWR9IGNsYXNzTmFtZT1cImNhcmQtZGF0YXNldCBidG4gYnRuLWRlZmF1bHRcIiBvbkNsaWNrPXsoKSA9PiBwcm9wcy5vbkRlbGV0ZVZyZUNsaWNrKHByb3BzLnZyZUlkKX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImdseXBoaWNvbiBnbHlwaGljb24tdHJhc2hcIiAvPntcIiBcIn1cbiAgICAgICAgICAgICAgIERlbGV0ZVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICkgOiBudWxsXG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWRhdGFzZXRcIj5cbiAgICAgIDxhIGNsYXNzTmFtZT1cImNhcmQtZGF0YXNldCBidG4gYnRuLWRlZmF1bHQgZXhwbG9yZVwiXG4gICAgICAgICB0aXRsZT17cHJvcHMuY2FwdGlvbn1cbiAgICAgICAgIHN0eWxlPXt7Li4uaW1hZ2VTdHlsZSwgYmFja2dyb3VuZENvbG9yOiBjb2xvckNvZGUgPyBgIyR7Y29sb3JDb2RlfWAgOiBcIiNlNmU2ZTZcIiB9fVxuICAgICAgICAgaHJlZj17YCR7c2VhcmNoVXJsfT92cmVJZD0ke3Byb3BzLnZyZUlkfWB9IHRhcmdldD1cIl9ibGFua1wiPlxuICAgICAgICA8c3Ryb25nICBzdHlsZT17e2Rpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsIG92ZXJmbG93OiBcImhpZGRlblwiLCB3aWR0aDogXCI5MCVcIiwgd2hpdGVTcGFjZTogXCJub3dyYXBcIiwgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCJ9fT5cbiAgICAgICAgICAgIHtwcm9wcy5jYXB0aW9uLnJlcGxhY2UoL15bXl9dK18rLywgXCJcIil9XG4gICAgICAgIDwvc3Ryb25nPlxuICAgICAgPC9hPlxuICAgICAge3Byb3BzLnVzZXJJZFxuICAgICAgICA/IChcbiAgICAgICAgPExpbmsgY2xhc3NOYW1lPVwiY2FyZC1kYXRhc2V0IGJ0biBidG4tZGVmYXVsdFwiIHRvPXt1cmxzLmVkaXREYXRhc2V0KHByb3BzLnZyZUlkKX0+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZ2x5cGhpY29uIGdseXBoaWNvbi13cmVuY2hcIiAvPntcIiBcIn1cbiAgICAgICAgICBTZXR0aW5nc1xuICAgICAgICA8L0xpbms+XG4gICAgICApIDogbnVsbFxuICAgICAgfVxuICAgICAge3Byb3BzLnVzZXJJZFxuICAgICAgICA/ICg8YSBjbGFzc05hbWU9XCJjYXJkLWRhdGFzZXQgYnRuIGJ0bi1kZWZhdWx0XCJcbiAgICAgICAgICAgICAgaHJlZj17YCR7cHJvY2Vzcy5lbnYuc2VydmVyfS9zdGF0aWMvZWRpdC1ndWkvP3ZyZUlkPSR7cHJvcHMudnJlSWR9JmhzaWQ9JHtwcm9wcy51c2VySWR9YH0gdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJnbHlwaGljb24gZ2x5cGhpY29uLXBlbmNpbFwiIC8+e1wiIFwifVxuICAgICAgICAgICAgRWRpdFxuICAgICAgICAgIDwvYT4pXG4gICAgICAgIDogbnVsbH1cbiAgICAgIHtwcm9wcy51c2VySWRcbiAgICAgICAgPyAoPGEgY2xhc3NOYW1lPVwiY2FyZC1kYXRhc2V0IGJ0biBidG4tZGVmYXVsdFwiIG9uQ2xpY2s9eygpID0+IHByb3BzLm9uRGVsZXRlVnJlQ2xpY2socHJvcHMudnJlSWQpfSBzdHlsZT17e2N1cnNvcjogXCJwb2ludGVyXCJ9fT5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJnbHlwaGljb24gZ2x5cGhpY29uLXRyYXNoXCIgLz57XCIgXCJ9XG4gICAgICAgICAgICBEZWxldGVcbiAgICAgICAgICA8L2E+KVxuICAgICAgICA6IG51bGxcbiAgICAgIH1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVNldENhcmQ7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cblxuY2xhc3MgRGVsZXRlVnJlQ29uZmlybWF0aW9uRm9ybSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgY29uZmlybVZhbHVlOiBcIlwiXG4gICAgfTtcbiAgfVxuXG4gIG9uQ29uZmlybUlucHV0Q2hhbmdlKGV2KSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7Y29uZmlybVZhbHVlOiBldi50YXJnZXQudmFsdWV9KTtcbiAgfVxuXG4gIG9uS2V5UHJlc3MoZXYpIHtcbiAgICBjb25zdCB7IHZyZUlkLCBvbkNvbWZpcm1EZWxldGVWcmUgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBjb25maXJtVmFsdWUgfSA9IHRoaXMuc3RhdGU7XG5cblxuICAgIGlmIChldi5rZXkgPT09IFwiRW50ZXJcIiAmJiB2cmVJZCA9PT0gY29uZmlybVZhbHVlKSB7XG4gICAgICBvbkNvbWZpcm1EZWxldGVWcmUodnJlSWQsIGNvbmZpcm1WYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgdnJlSWQsIG9uQ29tZmlybURlbGV0ZVZyZSwgb25DbG9zZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGNvbmZpcm1WYWx1ZSB9ID0gdGhpcy5zdGF0ZTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtYm9keVwiPlxuICAgICAgICAgIDxwPkFyZSB5b3Ugc3VyZSB5b3Ugd2lzaCB0byBkZWxldGUgdGhlIDxzdHJvbmc+e3ZyZUlkLnJlcGxhY2UoL15bXl9dK18rLywgXCJcIil9PC9zdHJvbmc+IGRhdGFzZXQ/PC9wPlxuICAgICAgICAgIDxwPlRvIGNvbmZpcm0sIHBsZWFzZSByZXR5cGUgdGhlIGZ1bGx5IHF1YWxpZmllZCBkYXRhc2V0IElEIGluIHRoZSBpbnB1dCBiZWxvdy48L3A+XG4gICAgICAgICAgPHAgc3R5bGU9e3t3aWR0aDogXCIxMDAlXCIsIGJhY2tncm91bmRDb2xvcjogXCIjZGRkXCIsIG92ZXJmbG93WDogXCJhdXRvXCIsIHdoaXRlU3BhY2U6IFwibm93cmFwXCJ9fT57dnJlSWR9PC9wPlxuICAgICAgICAgIDxwPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdmFsdWU9e2NvbmZpcm1WYWx1ZX0gb25DaGFuZ2U9e3RoaXMub25Db25maXJtSW5wdXRDaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICBvbktleVByZXNzPXt0aGlzLm9uS2V5UHJlc3MuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIGRhdGFzZXQgSUQgaGVyZVwiIC8+XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWZvb3RlclwiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1kYW5nZXJcIiBvbkNsaWNrPXsoKSA9PiBvbkNvbWZpcm1EZWxldGVWcmUodnJlSWQsIGNvbmZpcm1WYWx1ZSl9IGRpc2FibGVkPXt2cmVJZCAhPT0gY29uZmlybVZhbHVlfT5cbiAgICAgICAgICAgIERlbGV0ZVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuIGJ0bi1kZWZhdWx0XCIgb25DbGljaz17b25DbG9zZX0+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgRGVsZXRlVnJlQ29uZmlybWF0aW9uRm9ybTsiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuXG5cbmNsYXNzIE1vZGFsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyLCBmYWxzZSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIsIGZhbHNlKTtcbiAgfVxuXG4gIGhhbmRsZURvY3VtZW50Q2xpY2soZXYpIHtcbiAgICBpZiAoIVJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLmZpcnN0Q2hpbGQuY29udGFpbnMoZXYudGFyZ2V0KSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgb25DbG9zZSwgaGVhZGVyIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgaGVhZGVyQm9keSA9IGhlYWRlclxuICAgICAgPyA8aDUgY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj57aGVhZGVyfTwvaDU+XG4gICAgICA6IG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbFwiIHN0eWxlPXt7ZGlzcGxheTogXCJibG9ja1wiLCBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgwLDAsMCwwLjQpXCJ9fT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1kaWFsb2dcIj5cblxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtY29udGVudFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJjbG9zZVwiIG9uQ2xpY2s9e29uQ2xvc2V9PiZ0aW1lczs8L2J1dHRvbj5cbiAgICAgICAgICAgICAge2hlYWRlckJvZHl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgTW9kYWw7IiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBjeCBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBTZWxlY3RGaWVsZCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzT3BlbjogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciwgZmFsc2UpO1xuICB9XG5cbiAgdG9nZ2xlU2VsZWN0KCkge1xuICAgIGlmKHRoaXMuc3RhdGUuaXNPcGVuKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtpc09wZW46IGZhbHNlfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzT3BlbjogdHJ1ZX0pO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURvY3VtZW50Q2xpY2soZXYpIHtcbiAgICBjb25zdCB7IGlzT3BlbiB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaXNPcGVuICYmICFSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5jb250YWlucyhldi50YXJnZXQpKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNPcGVuOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgb25DaGFuZ2UsIG9uQ2xlYXIsIHZhbHVlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWRPcHRpb24gPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHRoaXMucHJvcHMuY2hpbGRyZW4pLmZpbHRlcigob3B0KSA9PiBvcHQucHJvcHMudmFsdWUgPT09IHZhbHVlKTtcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkodGhpcy5wcm9wcy5jaGlsZHJlbikuZmlsdGVyKChvcHQpID0+IG9wdC5wcm9wcy50eXBlID09PSBcInBsYWNlaG9sZGVyXCIpO1xuICAgIGNvbnN0IG90aGVyT3B0aW9ucyA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkodGhpcy5wcm9wcy5jaGlsZHJlbikuZmlsdGVyKChvcHQpID0+IG9wdC5wcm9wcy52YWx1ZSAmJiBvcHQucHJvcHMudmFsdWUgIT09IHZhbHVlKTtcblxuICAgIHJldHVybiAoXG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtjeChcImRyb3Bkb3duXCIsIHtvcGVuOiB0aGlzLnN0YXRlLmlzT3Blbn0pfSBzdHlsZT17dGhpcy5wcm9wcy5zdHlsZSB8fCB7fX0+XG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnRuIGJ0bi1ibGFuayBkcm9wZG93bi10b2dnbGVcIiBvbkNsaWNrPXt0aGlzLnRvZ2dsZVNlbGVjdC5iaW5kKHRoaXMpfT5cbiAgICAgICAgICB7c2VsZWN0ZWRPcHRpb24ubGVuZ3RoID8gc2VsZWN0ZWRPcHRpb24gOiBwbGFjZWhvbGRlcn0gPHNwYW4gY2xhc3NOYW1lPVwiY2FyZXRcIiAvPlxuICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICA8dWwgY2xhc3NOYW1lPVwiZHJvcGRvd24tbWVudVwiPlxuICAgICAgICAgIHsgdmFsdWUgPyAoXG4gICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgIDxhIG9uQ2xpY2s9eygpID0+IHsgb25DbGVhcigpOyB0aGlzLnRvZ2dsZVNlbGVjdCgpO319PlxuICAgICAgICAgICAgICAgIC0gY2xlYXIgLVxuICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgIHtvdGhlck9wdGlvbnMubWFwKChvcHRpb24sIGkpID0+IChcbiAgICAgICAgICAgIDxsaSBrZXk9e2l9PlxuICAgICAgICAgICAgICA8YSBzdHlsZT17e2N1cnNvcjogXCJwb2ludGVyXCJ9fSBvbkNsaWNrPXsoKSA9PiB7IG9uQ2hhbmdlKG9wdGlvbi5wcm9wcy52YWx1ZSk7IHRoaXMudG9nZ2xlU2VsZWN0KCk7IH19PntvcHRpb259PC9hPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuU2VsZWN0RmllbGQucHJvcFR5cGVzID0ge1xuICBvbkNoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQ2xlYXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICB2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0RmllbGQ7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmZ1bmN0aW9uIEZpcnN0VXBsb2FkKHByb3BzKSB7XG4gIGNvbnN0IHsgdXNlcklkIH0gPSBwcm9wcztcblxuICBjb25zdCBzYW1wbGVTaGVldCA9IHByb3BzLmV4YW1wbGVTaGVldFVybCA/XG4gICAgPHA+RG9uJ3QgaGF2ZSBhIGRhdGFzZXQgaGFuZHk/IEhlcmXigJlzIGFuIDxhIGhyZWY9e3Byb3BzLmV4YW1wbGVTaGVldFVybH0+ZXhhbXBsZSBleGNlbCBzaGVldDwvYT4uPC9wPiA6IG51bGw7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJqdW1ib3Ryb24gZmlyc3QtdXBsb2FkIHVwbG9hZC1iZ1wiPlxuICAgICAgICA8aDI+VXBsb2FkIHlvdXIgZmlyc3QgZGF0YXNldDwvaDI+XG4gICAgICAgIHtzYW1wbGVTaGVldH1cbiAgICAgICAge3VzZXJJZCA/IHByb3BzLmNoaWxkcmVuIDogKFxuICAgICAgICAgIDxmb3JtIGFjdGlvbj1cImh0dHBzOi8vc2VjdXJlLmh1eWdlbnMua25hdy5ubC9zYW1sMi9sb2dpblwiIG1ldGhvZD1cIlBPU1RcIj5cbiAgICAgICAgICAgIDxpbnB1dCBuYW1lPVwiaHN1cmxcIiAgdHlwZT1cImhpZGRlblwiIHZhbHVlPXt3aW5kb3cubG9jYXRpb24uaHJlZn0gLz5cbiAgICAgICAgICAgIDxwPk1vc3QgdW5pdmVyc2l0eSBhY2NvdW50cyB3aWxsIHdvcmsuPC9wPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnkgYnRuLWxnXCIgdHlwZT1cInN1Ym1pdFwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJnbHlwaGljb24gZ2x5cGhpY29uLWxvZy1pblwiIC8+IExvZyBpbiB0byB1cGxvYWRcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDwvZm9ybT4pIH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBGaXJzdFVwbG9hZDtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuZnVuY3Rpb24gRm9vdGVyKHByb3BzKSB7XG4gIGNvbnN0IGhpTG9nbyA9IChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0xIGNvbC1tZC0xXCI+XG4gICAgICA8aW1nIGNsYXNzTmFtZT1cImhpLWxvZ29cIiBzcmM9XCJpbWFnZXMvbG9nby1odXlnZW5zLWluZy5zdmdcIiAvPlxuICAgIDwvZGl2PlxuICApO1xuXG4gIGNvbnN0IGNsYXJpYWhMb2dvID0gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTEgY29sLW1kLTFcIj5cbiAgICAgIDxpbWcgY2xhc3NOYW1lPVwibG9nb1wiIHNyYz1cImltYWdlcy9sb2dvLWNsYXJpYWguc3ZnXCIgLz5cbiAgICA8L2Rpdj5cbiAgKTtcblxuICBjb25zdCBmb290ZXJCb2R5ID0gUmVhY3QuQ2hpbGRyZW4uY291bnQocHJvcHMuY2hpbGRyZW4pID4gMCA/XG4gICAgUmVhY3QuQ2hpbGRyZW4ubWFwKHByb3BzLmNoaWxkcmVuLCAoY2hpbGQsIGkpID0+IChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2hpdGUtYmFyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyXCI+XG4gICAgICAgICAge2kgPT09IFJlYWN0LkNoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSAtIDFcbiAgICAgICAgICAgID8gKDxkaXYgY2xhc3NOYW1lPVwicm93XCI+e2hpTG9nb308ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0xMCBjb2wtbWQtMTAgdGV4dC1jZW50ZXJcIj57Y2hpbGR9PC9kaXY+e2NsYXJpYWhMb2dvfTwvZGl2PilcbiAgICAgICAgICAgIDogKDxkaXYgY2xhc3NOYW1lPVwicm93XCI+PGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMTIgY29sLW1kLTEyIHRleHQtY2VudGVyXCI+e2NoaWxkfTwvZGl2PjwvZGl2PilcbiAgICAgICAgICB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKSkgOiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIndoaXRlLWJhclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgICAgICB7aGlMb2dvfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMTAgY29sLW1kLTEwIHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHtjbGFyaWFoTG9nb31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuXG5cbiAgcmV0dXJuIChcbiAgICA8Zm9vdGVyIGNsYXNzTmFtZT1cImZvb3RlclwiPlxuICAgICAge2Zvb3RlckJvZHl9XG4gICAgPC9mb290ZXI+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgRm9vdGVyOyIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjeCBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwcm9wcykge1xuICBjb25zdCB7IGRpc21pc3NpYmxlLCBhbGVydExldmVsLCBvbkNsb3NlTWVzc2FnZX0gPSBwcm9wcztcbiAgY29uc3QgZGlzbWlzc0J1dHRvbiA9IGRpc21pc3NpYmxlXG4gICAgPyA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9XCJjbG9zZVwiIG9uQ2xpY2s9e29uQ2xvc2VNZXNzYWdlfT48c3Bhbj4mdGltZXM7PC9zcGFuPjwvYnV0dG9uPlxuICAgIDogbnVsbDtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjeChcImFsZXJ0XCIsIGBhbGVydC0ke2FsZXJ0TGV2ZWx9YCwge1wiYWxlcnQtZGlzbWlzc2libGVcIjogZGlzbWlzc2libGV9KX0gcm9sZT1cImFsZXJ0XCI+XG4gICAgICB7ZGlzbWlzc0J1dHRvbn1cbiAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICA8L2Rpdj5cbiAgKVxufTsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IERhdGFzZXRDYXJkcyBmcm9tIFwiLi9kYXRhc2V0LWNhcmRzXCI7XG5pbXBvcnQgRm9vdGVyIGZyb20gXCIuL2Zvb3RlclwiO1xuXG5jb25zdCBGT09URVJfSEVJR0hUID0gODE7XG5cbmZ1bmN0aW9uIFBhZ2UocHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInBhZ2VcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmFzaWMtbWFyZ2luIGhpLUdyZWVuIGNvbnRhaW5lci1mbHVpZFwiPlxuICAgICAgICA8bmF2IGNsYXNzTmFtZT1cIm5hdmJhciBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXZiYXItaGVhZGVyXCI+IDxhIGNsYXNzTmFtZT1cIm5hdmJhci1icmFuZFwiIGhyZWY9XCIjXCI+PGltZyBzcmM9XCJpbWFnZXMvbG9nby10aW1idWN0b28uc3ZnXCIgY2xhc3NOYW1lPVwibG9nb1wiIGFsdD1cInRpbWJ1Y3Rvb1wiLz48L2E+IDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBpZD1cIm5hdmJhclwiIGNsYXNzTmFtZT1cIm5hdmJhci1jb2xsYXBzZSBjb2xsYXBzZVwiPlxuICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwibmF2IG5hdmJhci1uYXYgbmF2YmFyLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAge3Byb3BzLnVzZXJuYW1lID8gPGxpPjxhIGhyZWY9e3Byb3BzLnVzZXJsb2NhdGlvbiB8fCAnIyd9PjxzcGFuIGNsYXNzTmFtZT1cImdseXBoaWNvbiBnbHlwaGljb24tdXNlclwiLz4ge3Byb3BzLnVzZXJuYW1lfTwvYT48L2xpPiA6IG51bGx9XG4gICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uYXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgIHN0eWxlPXt7bWFyZ2luQm90dG9tOiBgJHtGT09URVJfSEVJR0hUfXB4YH19PlxuICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICAgIHtwcm9wcy52cmVzICYmIHByb3BzLnNob3dEYXRhc2V0cyA/IChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPERhdGFzZXRDYXJkcyBjYXB0aW9uPVwiRXhwbG9yZSBhbGwgZGF0YXNldHNcIiB2cmVzPXtwcm9wcy52cmVzfSBzZWFyY2hHdWlVcmw9e3Byb3BzLnNlYXJjaEd1aVVybH0gb25EZWxldGVWcmVDbGljaz17cHJvcHMub25EZWxldGVWcmVDbGlja30gLz5cbiAgICAgICAgICA8L2Rpdj4pIDogbnVsbH1cbiAgICAgIDwvZGl2PlxuICAgICAgPEZvb3RlciAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBQYWdlO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IGN4IGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbmNsYXNzIERhdGFSb3cgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHJvdyB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPHRyPlxuICAgICAgICB7cm93Lm1hcCgoY2VsbCwgaSkgPT4gKFxuICAgICAgICAgIDx0ZCBjbGFzc05hbWU9e2N4KHtcbiAgICAgICAgICAgIGRhbmdlcjogY2VsbC5lcnJvciA/IHRydWUgOiBmYWxzZVxuICAgICAgICAgIH0pfSBrZXk9e2l9PlxuICAgICAgICAgICAge2NlbGwudmFsdWV9XG4gICAgICAgICAgICB7Y2VsbC5lcnJvciA/IDxzcGFuIGNsYXNzTmFtZT1cInB1bGwtcmlnaHQgZ2x5cGhpY29uIGdseXBoaWNvbi1leGNsYW1hdGlvbi1zaWduXCIgc3R5bGU9e3tjdXJzb3I6IFwicG9pbnRlclwifX0gdGl0bGU9e2NlbGwuZXJyb3J9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L3RkPlxuICAgICAgICApKX1cbiAgICAgIDwvdHI+XG4gICAgKTtcbiAgfVxufVxuXG5EYXRhUm93LnByb3BUeXBlcyA9IHtcbiAgcm93OiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXksXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhUm93OyIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjeCBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBIZWFkZXJDZWxsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBoZWFkZXIsIGlzQ29uZmlybWVkIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0aCBjbGFzc05hbWU9e2N4KHtcbiAgICAgICAgc3VjY2VzczogaXNDb25maXJtZWQsXG4gICAgICAgIGluZm86ICFpc0NvbmZpcm1lZFxuICAgICAgfSl9PlxuICAgICAgICB7aGVhZGVyfVxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2N4KFwicHVsbC1yaWdodFwiLCBcImdseXBoaWNvblwiLCB7XG4gICAgICAgICAgXCJnbHlwaGljb24tb2stc2lnblwiOiBpc0NvbmZpcm1lZCxcbiAgICAgICAgICBcImdseXBoaWNvbi1xdWVzdGlvbi1zaWduXCI6ICFpc0NvbmZpcm1lZCxcbiAgICAgICAgfSl9PlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L3RoPlxuICAgICk7XG4gIH1cbn1cblxuSGVhZGVyQ2VsbC5wcm9wVHlwZXMgPSB7XG4gIGhlYWRlcjogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgaXNDb25maXJtZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBIZWFkZXJDZWxsOyIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBjeCBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBVcGxvYWRCdXR0b24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZXMsIHJlZGlyZWN0UGF0aCwgdXBsb2FkU3RhdHVzLCBvblVwbG9hZEZpbGVTZWxlY3QsIGdseXBoaWNvbiwgbGFiZWwsIHZyZU5hbWUsIHZyZUlkLCBmbG9hdCwgYWNjZXB0IH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAoXG4gICAgICA8Zm9ybSBzdHlsZT17e2Rpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsIGZsb2F0OiBmbG9hdCB8fCBcInJpZ2h0XCJ9fT5cbiAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT17Y3goLi4uY2xhc3NOYW1lcywge2Rpc2FibGVkOiAhIXVwbG9hZFN0YXR1c30pfT5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2dseXBoaWNvbn0+PC9zcGFuPlxuICAgICAgICAgIHtcIiBcIn1cbiAgICAgICAgICB7dXBsb2FkU3RhdHVzIHx8IGxhYmVsfVxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgZGlzYWJsZWQ9eyEhdXBsb2FkU3RhdHVzfVxuICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gb25VcGxvYWRGaWxlU2VsZWN0KGUudGFyZ2V0LmZpbGVzLCB7XG4gICAgICAgICAgICAgIHZyZU5hbWU6IHZyZU5hbWUsXG4gICAgICAgICAgICAgIHZyZUlkOiB2cmVJZCxcbiAgICAgICAgICAgICAgcmVkaXJlY3RUbzogcmVkaXJlY3RQYXRoIHx8IG51bGxcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgYWNjZXB0PXthY2NlcHQgfHwgXCIqXCJ9XG4gICAgICAgICAgICBzdHlsZT17e2Rpc3BsYXk6IFwibm9uZVwifX1cbiAgICAgICAgICAgIHR5cGU9XCJmaWxlXCIgLz5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZm9ybT5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVwbG9hZEJ1dHRvbjsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcHBTdGF0ZSkge1xuICByZXR1cm4ge1xuICAgIHVzZXJJZDogYXBwU3RhdGUudXNlcmRhdGEudXNlcklkLFxuICAgIHZyZXM6IGFwcFN0YXRlLnVzZXJkYXRhLm15VnJlcyB8fCB7fSxcbiAgICBzZWFyY2hHdWlVcmw6IGFwcFN0YXRlLmRhdGFzZXRzLnNlYXJjaEd1aVVybCxcbiAgICBzaG93RGVsZXRlVnJlTW9kYWxGb3I6IGFwcFN0YXRlLmRhdGFzZXRzLnZyZUlkT2ZEZWxldGVWcmVNb2RhbCxcbiAgICBzaG93RGVsZXRlVnJlRmFpbGVkTWVzc2FnZTogYXBwU3RhdGUubWVzc2FnZXMuc2hvd0RlbGV0ZVZyZUZhaWxlZE1lc3NhZ2VcbiAgfVxufSIsImltcG9ydCB7IHRyYW5zZm9ybUNvbGxlY3Rpb25Sb3dzLCB0cmFuc2Zvcm1Db2xsZWN0aW9uQ29sdW1ucywgZ2V0Q29sdW1uSW5mbyB9IGZyb20gXCIuL3RyYW5zZm9ybWVycy90YWJsZVwiO1xuaW1wb3J0IHsgdHJhbnNmb3JtQ29sbGVjdGlvblRhYnMgfSBmcm9tIFwiLi90cmFuc2Zvcm1lcnMvdGFic1wiXG5pbXBvcnQgZ2VuZXJhdGVSbWxNYXBwaW5nIGZyb20gXCIuLi91dGlsL2dlbmVyYXRlLXJtbC1tYXBwaW5nXCI7XG5pbXBvcnQge3VuaXF9IGZyb20gXCIuLi91dGlsL3VuaXFcIjtcbmltcG9ydCBQdWJsaXNoU3RhdGUgZnJvbSBcIi4uL3V0aWwvcHVibGlzaC1zdGF0ZVwiO1xuXG5mdW5jdGlvbiBnZXRUYXJnZXRhYmxlVnJlcyhtaW5lLCB2cmVzLCBhY3RpdmVWcmUpIHtcbiAgY29uc3QgbXlWcmVzID0gT2JqZWN0LmtleXMobWluZSB8fCB7fSlcbiAgICAubWFwKChrZXkpID0+IG1pbmVba2V5XSlcbiAgICAuZmlsdGVyKCh2cmUpID0+IHZyZS5wdWJsaXNoZWQpXG4gICAgLm1hcCgodnJlKSA9PiB2cmUubmFtZSk7XG4gIGNvbnN0IHB1YmxpY1ZyZXMgPSBPYmplY3Qua2V5cyh2cmVzIHx8IHt9KVxuICAgIC5tYXAoKGtleSkgPT4gdnJlc1trZXldLm5hbWUpO1xuXG4gIHJldHVybiBteVZyZXMuY29uY2F0KHB1YmxpY1ZyZXMpLnJlZHVjZSh1bmlxLCBbXSkuZmlsdGVyKHZyZSA9PiB2cmUgIT09IGFjdGl2ZVZyZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChhcHBTdGF0ZSwgcm91dGVkKSA9PiB7XG5cbiAgY29uc3QgeyBjb2xsZWN0aW9ucyB9ID0gYXBwU3RhdGUuaW1wb3J0RGF0YTtcbiAgY29uc3QgeyBtYXBwaW5ncywgYWN0aXZlQ29sbGVjdGlvbiwgYXJjaGV0eXBlLCBjdXN0b21Qcm9wZXJ0aWVzLFxuICAgIHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzIDogYWxsUHJlZGljYXRlT2JqZWN0TWFwcGluZ3MgfSA9IGFwcFN0YXRlO1xuXG4gIGNvbnN0IHsgdXNlcmRhdGE6IHsgbXlWcmVzIH0sIGRhdGFzZXRzOiB7IHB1YmxpY1ZyZXMgfX0gPSBhcHBTdGF0ZTtcblxuICBjb25zdCBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncyA9IGFsbFByZWRpY2F0ZU9iamVjdE1hcHBpbmdzW2FjdGl2ZUNvbGxlY3Rpb24ubmFtZV0gfHwgW107XG5cbiAgY29uc3QgYXJjaGV0eXBlTmFtZSA9IChtYXBwaW5ncy5jb2xsZWN0aW9uc1thY3RpdmVDb2xsZWN0aW9uLm5hbWVdIHx8IHt9KS5hcmNoZXR5cGVOYW1lO1xuICBjb25zdCBhcmNoZXR5cGVGaWVsZHMgPSBhcmNoZXR5cGVOYW1lICE9PSBudWxsICYmIG1hcHBpbmdzLmNvbGxlY3Rpb25zW2FjdGl2ZUNvbGxlY3Rpb24ubmFtZV0gP1xuICAgIGFyY2hldHlwZVthcmNoZXR5cGVOYW1lXSA6IFtdO1xuXG4gIGNvbnN0IGNvbHVtbkhlYWRlcnMgPSB0cmFuc2Zvcm1Db2xsZWN0aW9uQ29sdW1ucyhjb2xsZWN0aW9ucywgYWN0aXZlQ29sbGVjdGlvbiwgbWFwcGluZ3MsIHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzKTtcblxuICBjb25zdCBjb2xsZWN0aW9uVGFicyA9IHRyYW5zZm9ybUNvbGxlY3Rpb25UYWJzKGNvbGxlY3Rpb25zLCBtYXBwaW5ncywgYWN0aXZlQ29sbGVjdGlvbiwgYWxsUHJlZGljYXRlT2JqZWN0TWFwcGluZ3MpO1xuXG4gIGNvbnN0IGF2YWlsYWJsZUFyY2hldHlwZXMgPSBPYmplY3Qua2V5cyhtYXBwaW5ncy5jb2xsZWN0aW9ucykubWFwKChrZXkpID0+IG1hcHBpbmdzLmNvbGxlY3Rpb25zW2tleV0uYXJjaGV0eXBlTmFtZSk7XG5cbiAgY29uc3QgYXZhaWxhYmxlQ29sbGVjdGlvbkNvbHVtbnNQZXJBcmNoZXR5cGUgPSBhdmFpbGFibGVBcmNoZXR5cGVzLm1hcCgoYXJjaGV0eXBlTmFtZSkgPT4gKHtcbiAgICBrZXk6IGFyY2hldHlwZU5hbWUsXG4gICAgdmFsdWVzOiBPYmplY3Qua2V5cyhtYXBwaW5ncy5jb2xsZWN0aW9ucylcbiAgICAgIC5maWx0ZXIoKGNvbGxlY3Rpb25OYW1lKSA9PiBtYXBwaW5ncy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uTmFtZV0uYXJjaGV0eXBlTmFtZSA9PT0gYXJjaGV0eXBlTmFtZSlcbiAgICAgIC5tYXAoKGNvbGxlY3Rpb25OYW1lKSA9PiAoe1xuICAgICAgICBjb2xsZWN0aW9uTmFtZTogY29sbGVjdGlvbk5hbWUsXG4gICAgICAgIGNvbHVtbnM6IGNvbGxlY3Rpb25zLmZpbmQoKGNvbGwpID0+IGNvbGwubmFtZSA9PT0gY29sbGVjdGlvbk5hbWUpLnZhcmlhYmxlc1xuICAgICAgfSkpXG4gIH0pKS5yZWR1Y2UoKGFjY3VtLCBjdXIpID0+ICh7Li4uYWNjdW0sIFtjdXIua2V5XTogY3VyLnZhbHVlc30pLCB7fSk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBmcm9tIHJvdXRlclxuICAgIHZyZUlkOiByb3V0ZWQucGFyYW1zLnZyZUlkLFxuICAgIC8vIHRyYW5zZm9ybWVkIGZvciB2aWV3XG4gICAgdGFiczogY29sbGVjdGlvblRhYnMsXG5cbiAgICAvLyBtZXNzYWdlc1xuICAgIHNob3dDb2xsZWN0aW9uc0FyZUNvbm5lY3RlZE1lc3NhZ2U6IGFwcFN0YXRlLm1lc3NhZ2VzLnNob3dDb2xsZWN0aW9uc0FyZUNvbm5lY3RlZE1lc3NhZ2UsXG5cbiAgICAvLyBmcm9tIGFjdGl2ZSBjb2xsZWN0aW9uIGZvciB0YWJsZVxuICAgIGFjdGl2ZUNvbGxlY3Rpb246IGFjdGl2ZUNvbGxlY3Rpb24ubmFtZSxcbiAgICBmaXJzdE1hcHBlZENvbGxlY3Rpb246IGFyY2hldHlwZU5hbWUgPT09IG51bGwgJiYgY29sbGVjdGlvblRhYnMubGVuZ3RoID4gMCA/IGNvbGxlY3Rpb25UYWJzWzBdLmNvbGxlY3Rpb25OYW1lIDogbnVsbCxcbiAgICByb3dzOiB0cmFuc2Zvcm1Db2xsZWN0aW9uUm93cyhjb2xsZWN0aW9ucywgYWN0aXZlQ29sbGVjdGlvbiwgbWFwcGluZ3MpLFxuICAgIGhlYWRlcnM6IGNvbHVtbkhlYWRlcnMsXG4gICAgbmV4dFVybDogYWN0aXZlQ29sbGVjdGlvbi5uZXh0VXJsLFxuXG4gICAgLy8gZnJvbSBpbXBvcnQgZGF0YVxuICAgIHVwbG9hZFN0YXR1czogYXBwU3RhdGUuaW1wb3J0RGF0YS51cGxvYWRTdGF0dXMsXG4gICAgdXBsb2FkZWRGaWxlbmFtZTogYXBwU3RhdGUuaW1wb3J0RGF0YS51cGxvYWRlZEZpbGVOYW1lLFxuICAgIHZyZTogYXBwU3RhdGUuaW1wb3J0RGF0YS52cmUsXG5cbiAgICAvLyBmb3JtIGRhdGFcbiAgICBhcmNoZXR5cGVGaWVsZHM6IGFyY2hldHlwZUZpZWxkcyxcbiAgICBhdmFpbGFibGVBcmNoZXR5cGVzOiBhdmFpbGFibGVBcmNoZXR5cGVzLFxuICAgIGF2YWlsYWJsZUNvbGxlY3Rpb25Db2x1bW5zUGVyQXJjaGV0eXBlOiBhdmFpbGFibGVDb2xsZWN0aW9uQ29sdW1uc1BlckFyY2hldHlwZSxcbiAgICBjb2x1bW5zOiBnZXRDb2x1bW5JbmZvKGNvbGxlY3Rpb25zLCBhY3RpdmVDb2xsZWN0aW9uLCBtYXBwaW5ncykuY29sdW1ucyxcbiAgICBwcmVkaWNhdGVPYmplY3RNYXBwaW5nczogcHJlZGljYXRlT2JqZWN0TWFwcGluZ3MsXG4gICAgcHVibGlzaEVycm9yczogYXBwU3RhdGUuaW1wb3J0RGF0YS5wdWJsaXNoRXJyb3JzLFxuICAgIHB1Ymxpc2hFbmFibGVkOiAoIWFwcFN0YXRlLmltcG9ydERhdGEucHVibGlzaGluZyAmJiBteVZyZXNbcm91dGVkLnBhcmFtcy52cmVJZF0ucHVibGlzaFN0YXRlICE9PSBQdWJsaXNoU3RhdGUuTUFQUElOR19FWEVDVVRJT04pICYmIGNvbGxlY3Rpb25UYWJzLmV2ZXJ5KHRhYiA9PiB0YWIuY29tcGxldGUpLFxuICAgIHB1Ymxpc2hTdGF0dXM6IGFwcFN0YXRlLmltcG9ydERhdGEucHVibGlzaFN0YXR1cyA/IGFwcFN0YXRlLmltcG9ydERhdGEucHVibGlzaFN0YXR1cyAgOiAobXlWcmVzW3JvdXRlZC5wYXJhbXMudnJlSWRdLnB1Ymxpc2hTdGF0ZSA9PT0gUHVibGlzaFN0YXRlLk1BUFBJTkdfRVhFQ1VUSU9OID8gXCJQdWJsaXNoaW5nXCIgOiBcIlB1Ymxpc2ggZGF0YXNldFwiKSxcbiAgICBjdXN0b21Qcm9wZXJ0aWVzOiBjdXN0b21Qcm9wZXJ0aWVzW2FjdGl2ZUNvbGxlY3Rpb24ubmFtZV0gfHwgW10sXG4gICAgdGFyZ2V0YWJsZVZyZXM6IGdldFRhcmdldGFibGVWcmVzKG15VnJlcywgcHVibGljVnJlcywgYXBwU3RhdGUuaW1wb3J0RGF0YS52cmUpLFxuICAgIGhhc01hcHBpbmdFcnJvcnM6IG15VnJlc1tyb3V0ZWQucGFyYW1zLnZyZUlkXS5wdWJsaXNoU3RhdGUgPT09IFB1Ymxpc2hTdGF0ZS5NQVBQSU5HX0NSRUFUSU9OX0FGVEVSX0VSUk9SUyxcblxuICAgIC8vIGN0cmwtc2hpZnQtRjRcbiAgICBybWxQcmV2aWV3RGF0YTpcbiAgICAgIGFwcFN0YXRlLnByZXZpZXdSbWwuc2hvd1JNTFByZXZpZXcgP1xuICAgICAgICBnZW5lcmF0ZVJtbE1hcHBpbmcoYXBwU3RhdGUuaW1wb3J0RGF0YS52cmUsIGFwcFN0YXRlLm1hcHBpbmdzLmNvbGxlY3Rpb25zLCBhbGxQcmVkaWNhdGVPYmplY3RNYXBwaW5ncylcbiAgICAgICAgOiBudWxsXG4gIH07XG59IiwiaW1wb3J0IHsgdHJhbnNmb3JtQ29sbGVjdGlvblJvd3MsIHRyYW5zZm9ybUNvbGxlY3Rpb25Db2x1bW5zIH0gZnJvbSBcIi4vdHJhbnNmb3JtZXJzL3RhYmxlXCI7XG5pbXBvcnQgZ2VuZXJhdGVSbWxNYXBwaW5nIGZyb20gXCIuLi91dGlsL2dlbmVyYXRlLXJtbC1tYXBwaW5nXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChhcHBTdGF0ZSwgcm91dGVkKSA9PiB7XG4gIGNvbnN0IHsgaW1wb3J0RGF0YTogeyBjb2xsZWN0aW9ucyB9fSA9IGFwcFN0YXRlO1xuICBjb25zdCB7IGFjdGl2ZUNvbGxlY3Rpb24sIG1hcHBpbmdzIH0gPSBhcHBTdGF0ZTtcblxuICByZXR1cm4ge1xuICAgIHZyZUlkOiByb3V0ZWQucGFyYW1zLnZyZUlkLFxuICAgIGNvbGxlY3Rpb25zOiBhcHBTdGF0ZS5pbXBvcnREYXRhLmNvbGxlY3Rpb25zLFxuICAgIHVwbG9hZGVkRmlsZU5hbWU6IGFwcFN0YXRlLmltcG9ydERhdGEudXBsb2FkZWRGaWxlTmFtZSxcbiAgICBhcmNoZXR5cGU6IGFwcFN0YXRlLmFyY2hldHlwZSxcbiAgICBtYXBwaW5nczogYXBwU3RhdGUubWFwcGluZ3MsXG4gICAgc2hvd0ZpbGVJc1VwbG9hZGVkTWVzc2FnZTogYXBwU3RhdGUubWVzc2FnZXMuc2hvd0ZpbGVJc1VwbG9hZGVkTWVzc2FnZSxcbiAgICB2cmU6IGFwcFN0YXRlLmltcG9ydERhdGEudnJlLFxuXG4gICAgLy8gZnJvbSBhY3RpdmUgY29sbGVjdGlvbiBmb3IgdGFibGVcbiAgICBhY3RpdmVDb2xsZWN0aW9uOiBhY3RpdmVDb2xsZWN0aW9uLm5hbWUsXG4gICAgcm93czogdHJhbnNmb3JtQ29sbGVjdGlvblJvd3MoY29sbGVjdGlvbnMsIGFjdGl2ZUNvbGxlY3Rpb24pLFxuICAgIGhlYWRlcnM6IHRyYW5zZm9ybUNvbGxlY3Rpb25Db2x1bW5zKGNvbGxlY3Rpb25zLCBhY3RpdmVDb2xsZWN0aW9uLCBtYXBwaW5ncyksXG4gICAgbmV4dFVybDogYWN0aXZlQ29sbGVjdGlvbi5uZXh0VXJsLFxuXG4gICAgLy8gY3RybC1zaGlmdC1GNFxuICAgIHJtbFByZXZpZXdEYXRhOlxuICAgICAgYXBwU3RhdGUucHJldmlld1JtbC5zaG93Uk1MUHJldmlldyA/XG4gICAgICAgIGdlbmVyYXRlUm1sTWFwcGluZyhhcHBTdGF0ZS5pbXBvcnREYXRhLnZyZSwgYXBwU3RhdGUubWFwcGluZ3MuY29sbGVjdGlvbnMsIFtdKVxuICAgICAgICA6IG51bGxcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcHBTdGF0ZSwgcm91dGVkKSB7XG4gIGNvbnN0IHZyZUlkID0gcm91dGVkLnBhcmFtcy52cmVJZDtcbiAgY29uc3QgdnJlRGF0YSA9IHZyZUlkID8gKGFwcFN0YXRlLnVzZXJkYXRhLm15VnJlc1t2cmVJZF0gfHwge1xuICAgIHZyZU1ldGFkYXRhOiB7fVxuICB9KSA6IHtcbiAgICB2cmVNZXRhZGF0YToge31cbiAgfTtcbiAgY29uc3QgeyBsYWJlbDogdnJlTGFiZWwsIHZyZU1ldGFkYXRhOiB7IHByb3ZlbmFuY2UsIGNvbG9yQ29kZSwgZGVzY3JpcHRpb24sIGltYWdlLCB1cGxvYWRlZEZpbGVuYW1lIH19ID0gdnJlRGF0YTtcbiAgcmV0dXJuIHtcbiAgICBuZXdWcmVOYW1lOiBhcHBTdGF0ZS5kYXRhc2V0U2V0dGluZ3MubmV3VnJlTmFtZSB8fCB2cmVMYWJlbCxcbiAgICBuZXdEZXNjcmlwdGlvbjogYXBwU3RhdGUuZGF0YXNldFNldHRpbmdzLmRlc2NyaXB0aW9uID09PSBudWxsID8gZGVzY3JpcHRpb24gOiBhcHBTdGF0ZS5kYXRhc2V0U2V0dGluZ3MuZGVzY3JpcHRpb24sXG4gICAgbmV3UHJvdmVuYW5jZTogIGFwcFN0YXRlLmRhdGFzZXRTZXR0aW5ncy5wcm92ZW5hbmNlID09PSBudWxsID8gcHJvdmVuYW5jZSA6IGFwcFN0YXRlLmRhdGFzZXRTZXR0aW5ncy5wcm92ZW5hbmNlLFxuICAgIG5ld0NvbG9yQ29kZTogYXBwU3RhdGUuZGF0YXNldFNldHRpbmdzLmNvbG9yQ29kZSA9PT0gbnVsbCA/IGNvbG9yQ29kZSA6IGFwcFN0YXRlLmRhdGFzZXRTZXR0aW5ncy5jb2xvckNvZGUsXG4gICAgdXBsb2FkU3RhdHVzOiBhcHBTdGF0ZS5pbXBvcnREYXRhLnVwbG9hZFN0YXR1cyxcbiAgICBwdWJsaXNoU3RhdGU6IHZyZURhdGEucHVibGlzaFN0YXRlLFxuICAgIHZyZUlkOiB2cmVJZCxcbiAgICB1cGxvYWRlZEZpbGVOYW1lOiBhcHBTdGF0ZS5pbXBvcnREYXRhLnVwbG9hZGVkRmlsZU5hbWUsXG4gICAgdXBsb2FkZWRGaWxlbmFtZUZyb21WcmU6IHVwbG9hZGVkRmlsZW5hbWUsXG4gICAgaW1hZ2VVcGxvYWRTdGF0dXM6IGFwcFN0YXRlLmRhdGFzZXRTZXR0aW5ncy5pbWFnZVVwbG9hZFN0YXR1cyxcbiAgICBpbWFnZVVwbG9hZEVycm9yTWVzc2FnZTogYXBwU3RhdGUuZGF0YXNldFNldHRpbmdzLmltYWdlVXBsb2FkRXJyb3JNZXNzYWdlLFxuICAgIGltYWdlVXJsOiBpbWFnZVxuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgKHN0YXRlLCByb3V0ZWQpID0+IHtcbiAgY29uc3QgeyBsb2NhdGlvbjogeyBwYXRobmFtZSB9fSA9IHJvdXRlZDtcblxuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lOiBzdGF0ZS51c2VyZGF0YS51c2VySWQsXG4gICAgdnJlczogc3RhdGUuZGF0YXNldHMucHVibGljVnJlcy5maWx0ZXIoKHZyZSkgPT4gdnJlLm5hbWUgIT09IFwiQWRtaW5cIiAmJiB2cmUubmFtZSAhPT0gXCJCYXNlXCIpLFxuICAgIHNlYXJjaEd1aVVybDogc3RhdGUuZGF0YXNldHMuc2VhcmNoR3VpVXJsLFxuICAgIHNob3dEYXRhc2V0czogcGF0aG5hbWUgPT09IFwiL1wiIC8qIHx8IHBhdGhuYW1lID09PSB1cmxzLmNvbGxlY3Rpb25zT3ZlcnZpZXcoKSwqL1xuICB9XG59IiwiaW1wb3J0IHsgcHJvcGVydHlNYXBwaW5nSXNDb21wbGV0ZSB9IGZyb20gXCIuLi8uLi9hY2Nlc3NvcnMvcHJvcGVydHktbWFwcGluZ3NcIlxuaW1wb3J0IHtnZXRDb2x1bW5WYWx1ZX0gZnJvbSBcIi4uLy4uL2FjY2Vzc29ycy9wcm9wZXJ0eS1tYXBwaW5nc1wiO1xuXG5jb25zdCBzaGVldFJvd0Zyb21EaWN0VG9BcnJheSA9IChyb3dkaWN0LCBhcnJheU9mVmFyaWFibGVOYW1lcywgbWFwcGluZ0Vycm9ycykgPT5cbiAgYXJyYXlPZlZhcmlhYmxlTmFtZXMubWFwKG5hbWUgPT4gKHtcbiAgICB2YWx1ZTogcm93ZGljdFtuYW1lXSxcbiAgICBlcnJvcjogbWFwcGluZ0Vycm9yc1tuYW1lXSB8fCBudWxsXG4gIH0pKTtcblxuXG5jb25zdCBnZXRDb2x1bW5JbmZvID0gKGNvbGxlY3Rpb25zLCBhY3RpdmVDb2xsZWN0aW9uLCBtYXBwaW5ncykgPT4ge1xuICBjb25zdCBjb2xsZWN0aW9uSW5mbyA9IChjb2xsZWN0aW9ucyB8fCBbXSkuZmluZCgoY29sbCkgPT4gY29sbC5uYW1lID09PSBhY3RpdmVDb2xsZWN0aW9uLm5hbWUpO1xuICBjb25zdCBjb2x1bW5zID0gY29sbGVjdGlvbkluZm8gPyBjb2xsZWN0aW9uSW5mby52YXJpYWJsZXMgOiBudWxsO1xuXG4gIHJldHVybiB7Y29sdW1uczogY29sdW1uc307XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Db2xsZWN0aW9uUm93cyA9IChjb2xsZWN0aW9ucywgYWN0aXZlQ29sbGVjdGlvbiwgbWFwcGluZ3MpID0+IHtcbiAgY29uc3QgeyBjb2x1bW5zICB9ID0gZ2V0Q29sdW1uSW5mbyhjb2xsZWN0aW9ucywgYWN0aXZlQ29sbGVjdGlvbiwgbWFwcGluZ3MpO1xuICByZXR1cm4gYWN0aXZlQ29sbGVjdGlvbi5uYW1lICYmIGNvbHVtbnNcbiAgICA/IGFjdGl2ZUNvbGxlY3Rpb24ucm93c1xuICAgIC5tYXAoKHJvdykgPT4gc2hlZXRSb3dGcm9tRGljdFRvQXJyYXkocm93LnZhbHVlcywgY29sdW1ucywgcm93LmVycm9ycykpXG4gICAgOiBbXTtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybUNvbGxlY3Rpb25Db2x1bW5zID0gKGNvbGxlY3Rpb25zLCBhY3RpdmVDb2xsZWN0aW9uLCBtYXBwaW5ncywgcHJlZGljYXRlT2JqZWN0TWFwcGluZ3MgPSBbXSkgPT4ge1xuICBjb25zdCB7IGNvbHVtbnN9ID0gZ2V0Q29sdW1uSW5mbyhjb2xsZWN0aW9ucywgYWN0aXZlQ29sbGVjdGlvbiwgbWFwcGluZ3MpO1xuICByZXR1cm4gKGNvbHVtbnMgfHwgW10pLm1hcCgoY29sdW1uLCBpKSA9PiAoe1xuICAgIG5hbWU6IGNvbHVtbixcbiAgICBpc0NvbmZpcm1lZDogcHJvcGVydHlNYXBwaW5nSXNDb21wbGV0ZShwcmVkaWNhdGVPYmplY3RNYXBwaW5ncy5maW5kKChwb20pID0+IGdldENvbHVtblZhbHVlKHBvbSkgPT09IGNvbHVtbikpXG4gIH0pKTtcbn07XG5cbmV4cG9ydCB7XG4gIHRyYW5zZm9ybUNvbGxlY3Rpb25Db2x1bW5zLFxuICB0cmFuc2Zvcm1Db2xsZWN0aW9uUm93cyxcbiAgZ2V0Q29sdW1uSW5mb1xufSIsImltcG9ydCB7cHJvcGVydHlNYXBwaW5nSXNDb21wbGV0ZX0gZnJvbSBcIi4uLy4uL2FjY2Vzc29ycy9wcm9wZXJ0eS1tYXBwaW5nc1wiO1xuaW1wb3J0IHt1bmlxfSBmcm9tIFwiLi4vLi4vdXRpbC91bmlxXCI7XG5pbXBvcnQge2dldENvbHVtblZhbHVlfSBmcm9tIFwiLi4vLi4vYWNjZXNzb3JzL3Byb3BlcnR5LW1hcHBpbmdzXCI7XG5cbmNvbnN0IG1hcHBpbmdzQXJlQ29tcGxldGUgPSAocHJlZGljYXRlT2JqZWN0TWFwcGluZ3MpID0+IHtcbiAgcmV0dXJuIHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzLmxlbmd0aCA+IDAgJiYgcHJlZGljYXRlT2JqZWN0TWFwcGluZ3NcbiAgICAuZmlsdGVyKChwb20pID0+ICFwcm9wZXJ0eU1hcHBpbmdJc0NvbXBsZXRlKHBvbSkpXG4gICAgLmxlbmd0aCA9PT0gMDtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybUNvbGxlY3Rpb25UYWJzID0gKGNvbGxlY3Rpb25zLCBtYXBwaW5ncywgYWN0aXZlQ29sbGVjdGlvbiwgcHJlZGljYXRlT2JqZWN0TWFwcGluZ3MpID0+XG4gIChjb2xsZWN0aW9ucyB8fCBbXSlcbiAgICAuZmlsdGVyKChjb2xsZWN0aW9uKSA9PiB0eXBlb2YgbWFwcGluZ3MuY29sbGVjdGlvbnNbY29sbGVjdGlvbi5uYW1lXSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAuZmlsdGVyKChjb2xsZWN0aW9uKSA9PiBtYXBwaW5ncy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uLm5hbWVdLmFyY2hldHlwZU5hbWUgIT09IG51bGwpXG4gICAgLm1hcCgoY29sbGVjdGlvbikgPT4gKHtcbiAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb2xsZWN0aW9uLm5hbWUsXG4gICAgICBhcmNoZXR5cGVOYW1lOiBtYXBwaW5ncy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uLm5hbWVdLmFyY2hldHlwZU5hbWUsXG4gICAgICBhY3RpdmU6IGFjdGl2ZUNvbGxlY3Rpb24ubmFtZSA9PT0gY29sbGVjdGlvbi5uYW1lLFxuICAgICAgY29tcGxldGU6IG1hcHBpbmdzQXJlQ29tcGxldGUocHJlZGljYXRlT2JqZWN0TWFwcGluZ3NbY29sbGVjdGlvbi5uYW1lXSB8fCBbXSlcbiAgICB9KSk7XG5cbmV4cG9ydCB7IHRyYW5zZm9ybUNvbGxlY3Rpb25UYWJzIH0iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHN0b3JlIGZyb20gXCIuL3N0b3JlXCI7XG5pbXBvcnQgeGhyIGZyb20gXCJ4aHJcIjtcbmltcG9ydCByb3V0ZXIgZnJvbSBcIi4vcm91dGVyXCI7XG5pbXBvcnQgZ2V0VG9rZW4gZnJvbSBcIi4vdG9rZW5cIlxuaW1wb3J0IHtmZXRjaE15VnJlc30gZnJvbSBcIi4vYWN0aW9ucy9mZXRjaC1teS12cmVzXCI7XG5cbmltcG9ydCB4aHJtb2NrIGZyb20gXCJ4aHItbW9ja1wiO1xuaW1wb3J0IHNldHVwTW9ja3MgZnJvbSBcIi4vc2VydmVybW9ja3NcIjtcblxuaWYgKHByb2Nlc3MuZW52LlVTRV9NT0NLID09PSBcInRydWVcIikge1xuICBjb25zb2xlLmxvZyhcIlVzaW5nIG1vY2sgc2VydmVyIVwiKVxuICB2YXIgb3JpZyA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgeGhybW9jay5zZXR1cCgpOyAvL21vY2sgd2luZG93LlhNTEh0dHBSZXF1ZXN0IHVzYWdlc1xuICB2YXIgbW9jayA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgd2luZG93LlhNTEh0dHBSZXF1ZXN0ID0gbW9jaztcbiAgeGhyLlhNTEh0dHBSZXF1ZXN0ID0gbW9jaztcbiAgeGhyLlhEb21haW5SZXF1ZXN0ID0gbW9jaztcbiAgc2V0dXBNb2Nrcyh4aHJtb2NrLCBvcmlnKTtcbn1cblxueGhyLmdldChwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL2phdmFzY3JpcHQtZ2xvYmFsc1wiLCAoZXJyLCByZXMpID0+IHtcbiAgdmFyIGdsb2JhbHMgPSBKU09OLnBhcnNlKHJlcy5ib2R5KTtcbiAgc3RvcmUuZGlzcGF0Y2goe3R5cGU6IFwiU0VUX1NFQVJDSF9VUkxcIiwgZGF0YTogZ2xvYmFscy5lbnYuVElNQlVDVE9PX1NFQVJDSF9VUkx9KTtcbn0pO1xuXG54aHIuZ2V0KHByb2Nlc3MuZW52LnNlcnZlciArIFwiL3YyLjEvc3lzdGVtL3ZyZXNcIiwgKGVyciwgcmVzcCwgYm9keSkgPT4ge1xuICBzdG9yZS5kaXNwYXRjaCh7dHlwZTogXCJTRVRfUFVCTElDX1ZSRVNcIiwgcGF5bG9hZDogSlNPTi5wYXJzZShib2R5KX0pO1xufSk7XG5cbmNvbnN0IGluaXRpYWxSZW5kZXIgPSAoKSA9PiBSZWFjdERPTS5yZW5kZXIocm91dGVyLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFwcFwiKSk7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcblxuICB4aHIocHJvY2Vzcy5lbnYuc2VydmVyICsgXCIvdjIuMS9tZXRhZGF0YS9BZG1pblwiLCAoZXJyLCByZXNwKSA9PiB7XG5cbiAgICBzdG9yZS5kaXNwYXRjaCh7dHlwZTogXCJTRVRfQVJDSEVUWVBFX01FVEFEQVRBXCIsIGRhdGE6IEpTT04ucGFyc2UocmVzcC5ib2R5KX0pO1xuICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKGZldGNoTXlWcmVzKHRva2VuLCAoKSA9PiBpbml0aWFsUmVuZGVyKCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFJlbmRlcigpO1xuICAgIH1cbiAgfSk7XG59KTtcblxubGV0IGNvbWJvTWFwID0ge1xuICBjdHJsOiBmYWxzZSxcbiAgc2hpZnQ6IGZhbHNlLFxuICBmNDogZmFsc2Vcbn07XG5cbmNvbnN0IGtleU1hcCA9IHtcbiAgMTc6IFwiY3RybFwiLFxuICAxNjogXCJzaGlmdFwiLFxuICAxMTU6IFwiZjRcIlxufTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2KSA9PiB7XG4gIGlmIChrZXlNYXBbZXYua2V5Q29kZV0pIHtcbiAgICBjb21ib01hcFtrZXlNYXBbZXYua2V5Q29kZV1dID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhjb21ib01hcCkubWFwKGsgPT4gY29tYm9NYXBba10pLmZpbHRlcihpc1ByZXNzZWQgPT4gaXNQcmVzc2VkKS5sZW5ndGggPT09IDMpIHtcbiAgICBzdG9yZS5kaXNwYXRjaCh7dHlwZTogXCJQUkVWSUVXX1JNTFwifSk7XG4gIH1cblxuICBpZiAoZXYua2V5Q29kZSA9PT0gMjcpIHtcbiAgICBzdG9yZS5kaXNwYXRjaCh7dHlwZTogXCJISURFX1JNTF9QUkVWSUVXXCJ9KTtcbiAgfVxufSk7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAoZXYpID0+IHtcbiAgaWYgKGtleU1hcFtldi5rZXlDb2RlXSkge1xuICAgIGNvbWJvTWFwW2tleU1hcFtldi5rZXlDb2RlXV0gPSBmYWxzZTtcbiAgfVxufSk7IiwiY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBuYW1lOiBudWxsLFxuICBuZXh0VXJsOiBudWxsLFxuICByb3dzOiBbXSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXRlPWluaXRpYWxTdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiRklOSVNIX1VQTE9BRFwiOlxuICAgIGNhc2UgXCJQVUJMSVNIX1NUQVJUXCI6XG4gICAgICByZXR1cm4gey4uLmluaXRpYWxTdGF0ZX07XG4gICAgY2FzZSBcIlJFQ0VJVkVfQUNUSVZFX0NPTExFQ1RJT05cIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBuYW1lOiBhY3Rpb24uZGF0YS5uYW1lLFxuICAgICAgICBuZXh0VXJsOiBhY3Rpb24uZGF0YS5fbmV4dCxcbiAgICAgICAgcm93czogYWN0aW9uLmRhdGEubmFtZSAhPT0gc3RhdGUubmFtZVxuICAgICAgICAgID8gYWN0aW9uLmRhdGEuaXRlbXNcbiAgICAgICAgICA6IHN0YXRlLnJvd3MuY29uY2F0KGFjdGlvbi5kYXRhLml0ZW1zKVxuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn0iLCJjb25zdCBpbml0aWFsU3RhdGUgPSB7fTtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGF0ZT1pbml0aWFsU3RhdGUsIGFjdGlvbikge1xuXHRzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG5cdFx0Y2FzZSBcIlNFVF9BUkNIRVRZUEVfTUVUQURBVEFcIjpcblx0XHRcdHJldHVybiBhY3Rpb24uZGF0YTtcblx0fVxuXG5cdHJldHVybiBzdGF0ZTtcbn0iLCJjb25zdCBpbml0aWFsU3RhdGUgPSB7IH07XG5cbmNvbnN0IGFkZEN1c3RvbVByb3BlcnR5ID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgY29sbGVjdGlvbkN1c3RvbVByb3BlcnRpZXMgPSBzdGF0ZVthY3Rpb24uY29sbGVjdGlvbl0gfHwgW107XG5cbiAgY29uc3QgY3VzdG9tUHJvcGVydHkgPSB7XG4gICAgcHJvcGVydHlUeXBlOiBhY3Rpb24ucHJvcGVydHlUeXBlLFxuICAgIHByb3BlcnR5TmFtZTogYWN0aW9uLnByb3BlcnR5TmFtZSxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIFthY3Rpb24uY29sbGVjdGlvbl06IGNvbGxlY3Rpb25DdXN0b21Qcm9wZXJ0aWVzLmNvbmNhdChjdXN0b21Qcm9wZXJ0eSlcbiAgfTtcbn07XG5cbmNvbnN0IHJlbW92ZUN1c3RvbVByb3BlcnR5ID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgY29sbGVjdGlvbkN1c3RvbVByb3BlcnRpZXMgPSBzdGF0ZVthY3Rpb24uY29sbGVjdGlvbl0gfHwgW107XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBbYWN0aW9uLmNvbGxlY3Rpb25dOiBjb2xsZWN0aW9uQ3VzdG9tUHJvcGVydGllcy5maWx0ZXIoKHByb3AsIGlkeCkgPT4gaWR4ICE9PSBhY3Rpb24uaW5kZXgpXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXRlPWluaXRpYWxTdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiRklOSVNIX1VQTE9BRFwiOlxuICAgIGNhc2UgXCJSRUNFSVZFX01ZX1ZSRVNcIjpcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG4gICAgY2FzZSBcIkFERF9DVVNUT01fUFJPUEVSVFlcIjpcbiAgICAgIHJldHVybiBhZGRDdXN0b21Qcm9wZXJ0eShzdGF0ZSwgYWN0aW9uKTtcbiAgICBjYXNlIFwiUkVNT1ZFX0NVU1RPTV9QUk9QRVJUWVwiOlxuICAgICAgcmV0dXJuIHJlbW92ZUN1c3RvbVByb3BlcnR5KHN0YXRlLCBhY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufSIsImNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgbmV3VnJlTmFtZTogbnVsbCxcbiAgcHJvdmVuYW5jZTogbnVsbCxcbiAgZGVzY3JpcHRpb246IG51bGwsXG4gIGNvbG9yQ29kZTogbnVsbCxcbiAgaW1hZ2VVcGxvYWRTdGF0dXM6IG51bGwsXG4gIGltYWdlVXBsb2FkRXJyb3JNZXNzYWdlOiBudWxsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiQ0xFQVJfREFUQVNFVF9TRVRUSU5HU1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0YXRlXG4gICAgICB9O1xuICAgIGNhc2UgXCJGSU5JU0hfVVBMT0FEXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgbmV3VnJlTmFtZTogbnVsbFxuICAgICAgfTtcbiAgICBjYXNlIFwiU0VUX05FV19WUkVfTkFNRVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIG5ld1ZyZU5hbWU6IGFjdGlvbi5uZXdWcmVOYW1lLmxlbmd0aCA+IDAgPyBhY3Rpb24ubmV3VnJlTmFtZSA6IG51bGxcbiAgICAgIH07XG4gICAgY2FzZSBcIlNFVF9QUk9WRU5BTkNFXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgcHJvdmVuYW5jZTogYWN0aW9uLnByb3ZlbmFuY2VcbiAgICAgIH07XG4gICAgY2FzZSBcIlNFVF9ERVNDUklQVElPTlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBhY3Rpb24uZGVzY3JpcHRpb25cbiAgICAgIH07XG4gICAgY2FzZSBcIlNFVF9DT0xPUl9DT0RFXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgY29sb3JDb2RlOiBhY3Rpb24uY29sb3JDb2RlXG4gICAgICB9O1xuICAgIGNhc2UgXCJJTUFHRV9VUExPQURfU1RBUlRFRFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGltYWdlVXBsb2FkU3RhdHVzOiBcIlVwbG9hZGluZyBpbWFnZS4uLlwiXG4gICAgICB9O1xuICAgIGNhc2UgXCJJTUFHRV9VUExPQURfRVJST1JcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpbWFnZVVwbG9hZEVycm9yTWVzc2FnZTogYWN0aW9uLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgY2FzZSBcIklNQUdFX1VQTE9BRF9TVUNDRVNTXCI6XG4gICAgY2FzZSBcIkRJU01JU1NfSU1BR0VfRVJST1JcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpbWFnZVVwbG9hZEVycm9yTWVzc2FnZTogbnVsbFxuICAgICAgfTtcbiAgICBjYXNlIFwiSU1BR0VfVVBMT0FEX0ZJTklTSEVEXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgaW1hZ2VVcGxvYWRTdGF0dXM6IG51bGxcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn0iLCJjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIHNlYXJjaEd1aVVybDogdW5kZWZpbmVkLFxuICBwdWJsaWNWcmVzOiBbXSxcbiAgdnJlSWRPZkRlbGV0ZVZyZU1vZGFsOiBudWxsXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXRlPWluaXRpYWxTdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiU0VUX1NFQVJDSF9VUkxcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBzZWFyY2hHdWlVcmw6IGFjdGlvbi5kYXRhXG4gICAgICB9O1xuICAgIGNhc2UgXCJTRVRfUFVCTElDX1ZSRVNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBwdWJsaWNWcmVzOiBhY3Rpb24ucGF5bG9hZC5maWx0ZXIoKHZyZSkgPT4gdnJlLmlzUHVibGlzaGVkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiU0hPV19ERUxFVEVfVlJFX01PREFMXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdnJlSWRPZkRlbGV0ZVZyZU1vZGFsOiBhY3Rpb24udnJlSWRcbiAgICAgIH07XG4gICAgY2FzZSBcIkJFRk9SRV9ERUxFVEVfVlJFXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdnJlSWRPZkRlbGV0ZVZyZU1vZGFsOiBudWxsXG4gICAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufSIsImNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgaXNVcGxvYWRpbmc6IGZhbHNlLFxuICBwdWJsaXNoaW5nOiBmYWxzZSxcbiAgcHVibGlzaEVuYWJsZWQ6IHRydWUsXG4gIHB1Ymxpc2hTdGF0dXM6IHVuZGVmaW5lZCxcbiAgcHVibGlzaEVycm9yQ291bnQ6IDAsXG4gIHRyaXBsZUNvdW50OiAwXG59O1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbFN0YXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJTVEFSVF9VUExPQURcIjpcbiAgICAgIHJldHVybiB7Li4uaW5pdGlhbFN0YXRlLCB1cGxvYWRTdGF0dXM6IFwidHJhbnNmZXJpbmcgZmlsZVwiLCB1cGxvYWRlZEZpbGVOYW1lOiBhY3Rpb24udXBsb2FkZWRGaWxlTmFtZX07XG4gICAgY2FzZSBcIlVQTE9BRF9TVEFUVVNfVVBEQVRFXCI6XG4gICAgICBpZiAoYWN0aW9uLmRhdGEpIHtcbiAgICAgICAgdmFyIGZhaWx1cmVzID0gc3RhdGUuZmFpbHVyZXMgfHwgMDtcbiAgICAgICAgdmFyIGN1cnJlbnRTaGVldCA9IHN0YXRlLmN1cnJlbnRTaGVldCB8fCBcIlwiO1xuICAgICAgICB2YXIgcm93cyA9IHN0YXRlLnJvd3MgfHwgMDtcbiAgICAgICAgdmFyIHByZXZSb3dzID0gc3RhdGUucHJldlJvd3MgfHwgMDtcbiAgICAgICAgaWYgKGFjdGlvbi5kYXRhLnN1YnN0cigwLCBcImZhaWx1cmU6IFwiLmxlbmd0aCkgPT09IFwiZmFpbHVyZTogXCIpIHtcbiAgICAgICAgICBmYWlsdXJlcyArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbi5kYXRhLnN1YnN0cigwLCBcInNoZWV0OiBcIi5sZW5ndGgpID09PSBcInNoZWV0OiBcIikge1xuICAgICAgICAgIGN1cnJlbnRTaGVldCA9IGFjdGlvbi5kYXRhLnN1YnN0cihcInNoZWV0OiBcIi5sZW5ndGgpO1xuICAgICAgICAgIHByZXZSb3dzID0gcm93cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3dzID0gYWN0aW9uLmRhdGEqMSAtIHByZXZSb3dzO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cGxvYWRTdGF0dXMgPSBcInByb2Nlc3NpbmcgXCIgKyBjdXJyZW50U2hlZXQgKyBcIiAocm93IFwiICsgcm93cyArIChmYWlsdXJlcyA+IDAgPyBcIiwgXCIgKyBmYWlsdXJlcyArIFwiIGZhaWx1cmVzXCIgOiBcIlwiKSArIFwiKVwiO1xuICAgICAgICByZXR1cm4gey4uLnN0YXRlLFxuICAgICAgICAgIGZhaWx1cmVzLFxuICAgICAgICAgIHJvd3MsXG4gICAgICAgICAgY3VycmVudFNoZWV0LFxuICAgICAgICAgIHVwbG9hZFN0YXR1czogdXBsb2FkU3RhdHVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgY2FzZSBcIkZJTklTSF9VUExPQURcIjpcbiAgICAgIHJldHVybiB7Li4uc3RhdGUsXG4gICAgICAgIHVwbG9hZFN0YXR1czogdW5kZWZpbmVkLFxuICAgICAgICBmYWlsdXJlczogMCxcbiAgICAgICAgY3VycmVudFNoZWV0OiBcIlwiLFxuICAgICAgICByb3dzOiB1bmRlZmluZWQsXG4gICAgICAgIHB1Ymxpc2hFcnJvcnM6IGZhbHNlLFxuICAgICAgICB1cGxvYWRlZEZpbGVOYW1lOiBhY3Rpb24udXBsb2FkZWRGaWxlTmFtZSxcbiAgICAgICAgdnJlOiBhY3Rpb24uZGF0YS52cmUsXG4gICAgICAgIHNhdmVNYXBwaW5nVXJsOiAgYWN0aW9uLmRhdGEuc2F2ZU1hcHBpbmcsXG4gICAgICAgIGV4ZWN1dGVNYXBwaW5nVXJsOiBhY3Rpb24uZGF0YS5leGVjdXRlTWFwcGluZyxcbiAgICAgICAgY29sbGVjdGlvbnM6IGFjdGlvbi5kYXRhLmNvbGxlY3Rpb25zLm1hcCgoY29sKSA9PiAoe1xuICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICBkYXRhVXJsOiBjb2wuZGF0YSxcbiAgICAgICAgICBkYXRhVXJsV2l0aEVycm9yczogY29sLmRhdGFXaXRoRXJyb3JzXG4gICAgICAgIH0pKVxuICAgICAgfTtcblxuICAgIGNhc2UgXCJQVUJMSVNIX1NUQVJUXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgcHVibGlzaGluZzogdHJ1ZVxuICAgICAgfTtcblxuICAgIGNhc2UgXCJQVUJMSVNIX1NUQVRVU19VUERBVEVcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBwdWJsaXNoU3RhdHVzOiBhY3Rpb24uZGF0YVxuICAgICAgfTtcbiAgICBjYXNlIFwiUFVCTElTSF9IQURfRVJST1JcIjpcbiAgICAgIC8vIGNsZWFyIHRoZSBzaGVldHMgdG8gZm9yY2UgcmVsb2FkXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgcHVibGlzaEVycm9yczogdHJ1ZSxcbiAgICAgICAgY29sbGVjdGlvbnM6IHN0YXRlLmNvbGxlY3Rpb25zLm1hcCgoY29sKSA9PiAoe1xuICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICBkYXRhVXJsOiBjb2wuZGF0YSxcbiAgICAgICAgICBkYXRhVXJsV2l0aEVycm9yczogY29sLmRhdGFXaXRoRXJyb3JzXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICBjYXNlIFwiUFVCTElTSF9TVUNDRUVERURcIjpcbiAgICAgIC8vIGNsZWFyIHRoZSBzaGVldHMgdG8gZm9yY2UgcmVsb2FkXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgcHVibGlzaFN0YXR1czogdW5kZWZpbmVkLFxuICAgICAgICBwdWJsaXNoRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgcHVibGlzaEVycm9yczogZmFsc2UsXG4gICAgICAgIGNvbGxlY3Rpb25zOiBzdGF0ZS5jb2xsZWN0aW9ucy5tYXAoKGNvbCkgPT4gKHtcbiAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgZGF0YVVybDogY29sLmRhdGEsXG4gICAgICAgICAgZGF0YVVybFdpdGhFcnJvcnM6IGNvbC5kYXRhV2l0aEVycm9yc1xuICAgICAgICB9KSlcbiAgICAgIH07XG4gICAgY2FzZSBcIlBVQkxJU0hfRklOSVNIRURcIjpcbiAgICAgIC8vIGNsZWFyIHRoZSBzaGVldHMgdG8gZm9yY2UgcmVsb2FkXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgcHVibGlzaFN0YXR1czogdW5kZWZpbmVkLFxuICAgICAgICBwdWJsaXNoRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgcHVibGlzaEVycm9yQ291bnQ6IDAsXG4gICAgICAgIHRyaXBsZUNvdW50OiAwLFxuICAgICAgICBwdWJsaXNoaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7Y29tYmluZVJlZHVjZXJzfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IG1lc3NhZ2VzIGZyb20gXCIuL21lc3NhZ2VzXCI7XG5pbXBvcnQgZGF0YXNldHMgZnJvbSBcIi4vZGF0YXNldHNcIjtcbmltcG9ydCB1c2VyZGF0YSBmcm9tIFwiLi91c2VyZGF0YVwiO1xuaW1wb3J0IGltcG9ydERhdGEgZnJvbSBcIi4vaW1wb3J0LWRhdGFcIjtcbmltcG9ydCBhcmNoZXR5cGUgZnJvbSBcIi4vYXJjaGV0eXBlXCI7XG5pbXBvcnQgbWFwcGluZ3MgZnJvbSBcIi4vbWFwcGluZ3NcIjtcbmltcG9ydCBhY3RpdmVDb2xsZWN0aW9uIGZyb20gXCIuL2FjdGl2ZS1jb2xsZWN0aW9uXCI7XG5pbXBvcnQgcHJlZGljYXRlT2JqZWN0TWFwcGluZ3MgZnJvbSBcIi4vcHJlZGljYXRlLW9iamVjdC1tYXBwaW5nc1wiO1xuaW1wb3J0IGN1c3RvbVByb3BlcnRpZXMgZnJvbSBcIi4vY3VzdG9tLXByb3BlcnRpZXNcIjtcbmltcG9ydCBwcmV2aWV3Um1sIGZyb20gXCIuL3ByZXZpZXctcm1sXCI7XG5pbXBvcnQgZGF0YXNldFNldHRpbmdzIGZyb20gXCIuL2RhdGFzZXQtc2V0dGluZ3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgY29tYmluZVJlZHVjZXJzKHtcbiAgbWVzc2FnZXM6IG1lc3NhZ2VzLFxuICBkYXRhc2V0czogZGF0YXNldHMsXG4gIHVzZXJkYXRhOiB1c2VyZGF0YSxcbiAgaW1wb3J0RGF0YTogaW1wb3J0RGF0YSxcbiAgYXJjaGV0eXBlOiBhcmNoZXR5cGUsXG4gIG1hcHBpbmdzOiBtYXBwaW5ncyxcbiAgYWN0aXZlQ29sbGVjdGlvbjogIGFjdGl2ZUNvbGxlY3Rpb24sXG4gIHByZWRpY2F0ZU9iamVjdE1hcHBpbmdzOiBwcmVkaWNhdGVPYmplY3RNYXBwaW5ncyxcbiAgY3VzdG9tUHJvcGVydGllczogY3VzdG9tUHJvcGVydGllcyxcbiAgcHJldmlld1JtbDogcHJldmlld1JtbCxcbiAgZGF0YXNldFNldHRpbmdzOiBkYXRhc2V0U2V0dGluZ3Ncbn0pO1xuIiwiaW1wb3J0IHNldEluIGZyb20gXCIuLi91dGlsL3NldC1pblwiO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGNvbGxlY3Rpb25zOiB7fSxcbiAgY29uZmlybWVkOiBmYWxzZSxcbiAgcHVibGlzaGluZzogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIHNjYWZmb2xkQ29sbGVjdGlvbk1hcHBpbmdzKGluaXQsIHNoZWV0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGluaXQsIHtcbiAgICBbc2hlZXQubmFtZV06IHtcbiAgICAgIGFyY2hldHlwZU5hbWU6IG51bGxcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBtYXBDb2xsZWN0aW9uQXJjaGV0eXBlID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgbmV3Q29sbGVjdGlvbnMgPSBzZXRJbihbYWN0aW9uLmNvbGxlY3Rpb24sIFwiYXJjaGV0eXBlTmFtZVwiXSwgYWN0aW9uLnZhbHVlLCBzdGF0ZS5jb2xsZWN0aW9ucyk7XG5cbiAgcmV0dXJuIHsuLi5zdGF0ZSwgY29sbGVjdGlvbnM6IG5ld0NvbGxlY3Rpb25zfTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbFN0YXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJTVEFSVF9VUExPQURcIjpcbiAgICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG5cbiAgICBjYXNlIFwiRklOSVNIX1VQTE9BRFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGNvbGxlY3Rpb25zOiBhY3Rpb24uZGF0YS5jb2xsZWN0aW9ucy5yZWR1Y2Uoc2NhZmZvbGRDb2xsZWN0aW9uTWFwcGluZ3MsIHt9KVxuICAgICAgfTtcblxuICAgIGNhc2UgXCJNQVBfQ09MTEVDVElPTl9BUkNIRVRZUEVcIjpcbiAgICAgIHJldHVybiBtYXBDb2xsZWN0aW9uQXJjaGV0eXBlKHN0YXRlLCBhY3Rpb24pO1xuXG4gICAgY2FzZSBcIk1BUF9DT0xMRUNUSU9OX0FSQ0hFVFlQRVNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBjb2xsZWN0aW9uczogYWN0aW9uLmRhdGFcbiAgICAgIH07XG5cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIHNob3dGaWxlSXNVcGxvYWRlZE1lc3NhZ2U6IHRydWUsXG4gIHNob3dDb2xsZWN0aW9uc0FyZUNvbm5lY3RlZE1lc3NhZ2U6IHRydWUsXG4gIHNob3dEZWxldGVWcmVGYWlsZWRNZXNzYWdlOiBmYWxzZVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGF0ZT1pbml0aWFsU3RhdGUsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBcIlRPR0dMRV9NRVNTQUdFXCI6XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHsuLi5zdGF0ZX07XG4gICAgICBuZXdTdGF0ZVthY3Rpb24ubWVzc2FnZUlkXSA9ICFzdGF0ZVthY3Rpb24ubWVzc2FnZUlkXTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICBjYXNlIFwiRklOSVNIX1VQTE9BRFwiOlxuICAgICAgcmV0dXJuIGluaXRpYWxTdGF0ZTtcbiAgICBjYXNlIFwiREVMRVRFX1ZSRV9FUlJPUlwiOlxuICAgICAgY29uc3QgbmV3U3RhdGUxID0gey4uLnN0YXRlfTtcbiAgICAgIG5ld1N0YXRlMS5zaG93RGVsZXRlVnJlRmFpbGVkTWVzc2FnZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV3U3RhdGUxO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufSIsImltcG9ydCB7Z2V0Q29sdW1uVmFsdWV9IGZyb20gXCIuLi9hY2Nlc3NvcnMvcHJvcGVydHktbWFwcGluZ3NcIjtcbmNvbnN0IGluaXRpYWxTdGF0ZSA9IHsgfTtcblxuZnVuY3Rpb24gc2V0QmFzaWNQcmVkaWNhdGVPYmplY3RNYXAoYWN0aW9uLCBjb2xsZWN0aW9uUHJlZGljYXRlT2JqZWN0TWFwcGluZ3MpIHtcbiAgY29uc3QgcHJlZGljYXRlT2JqZWN0TWFwID0ge1xuICAgIHByZWRpY2F0ZTogYWN0aW9uLnByZWRpY2F0ZSxcbiAgICBvYmplY3RNYXA6IHtcbiAgICAgIGNvbHVtbjogYWN0aW9uLm9iamVjdFxuICAgIH0sXG4gICAgcHJvcGVydHlUeXBlOiBhY3Rpb24ucHJvcGVydHlUeXBlXG4gIH07XG5cbiAgcmV0dXJuIGNvbGxlY3Rpb25QcmVkaWNhdGVPYmplY3RNYXBwaW5nc1xuICAgIC5maWx0ZXIoKHByZWRPYmpNYXApID0+IHByZWRPYmpNYXAucHJlZGljYXRlICE9PSBhY3Rpb24ucHJlZGljYXRlKVxuICAgIC5jb25jYXQocHJlZGljYXRlT2JqZWN0TWFwKTtcbn1cblxuXG5mdW5jdGlvbiBzZXRSZWxhdGlvblByZWRpY2F0ZU9iamVjdE1hcChhY3Rpb24sIGNvbGxlY3Rpb25QcmVkaWNhdGVPYmplY3RNYXBwaW5ncykge1xuICBjb25zdCBwcmVkaWNhdGVPYmplY3RNYXAgPSB7XG4gICAgcHJlZGljYXRlOiBhY3Rpb24ucHJlZGljYXRlLFxuICAgIG9iamVjdE1hcDogYWN0aW9uLm9iamVjdCxcbiAgICBwcm9wZXJ0eVR5cGU6IGFjdGlvbi5wcm9wZXJ0eVR5cGUsXG4gICAgZGF0YXNldDogYWN0aW9uLmRhdGFzZXRcbiAgfTtcblxuICByZXR1cm4gY29sbGVjdGlvblByZWRpY2F0ZU9iamVjdE1hcHBpbmdzXG4gICAgLmZpbHRlcigocHJlZE9iak1hcCkgPT4gcHJlZE9iak1hcC5wcmVkaWNhdGUgIT09IGFjdGlvbi5wcmVkaWNhdGUpXG4gICAgLmNvbmNhdChwcmVkaWNhdGVPYmplY3RNYXApO1xufVxuXG5cbmNvbnN0IHNldFByZWRpY2F0ZU9iamVjdE1hcHBpbmcgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCBjb2xsZWN0aW9uUHJlZGljYXRlT2JqZWN0TWFwcGluZ3MgPSBzdGF0ZVthY3Rpb24uc3ViamVjdENvbGxlY3Rpb25dIHx8IFtdO1xuICBjb25zdCBuZXdDb2xsZWN0aW9uUHJlZGljYXRlT2JqZWN0TWFwcGluZ3MgPVxuICAgIGFjdGlvbi5wcm9wZXJ0eVR5cGUgPT09IFwicmVsYXRpb25cIlxuICAgICAgPyBzZXRSZWxhdGlvblByZWRpY2F0ZU9iamVjdE1hcChhY3Rpb24sIGNvbGxlY3Rpb25QcmVkaWNhdGVPYmplY3RNYXBwaW5ncylcbiAgICAgIDogc2V0QmFzaWNQcmVkaWNhdGVPYmplY3RNYXAoYWN0aW9uLCBjb2xsZWN0aW9uUHJlZGljYXRlT2JqZWN0TWFwcGluZ3MpO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgW2FjdGlvbi5zdWJqZWN0Q29sbGVjdGlvbl06IG5ld0NvbGxlY3Rpb25QcmVkaWNhdGVPYmplY3RNYXBwaW5nc1xuICB9O1xufTtcblxuY29uc3QgcmVtb3ZlUHJlZGljYXRlT2JqZWN0TWFwcGluZyA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IGNvbGxlY3Rpb25QcmVkaWNhdGVPYmplY3RNYXBwaW5ncyA9IHN0YXRlW2FjdGlvbi5zdWJqZWN0Q29sbGVjdGlvbl0gfHwgW107XG5cbiAgcmV0dXJuIGFjdGlvbi5wcmVkaWNhdGUgPT09IFwibmFtZXNcIiA/ICB7XG4gICAgLi4uc3RhdGUsXG4gICAgW2FjdGlvbi5zdWJqZWN0Q29sbGVjdGlvbl06IGNvbGxlY3Rpb25QcmVkaWNhdGVPYmplY3RNYXBwaW5nc1xuICAgICAgLmZpbHRlcigocG9tKSA9PiAhKHBvbS5wcm9wZXJ0eVR5cGUgPT09IFwibmFtZXNcIiAmJiBbXCJmb3JlbmFtZVwiLCBcInN1cm5hbWVcIiwgXCJuYW1lTGlua1wiLCBcImdlbk5hbWVcIiwgXCJyb2xlTmFtZVwiXS5pbmRleE9mKHBvbS5wcmVkaWNhdGUpID4gLTEpKVxuICB9IDoge1xuICAgIC4uLnN0YXRlLFxuICAgIFthY3Rpb24uc3ViamVjdENvbGxlY3Rpb25dOiBjb2xsZWN0aW9uUHJlZGljYXRlT2JqZWN0TWFwcGluZ3NcbiAgICAgIC5maWx0ZXIoKHBvbSkgPT4gIShwb20ucHJlZGljYXRlID09PSBhY3Rpb24ucHJlZGljYXRlICYmIGdldENvbHVtblZhbHVlKHBvbSkgPT09IGFjdGlvbi5vYmplY3QpKVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbFN0YXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJGSU5JU0hfVVBMT0FEXCI6XG4gICAgY2FzZSBcIlJFQ0VJVkVfTVlfVlJFU1wiOlxuICAgIGNhc2UgXCJDTEVBUl9QUkVESUNBVEVfT0JKRUNUX01BUFBJTkdTXCI6XG4gICAgICByZXR1cm4gaW5pdGlhbFN0YXRlO1xuICAgIGNhc2UgXCJTRVRfUFJFRElDQVRFX09CSkVDVF9NQVBQSU5HXCI6XG4gICAgICByZXR1cm4gc2V0UHJlZGljYXRlT2JqZWN0TWFwcGluZyhzdGF0ZSwgYWN0aW9uKTtcbiAgICBjYXNlIFwiUkVNT1ZFX1BSRURJQ0FURV9PQkpFQ1RfTUFQUElOR1wiOlxuICAgICAgcmV0dXJuIHJlbW92ZVByZWRpY2F0ZU9iamVjdE1hcHBpbmcoc3RhdGUsIGFjdGlvbik7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59IiwiY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBzaG93Uk1MUHJldmlldzogZmFsc2Vcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbFN0YXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJQUkVWSUVXX1JNTFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHNob3dSTUxQcmV2aWV3OiB0cnVlXG4gICAgICB9O1xuICAgIGNhc2UgXCJISURFX1JNTF9QUkVWSUVXXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgc2hvd1JNTFByZXZpZXc6IGZhbHNlXG4gICAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufSIsImNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgdXNlcklkOiB1bmRlZmluZWQsXG4gIG15VnJlczogdW5kZWZpbmVkLFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGF0ZT1pbml0aWFsU3RhdGUsIGFjdGlvbikge1xuICBsZXQgbmV3TXlWcmVzO1xuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiUkVDRUlWRV9NWV9WUkVTXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgdXNlcklkOiBhY3Rpb24uZGF0YSxcbiAgICAgICAgbXlWcmVzOiBhY3Rpb24udnJlRGF0YSA/IGFjdGlvbi52cmVEYXRhLm1pbmUgOiBudWxsLFxuICAgICAgfTtcbiAgICBjYXNlIFwiQkVGT1JFX0RFTEVURV9WUkVcIjpcbiAgICAgIG5ld015VnJlcyA9IHsuLi5zdGF0ZS5teVZyZXN9O1xuICAgICAgaWYgKG5ld015VnJlc1thY3Rpb24udnJlSWRdKSB7XG4gICAgICAgIG5ld015VnJlc1thY3Rpb24udnJlSWRdLmRlbGV0ZVBlbmRpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIG15VnJlczogbmV3TXlWcmVzXG4gICAgICB9O1xuICAgIGNhc2UgXCJERUxFVEVfVlJFX0VSUk9SXCI6XG4gICAgICBuZXdNeVZyZXMgPSB7Li4uc3RhdGUubXlWcmVzfTtcbiAgICAgIGlmIChuZXdNeVZyZXNbYWN0aW9uLnZyZUlkXSkge1xuICAgICAgICBuZXdNeVZyZXNbYWN0aW9uLnZyZUlkXS5kZWxldGVQZW5kaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgbXlWcmVzOiBuZXdNeVZyZXNcbiAgICAgIH07XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59IiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtSb3V0ZXIsIFJvdXRlLCBJbmRleFJvdXRlLCBoYXNoSGlzdG9yeX0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuaW1wb3J0IHtQcm92aWRlciwgY29ubmVjdH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5pbXBvcnQgc3RvcmUgZnJvbSBcIi4vc3RvcmVcIjtcbmltcG9ydCBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcbmltcG9ydCBnZXRUb2tlbiBmcm9tIFwiLi90b2tlblwiO1xuXG5pbXBvcnQgcGFnZUNvbm5lY3RvciBmcm9tIFwiLi9jb25uZWN0b3JzL3BhZ2UtY29ubmVjdG9yXCI7XG5pbXBvcnQgUGFnZSBmcm9tIFwiLi9jb21wb25lbnRzL3BhZ2UuanN4XCI7XG5cbmltcG9ydCBjb2xsZWN0aW9uT3ZlcnZpZXdDb25uZWN0b3IgZnJvbSBcIi4vY29ubmVjdG9ycy9jb2xsZWN0aW9uLW92ZXJ2aWV3XCI7XG5pbXBvcnQgQ29sbGVjdGlvbk92ZXJ2aWV3IGZyb20gXCIuL2NvbXBvbmVudHMvY29sbGVjdGlvbi1vdmVydmlld1wiO1xuXG5pbXBvcnQgY29ubmVjdEFyY2hldHlwZUNvbm5lY3RvciBmcm9tIFwiLi9jb25uZWN0b3JzL2Nvbm5lY3QtdG8tYXJjaGV0eXBlXCI7XG5pbXBvcnQgQ29ubmVjdFRvQXJjaGV0eXBlIGZyb20gXCIuL2NvbXBvbmVudHMvY29ubmVjdC10by1hcmNoZXR5cGVcIjtcblxuaW1wb3J0IGNvbm5lY3REYXRhQ29ubmVjdG9yIGZyb20gXCIuL2Nvbm5lY3RvcnMvY29ubmVjdC1kYXRhXCI7XG5pbXBvcnQgQ29ubmVjdERhdGEgZnJvbSBcIi4vY29tcG9uZW50cy9jb25uZWN0LWRhdGFcIjtcblxuaW1wb3J0IGRhdGFzZXRTZXR0aW5nc0Nvbm5lY3RvciBmcm9tIFwiLi9jb25uZWN0b3JzL2RhdGFzZXQtc2V0dGluZ3NcIjtcbmltcG9ydCBEYXRhc2V0U2V0dGluZ3MgZnJvbSBcIi4vY29tcG9uZW50cy9kYXRhc2V0LXNldHRpbmdzXCI7XG5cbnZhciB1cmxzID0ge1xuICByb290KCkge1xuICAgIHJldHVybiBcIi9cIjtcbiAgfSxcbiAgbmV3RGF0YXNldCgpIHtcbiAgICByZXR1cm4gXCIvZGF0YXNldC1zZXR0aW5nc1wiO1xuICB9LFxuICBlZGl0RGF0YXNldCh2cmVJZCkge1xuICAgIHJldHVybiB2cmVJZFxuICAgICAgPyBgL2RhdGFzZXQtc2V0dGluZ3MvJHt2cmVJZH1gXG4gICAgICA6IFwiL2RhdGFzZXQtc2V0dGluZ3MvOnZyZUlkXCI7XG4gIH0sXG4gIG1hcERhdGEodnJlSWQpIHtcbiAgICByZXR1cm4gdnJlSWRcbiAgICAgID8gYC9tYXBkYXRhLyR7dnJlSWR9YFxuICAgICAgOiBcIi9tYXBkYXRhLzp2cmVJZFwiO1xuICB9LFxuICBtYXBBcmNoZXR5cGVzKHZyZUlkKSB7XG4gICAgcmV0dXJuIHZyZUlkXG4gICAgICA/IGAvbWFwYXJjaGV0eXBlcy8ke3ZyZUlkfWBcbiAgICAgIDogXCIvbWFwYXJjaGV0eXBlcy86dnJlSWRcIjtcbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5hdmlnYXRlVG8oa2V5LCBhcmdzKSB7XG4gIGhhc2hIaXN0b3J5LnB1c2godXJsc1trZXldLmFwcGx5KG51bGwsIGFyZ3MpKTtcbn1cblxuY29uc3QgZGVmYXVsdENvbm5lY3QgPSBjb25uZWN0KChzdGF0ZSkgPT4gc3RhdGUsIGRpc3BhdGNoID0+IGFjdGlvbnMobmF2aWdhdGVUbywgZGlzcGF0Y2gpKTtcblxuY29uc3QgY29ubmVjdENvbXBvbmVudCA9IChzdGF0ZVRvUHJvcHMpID0+IGNvbm5lY3Qoc3RhdGVUb1Byb3BzLCBkaXNwYXRjaCA9PiBhY3Rpb25zKG5hdmlnYXRlVG8sIGRpc3BhdGNoKSk7XG5cblxuY29uc3QgZmlsdGVyQXV0aG9yaXplZCA9IChyZWRpcmVjdFRvKSA9PiAobmV4dFN0YXRlLCByZXBsYWNlKSA9PiB7XG4gIGlmICghZ2V0VG9rZW4oKSkge1xuICAgIHJlcGxhY2UocmVkaXJlY3RUbyk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChcbiAgPFByb3ZpZGVyIHN0b3JlPXtzdG9yZX0+XG4gICAgPFJvdXRlciBoaXN0b3J5PXtoYXNoSGlzdG9yeX0+XG4gICAgICA8Um91dGUgcGF0aD1cIi9cIiBjb21wb25lbnQ9e2Nvbm5lY3RDb21wb25lbnQocGFnZUNvbm5lY3RvcikoUGFnZSl9PlxuICAgICAgICA8SW5kZXhSb3V0ZSBjb21wb25lbnQ9e2Nvbm5lY3RDb21wb25lbnQoY29sbGVjdGlvbk92ZXJ2aWV3Q29ubmVjdG9yKShDb2xsZWN0aW9uT3ZlcnZpZXcpfSAvPlxuICAgICAgICA8Um91dGUgb25FbnRlcj17ZmlsdGVyQXV0aG9yaXplZChcIi9cIil9XG4gICAgICAgICAgICAgICBwYXRoPXt1cmxzLmVkaXREYXRhc2V0KCl9IGNvbXBvbmVudD17Y29ubmVjdENvbXBvbmVudChkYXRhc2V0U2V0dGluZ3NDb25uZWN0b3IpKERhdGFzZXRTZXR0aW5ncyl9IC8+XG4gICAgICAgIDxSb3V0ZSBvbkVudGVyPXtmaWx0ZXJBdXRob3JpemVkKFwiL1wiKX1cbiAgICAgICAgICAgICAgIHBhdGg9e3VybHMubmV3RGF0YXNldCgpfSBjb21wb25lbnQ9e2Nvbm5lY3RDb21wb25lbnQoZGF0YXNldFNldHRpbmdzQ29ubmVjdG9yKShEYXRhc2V0U2V0dGluZ3MpfSAvPlxuICAgICAgICA8Um91dGUgb25FbnRlcj17ZmlsdGVyQXV0aG9yaXplZChcIi9cIil9XG4gICAgICAgICAgICAgICBwYXRoPXt1cmxzLm1hcEFyY2hldHlwZXMoKX0gY29tcG9uZW50PXtjb25uZWN0Q29tcG9uZW50KGNvbm5lY3RBcmNoZXR5cGVDb25uZWN0b3IpKENvbm5lY3RUb0FyY2hldHlwZSl9IC8+XG4gICAgICAgIDxSb3V0ZSBvbkVudGVyPXtmaWx0ZXJBdXRob3JpemVkKFwiL1wiKX1cbiAgICAgICAgICAgICAgIHBhdGg9e3VybHMubWFwRGF0YSgpfSBjb21wb25lbnQ9e2Nvbm5lY3RDb21wb25lbnQoY29ubmVjdERhdGFDb25uZWN0b3IpKENvbm5lY3REYXRhKX0gLz5cblxuICAgICAgPC9Sb3V0ZT5cbiAgICA8L1JvdXRlcj5cbiAgPC9Qcm92aWRlcj5cbik7XG5cbmV4cG9ydCB7IHVybHMgfTsiLCJpbXBvcnQgUHVibGlzaFN0YXRlIGZyb20gXCIuL3V0aWwvcHVibGlzaC1zdGF0ZVwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwTW9ja3MoeGhybW9jaywgb3JpZykge1xuICB4aHJtb2NrXG4gICAgLmdldChwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL21ldGFkYXRhL0FkbWluXCIsIGZ1bmN0aW9uIChyZXEsIHJlc3ApIHtcbiAgICAgIHJldHVybiByZXNwXG4gICAgICAgIC5zdGF0dXMoMjAwKVxuICAgICAgICAuYm9keShge1xuICAgICAgICAgIFwicGVyc29uc1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5hbWVzXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcIm5hbWVzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFwibmFtZVwiOiBcImJpcnRoRGF0ZVwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJkYXRhYmxlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFwibmFtZVwiOiBcImZsb3J1aXRcIixcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoYXNXcml0dGVuXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInJlbGF0aW9uXCIsXG4gICAgICAgICAgICAgIFwicXVpY2tzZWFyY2hcIjogXCIvdjIuMS9kb21haW4vZG9jdW1lbnRzL2F1dG9jb21wbGV0ZVwiLFxuICAgICAgICAgICAgICBcInJlbGF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcImRpcmVjdGlvblwiOiBcIk9VVFwiLFxuICAgICAgICAgICAgICAgIFwib3V0TmFtZVwiOiBcImhhc1dyaXR0ZW5cIixcbiAgICAgICAgICAgICAgICBcImluTmFtZVwiOiBcIndhc1dyaXR0ZW5CeVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0Q29sbGVjdGlvblwiOiBcImRvY3VtZW50c1wiLFxuICAgICAgICAgICAgICAgIFwicmVsYXRpb25Db2xsZWN0aW9uXCI6IFwicmVsYXRpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJyZWxhdGlvblR5cGVJZFwiOiBcImJiYTEwZDM3LTg2Y2MtNGYxZi1iYTJkLTAxNmFmMmIyMWFhNFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFwibmFtZVwiOiBcImlzUmVsYXRlZFRvXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInJlbGF0aW9uXCIsXG4gICAgICAgICAgICAgIFwicXVpY2tzZWFyY2hcIjogXCIvdjIuMS9kb21haW4vcGVyc29ucy9hdXRvY29tcGxldGVcIixcbiAgICAgICAgICAgICAgXCJyZWxhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJkaXJlY3Rpb25cIjogXCJPVVRcIixcbiAgICAgICAgICAgICAgICBcIm91dE5hbWVcIjogXCJpc1JlbGF0ZWRUb1wiLFxuICAgICAgICAgICAgICAgIFwiaW5OYW1lXCI6IFwiaXNSZWxhdGVkVG9cIixcbiAgICAgICAgICAgICAgICBcInRhcmdldENvbGxlY3Rpb25cIjogXCJwZXJzb25zXCIsXG4gICAgICAgICAgICAgICAgXCJyZWxhdGlvbkNvbGxlY3Rpb25cIjogXCJyZWxhdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcInJlbGF0aW9uVHlwZUlkXCI6IFwiY2JhMTBkMzctODZjYy00ZjFmLWJhMmQtMDE2YWYyYjIxYWE1XCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJkb2N1bWVudHNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0aXRsZVwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1gKTtcbiAgICB9KVxuICAgIC5nZXQocHJvY2Vzcy5lbnYuc2VydmVyICsgXCIvdjIuMS9zeXN0ZW0vdXNlcnMvbWUvdnJlc1wiLCBmdW5jdGlvbihyZXEsIHJlc3ApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZmV0Y2gtbXktdnJlc1wiKTtcbiAgICAgIHJldHVybiByZXNwXG4gICAgICAgIC5zdGF0dXMoMjAwKVxuICAgICAgICAuYm9keShge1xuICAgICAgICAgIFwibWluZVwiOiB7XG4gICAgICAgICAgICBcIm1pZ3JhbnRfc3RlZWtwcm9lZl9tYXN0ZXJkYiAoNikueGxzeFwiOiB7XG4gICAgICAgICAgICAgIFwibmFtZVwiOiBcIm1pZ3JhbnRfc3RlZWtwcm9lZl9tYXN0ZXJkYiAoNikueGxzeFwiLFxuICAgICAgICAgICAgICBcInB1Ymxpc2hlZFwiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0aGV2cmVuYW1lXCI6IHtcbiAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidGhldnJlbmFtZVwiLFxuICAgICAgICAgICAgICBcInB1Ymxpc2hlZFwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgXCJwdWJsaXNoU3RhdGVcIjogXCIke1B1Ymxpc2hTdGF0ZS5NQVBQSU5HX0NSRUFUSU9OfVwiLFxuICAgICAgICAgICAgICBcInJtbFVyaVwiOiBcIjw8VGhlIGdldCByYXcgZGF0YSB1cmwgdGhhdCB0aGUgc2VydmVyIHByb3ZpZGVzPj5cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwdWJsaWNcIjoge1xuICAgICAgICAgICAgXCJXb21lbldyaXRlcnNcIjoge1xuICAgICAgICAgICAgICBcIm5hbWVcIjogXCJXb21lbldyaXRlcnNcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWApO1xuICAgIH0pXG4gICAgLnBvc3QocHJvY2Vzcy5lbnYuc2VydmVyICsgXCIvdjIuMS9idWxrLXVwbG9hZFwiLCBmdW5jdGlvbiAocmVxLCByZXNwKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImJ1bGstdXBsb2FkXCIpO1xuICAgICAgcmV0dXJuIHJlc3BcbiAgICAgICAgLnN0YXR1cygyMDApXG4gICAgICAgIC5oZWFkZXIoXCJMb2NhdGlvblwiLCBwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL2J1bGstdXBsb2FkL3RoZXZyZW5hbWVcIik7XG4gICAgfSlcbiAgICAucG9zdChcIjw8VGhlIGV4ZWN1dGUgbWFwcGluZyB1cmwgdGhhdCB0aGUgc2VydmVyIHByb3ZpZGVzPj5cIiwgZnVuY3Rpb24gKHJlcSwgcmVzcCkge1xuICAgICAgY29uc29sZS5sb2coXCJleGVjdXRlIG1hcHBpbmcgd2l0aCBmYWlsdXJlc1wiLCByZXEuYm9keSgpKTtcbiAgICAgIHJldHVybiByZXNwXG4gICAgICAgIC5zdGF0dXMoMjAwKVxuICAgICAgICAuYm9keShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgIH0pXG4gICAgLnBvc3QoXCI8PFRoZSBzYXZlIG1hcHBpbmcgdXJsIHRoYXQgdGhlIHNlcnZlciBwcm92aWRlcz4+XCIsIGZ1bmN0aW9uIChyZXEsIHJlc3ApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic2F2ZSBtYXBwaW5nXCIsIHJlcS5ib2R5KCkpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzYXZlZC1tYXBwaW5nXCIsIHJlcS5ib2R5KCkpO1xuICAgICAgcmV0dXJuIHJlc3BcbiAgICAgICAgLnN0YXR1cygyMDApXG4gICAgICAgIC5ib2R5KEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICB9KVxuICAgIC5nZXQocHJvY2Vzcy5lbnYuc2VydmVyICsgXCIvdjIuMS9idWxrLXVwbG9hZC90aGV2cmVuYW1lXCIsIGZ1bmN0aW9uIChyZXEsIHJlc3ApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiR2V0IFZSRSBpbmZvcm1hdGlvbiwgc2F2ZWQgbWFwcGluZzogXCIsIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic2F2ZWQtbWFwcGluZ1wiKSk7XG4gICAgICByZXR1cm4gcmVzcFxuICAgICAgICAuc3RhdHVzKDIwMClcbiAgICAgICAgLmJvZHkoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHZyZTogXCJ0aGV2cmVuYW1lXCIsXG4gICAgICAgICAgc2F2ZU1hcHBpbmc6IFwiPDxUaGUgc2F2ZSBtYXBwaW5nIHVybCB0aGF0IHRoZSBzZXJ2ZXIgcHJvdmlkZXM+PlwiLFxuICAgICAgICAgIGV4ZWN1dGVNYXBwaW5nOiBcIjw8VGhlIGV4ZWN1dGUgbWFwcGluZyB1cmwgdGhhdCB0aGUgc2VydmVyIHByb3ZpZGVzPj5cIixcbiAgICAgICAgICBzYXZlZE1hcHBpbmdTdGF0ZTogSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNhdmVkLW1hcHBpbmdcIikgfHwgXCJudWxsXCIpLFxuICAgICAgICAgIGNvbGxlY3Rpb25zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwibW9ja3BlcnNvbnNcIixcbiAgICAgICAgICAgICAgdmFyaWFibGVzOiBbXCJJRFwiLCBcIlZvb3JuYWFtXCIsIFwidHVzc2Vudm9lZ3NlbFwiLCBcIkFjaHRlcm5hYW1cIiwgXCJHZXNjaHJldmVuRG9jdW1lbnRcIiwgXCJHZW5vZW1kIGluXCIsIFwiSXMgZ2V0cm91d2QgbWV0XCJdLFxuICAgICAgICAgICAgICBkYXRhOiBcIjw8dXJsIGZvciBwZXJzb24gZGF0YT4+XCIsXG4gICAgICAgICAgICAgIGRhdGFXaXRoRXJyb3JzOiBcIjw8dXJsIGZvciBwZXJzb24gZGF0YSB3aXRoIGVycm9ycz4+XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwibW9ja2RvY3VtZW50c1wiLFxuICAgICAgICAgICAgICB2YXJpYWJsZXM6IFtcInRpdGVsXCIsIFwiZGF0dW1cIiwgXCJyZWZlcmVudGllXCIsIFwidXJsXCJdLFxuICAgICAgICAgICAgICBkYXRhOiBcIjw8dXJsIGZvciBkb2N1bWVudCBkYXRhPj5cIixcbiAgICAgICAgICAgICAgZGF0YVdpdGhFcnJvcnM6IFwiPDx1cmwgZm9yIGRvY3VtZW50IGRhdGEgd2l0aCBlcnJvcnM+PlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KSk7XG4gICAgfSlcbiAgICAuZGVsZXRlKHByb2Nlc3MuZW52LnNlcnZlciArIFwiL3YyLjEvYnVsay11cGxvYWQvdGhldnJlbmFtZVwiLCBmdW5jdGlvbiAocmVxLCByZXNwKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImRlbGV0ZSB2cmVcIik7XG4gICAgICByZXR1cm4gcmVzcFxuICAgICAgICAuc3RhdHVzKDQwMyk7XG4gICAgfSlcbiAgICAuZ2V0KFwiPDx1cmwgZm9yIHBlcnNvbiBkYXRhPj5cIiwgZnVuY3Rpb24gKHJlcSwgcmVzcCkge1xuICAgICAgY29uc29sZS5sb2coXCJnZXQgcGVyc29uIGl0ZW1zIGRhdGFcIik7XG4gICAgICByZXR1cm4gcmVzcFxuICAgICAgICAuc3RhdHVzKDIwMClcbiAgICAgICAgLmJvZHkoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIFwiX25leHRcIjogXCI8PG1vcmUgZGF0YT4+XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtb2NrcGVyc29uc1wiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwiSURcIjogXCIxXCIsXG4gICAgICAgICAgICAgICAgICBcIlZvb3JuYWFtXCI6IFwiVm9vcm5hYW1cIixcbiAgICAgICAgICAgICAgICAgIFwidHVzc2Vudm9lZ3NlbFwiOiBcInR1c3NlbnZvZWdzZWxcIixcbiAgICAgICAgICAgICAgICAgIFwiQWNodGVybmFhbVwiOiBcIkFjaHRlcm5hYW1cIixcbiAgICAgICAgICAgICAgICAgIFwiR2VzY2hyZXZlbkRvY3VtZW50XCI6IFwiR2VzY2hyZXZlbkRvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgICBcIkdlbm9lbWQgaW5cIjogXCJHZW5vZW1kIGluXCIsXG4gICAgICAgICAgICAgICAgICBcIklzIGdldHJvdXdkIG1ldFwiOiBcIklzIGdldHJvdXdkIG1ldFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3JzOiB7fVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgICBcIklEXCI6IFwiMlwiLFxuICAgICAgICAgICAgICAgICAgXCJWb29ybmFhbVwiOiBcIlZvb3JuYWFtXCIsXG4gICAgICAgICAgICAgICAgICBcInR1c3NlbnZvZWdzZWxcIjogXCJ0dXNzZW52b2Vnc2VsXCIsXG4gICAgICAgICAgICAgICAgICBcIkFjaHRlcm5hYW1cIjogXCJBY2h0ZXJuYWFtXCIsXG4gICAgICAgICAgICAgICAgICBcIkdlc2NocmV2ZW5Eb2N1bWVudFwiOiBcIkdlc2NocmV2ZW5Eb2N1bWVudFwiLFxuICAgICAgICAgICAgICAgICAgXCJHZW5vZW1kIGluXCI6IFwiR2Vub2VtZCBpblwiLFxuICAgICAgICAgICAgICAgICAgXCJJcyBnZXRyb3V3ZCBtZXRcIjogXCJJcyBnZXRyb3V3ZCBtZXRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yczoge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KSk7XG4gICAgfSlcbiAgICAuZ2V0KFwiPDx1cmwgZm9yIHBlcnNvbiBkYXRhPj4/b25seUVycm9ycz10cnVlXCIsIGZ1bmN0aW9uIChyZXEsIHJlc3ApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZ2V0IHBlcnNvbiBpdGVtcyBkYXRhIHdpdGggZXJyb3JzXCIpO1xuICAgICAgcmV0dXJuIHJlc3BcbiAgICAgICAgLnN0YXR1cygyMDApXG4gICAgICAgIC5ib2R5KEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBcIl9uZXh0XCI6IFwiPDxtb3JlIGRhdGE+PlwiLFxuICAgICAgICAgIFwibmFtZVwiOiBcIm1vY2twZXJzb25zXCIsXG4gICAgICAgICAgXCJpdGVtc1wiOiBbe1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIFwiSURcIjogXCIxXCIsXG4gICAgICAgICAgICAgIFwiVm9vcm5hYW1cIjogXCJWb29ybmFhbVwiLFxuICAgICAgICAgICAgICBcInR1c3NlbnZvZWdzZWxcIjogXCJ0dXNzZW52b2Vnc2VsXCIsXG4gICAgICAgICAgICAgIFwiQWNodGVybmFhbVwiOiBcIkFjaHRlcm5hYW1cIixcbiAgICAgICAgICAgICAgXCJHZXNjaHJldmVuRG9jdW1lbnRcIjogXCJHZXNjaHJldmVuRG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgXCJHZW5vZW1kIGluXCI6IFwiR2Vub2VtZCBpblwiLFxuICAgICAgICAgICAgICBcIklzIGdldHJvdXdkIG1ldFwiOiBcIklzIGdldHJvdXdkIG1ldFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgICBcIlZvb3JuYWFtXCI6IFwid2lsbCBub3QgZG9cIixcbiAgICAgICAgICAgICAgXCJBY2h0ZXJuYWFtXCI6IFwiYWxzbyBmYWlsZWRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dXG4gICAgICAgIH0pKTtcbiAgICB9KVxuICAgIC5nZXQoXCI8PG1vcmUgZGF0YT4+XCIsIGZ1bmN0aW9uIChyZXEsIHJlc3ApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZ2V0IHBlcnNvbiBpdGVtcyBkYXRhXCIpO1xuICAgICAgcmV0dXJuIHJlc3BcbiAgICAgICAgLnN0YXR1cygyMDApXG4gICAgICAgIC5ib2R5KEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBcIm5hbWVcIjogXCJtb2NrcGVyc29uc1wiLFxuICAgICAgICAgIFwiaXRlbXNcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBcIklEXCI6IFwiM1wiLFxuICAgICAgICAgICAgICAgIFwiVm9vcm5hYW1cIjogXCJWb29ybmFhbVwiLFxuICAgICAgICAgICAgICAgIFwidHVzc2Vudm9lZ3NlbFwiOiBcInR1c3NlbnZvZWdzZWxcIixcbiAgICAgICAgICAgICAgICBcIkFjaHRlcm5hYW1cIjogXCJBY2h0ZXJuYWFtXCIsXG4gICAgICAgICAgICAgICAgXCJHZXNjaHJldmVuRG9jdW1lbnRcIjogXCJHZXNjaHJldmVuRG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICBcIkdlbm9lbWQgaW5cIjogXCJHZW5vZW1kIGluXCIsXG4gICAgICAgICAgICAgICAgXCJJcyBnZXRyb3V3ZCBtZXRcIjogXCJJcyBnZXRyb3V3ZCBtZXRcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXJyb3JzOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgXCJJRFwiOiBcIjRcIixcbiAgICAgICAgICAgICAgICBcIlZvb3JuYWFtXCI6IFwiVm9vcm5hYW1cIixcbiAgICAgICAgICAgICAgICBcInR1c3NlbnZvZWdzZWxcIjogXCJ0dXNzZW52b2Vnc2VsXCIsXG4gICAgICAgICAgICAgICAgXCJBY2h0ZXJuYWFtXCI6IFwiQWNodGVybmFhbVwiLFxuICAgICAgICAgICAgICAgIFwiR2VzY2hyZXZlbkRvY3VtZW50XCI6IFwiR2VzY2hyZXZlbkRvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJHZW5vZW1kIGluXCI6IFwiR2Vub2VtZCBpblwiLFxuICAgICAgICAgICAgICAgIFwiSXMgZ2V0cm91d2QgbWV0XCI6IFwiSXMgZ2V0cm91d2QgbWV0XCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVycm9yczoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0pKTtcbiAgICB9KVxuICAgIC5nZXQoXCI8PHVybCBmb3IgZG9jdW1lbnQgZGF0YT4+XCIsIGZ1bmN0aW9uIChyZXEsIHJlc3ApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZ2V0IGRvY3VtZW50IGl0ZW1zIGRhdGFcIik7XG4gICAgICByZXR1cm4gcmVzcFxuICAgICAgICAuc3RhdHVzKDIwMClcbiAgICAgICAgLmJvZHkoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibW9ja2RvY3VtZW50c1wiLFxuICAgICAgICAgICAgXCJpdGVtc1wiOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwidGltX2lkXCI6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgXCJ0aXRlbFwiOiBcInRpdGVsXCIsXG4gICAgICAgICAgICAgICAgICBcImRhdHVtXCI6IFwiZGF0dW1cIixcbiAgICAgICAgICAgICAgICAgIFwicmVmZXJlbnRpZVwiOiBcInJlZmVyZW50aWVcIixcbiAgICAgICAgICAgICAgICAgIFwidXJsXCI6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcnM6IHt9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICAgIFwidGltX2lkXCI6IFwiMlwiLFxuICAgICAgICAgICAgICAgICAgXCJ0aXRlbFwiOiBcInRpdGVsXCIsXG4gICAgICAgICAgICAgICAgICBcImRhdHVtXCI6IFwiZGF0dW1cIixcbiAgICAgICAgICAgICAgICAgIFwicmVmZXJlbnRpZVwiOiBcInJlZmVyZW50aWVcIixcbiAgICAgICAgICAgICAgICAgIFwidXJsXCI6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcnM6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSkpO1xuICAgIH0pXG4gICAgLmdldChcIjw8dXJsIGZvciBkb2N1bWVudCBkYXRhPj4/b25seUVycm9ycz10cnVlXCIsIGZ1bmN0aW9uIChyZXEsIHJlc3ApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZ2V0IGRvY3VtZW50IGl0ZW1zIGRhdGEgd2l0aCBlcnJvcnNcIik7XG4gICAgICByZXR1cm4gcmVzcFxuICAgICAgICAuc3RhdHVzKDIwMClcbiAgICAgICAgLmJvZHkoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIFwibmFtZVwiOiBcIm1vY2tkb2N1bWVudHNcIixcbiAgICAgICAgICBcIml0ZW1zXCI6IFtdXG4gICAgICAgIH0pKTtcbiAgICB9KVxuICAgIC5nZXQocHJvY2Vzcy5lbnYuc2VydmVyICsgXCIvdjIuMS9qYXZhc2NyaXB0LWdsb2JhbHNcIiwgZnVuY3Rpb24ocmVxLCByZXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZ2V0IGphdmFzY3JpcHQgZ2xvYmFsc1wiKTtcbiAgICAgIHJldHVybiByZXNcbiAgICAgICAgLnN0YXR1cygyMDApXG4gICAgICAgIC5ib2R5KCd7XCJlbnZcIjp7XCJUSU1CVUNUT09fU0VBUkNIX1VSTFwiOlwiaHR0cDovL2V4YW1wbGUuY29tL1wifX0nKVxuICAgIH0pXG4gICAgLmdldChwcm9jZXNzLmVudi5zZXJ2ZXIgKyBcIi92Mi4xL3N5c3RlbS92cmVzXCIsIGZ1bmN0aW9uKHJlcSwgcmVzKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImdldCBwdWJsaWMgZGF0YXNldHNcIik7XG4gICAgICByZXR1cm4gcmVzXG4gICAgICAgIC5zdGF0dXMoMjAwKVxuICAgICAgICAuYm9keSgnW3tcIm5hbWVcIjpcIkNoYXJ0ZXJQb3J0YWFsXCIsXCJtZXRhZGF0YVwiOlwiaHR0cDovL3Rlc3QucmVwb3NpdG9yeS5odXlnZW5zLmtuYXcubmwvdjIuMS9tZXRhZGF0YS9DaGFydGVyUG9ydGFhbFwifSx7XCJuYW1lXCI6XCJFdXJvcGVzZU1pZ3JhdGllXCIsXCJtZXRhZGF0YVwiOlwiaHR0cDovL3Rlc3QucmVwb3NpdG9yeS5odXlnZW5zLmtuYXcubmwvdjIuMS9tZXRhZGF0YS9FdXJvcGVzZU1pZ3JhdGllXCJ9XScpXG4gICAgfSlcbiAgICAubW9jayhmdW5jdGlvbiAocmVxLCByZXNwKSB7XG4gICAgICBpZiAocmVxLnVybCgpLm1hdGNoKFwiYnJvd3Nlci1zeW5jXCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImJyb3dzZXItc3luYyBkaXNhYmxlZCBpbiBtb2NrIG1vZGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwidW5tb2NrZWQgcmVxdWVzdFwiLCByZXEudXJsKCksIHJlcSwgcmVzcCk7XG4gICAgICB9XG4gICAgfSk7XG59XG4iLCJpbXBvcnQge2NyZWF0ZVN0b3JlLCBhcHBseU1pZGRsZXdhcmV9IGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHRodW5rTWlkZGxld2FyZSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcblxuaW1wb3J0IHJlZHVjZXJzIGZyb20gXCIuL3JlZHVjZXJzXCI7XG5cbmNvbnN0IGxvZ2dlciA9ICgpID0+IG5leHQgPT4gYWN0aW9uID0+IHtcbiAgaWYgKGFjdGlvbi5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpIHtcbiAgICBjb25zb2xlLmxvZyhcIltSRURVWF1cIiwgYWN0aW9uLnR5cGUsIGFjdGlvbik7XG4gIH1cblxuICByZXR1cm4gbmV4dChhY3Rpb24pO1xufTtcblxubGV0IGNyZWF0ZVN0b3JlV2l0aE1pZGRsZXdhcmUgPSBhcHBseU1pZGRsZXdhcmUoLypsb2dnZXIsKi8gdGh1bmtNaWRkbGV3YXJlKShjcmVhdGVTdG9yZSk7XG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdG9yZVdpdGhNaWRkbGV3YXJlKHJlZHVjZXJzKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyKDEpO1xuICBsZXQgcGFyYW1zID0gcGF0aC5zcGxpdCgnJicpO1xuXG4gIGZvcihsZXQgaSBpbiBwYXJhbXMpIHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW1zW2ldLnNwbGl0KCc9Jyk7XG4gICAgaWYoa2V5ID09PSAnaHNpZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJleHBvcnQgZGVmYXVsdCAoY2FtZWxDYXNlKSA9PiBjYW1lbENhc2VcbiAgLnJlcGxhY2UoLyhbQS1aMC05XSkvZywgKG1hdGNoKSA9PiBgICR7bWF0Y2gudG9Mb3dlckNhc2UoKX1gKVxuICAudHJpbSgpXG4gIC5yZXBsYWNlKC9eLi8sIChtYXRjaCkgPT4gbWF0Y2gudG9VcHBlckNhc2UoKSlcbiAgLnJlcGxhY2UoL18vZywgXCIgXCIpO1xuIiwiZnVuY3Rpb24gZGVlcENsb25lOShvYmopIHtcbiAgICB2YXIgaSwgbGVuLCByZXQ7XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgICBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHJldC5wdXNoKCAodHlwZW9mIG9ialtpXSA9PT0gXCJvYmplY3RcIiAmJiBvYmpbaV0gIT09IG51bGwpID8gZGVlcENsb25lOShvYmpbaV0pIDogb2JqW2ldICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIHJldFtpXSA9ICh0eXBlb2Ygb2JqW2ldID09PSBcIm9iamVjdFwiICYmIG9ialtpXSAhPT0gbnVsbCkgPyBkZWVwQ2xvbmU5KG9ialtpXSkgOiBvYmpbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVlcENsb25lOTsiLCJleHBvcnQgZGVmYXVsdCBbXG4gIFwiY2U3MDYwXCIsXG4gIFwiOTJlM2ZjXCIsXG4gIFwiZmFkZThkXCIsXG4gIFwiOWNlNDc5XCIsXG4gIFwiZTM5MDYxXCIsXG4gIFwiZDNiMmQ2XCIsXG4gIFwiOTVjYWM0XCJcbl07IiwiaW1wb3J0IHtpc0Jhc2ljUHJvcGVydHl9IGZyb20gXCIuLi9hY2Nlc3NvcnMvcHJvcGVydHktbWFwcGluZ3NcIjtcblxuY29uc3QgZGVmYXVsdE5hbWVzcGFjZSA9IFwiaHR0cDovL3RpbWJ1Y3Rvby5odXlnZW5zLmtuYXcubmwvXCI7XG5cbmNvbnN0IG5hbWVTcGFjZXMgPSB7XG4gIHN1cm5hbWU6IFwiaHR0cDovL3d3dy50ZWktYy5vcmcvbnMvMS4wL1wiLFxuICBmb3JlbmFtZTogXCJodHRwOi8vd3d3LnRlaS1jLm9yZy9ucy8xLjAvXCIsXG4gIHJvbGVOYW1lOiBcImh0dHA6Ly93d3cudGVpLWMub3JnL25zLzEuMC9cIixcbiAgbmFtZUxpbms6IFwiaHR0cDovL3d3dy50ZWktYy5vcmcvbnMvMS4wL1wiLFxuICBnZW5OYW1lOiBcImh0dHA6Ly93d3cudGVpLWMub3JnL25zLzEuMC9cIixcbiAgc2FtZUFzOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDIvMDcvb3dsI1wiXG59O1xuXG5jb25zdCBybWxUZW1wbGF0ZSA9ICB7XG4gIFwiQGNvbnRleHRcIjoge1xuICAgIFwiQHZvY2FiXCI6IFwiaHR0cDovL3d3dy53My5vcmcvbnMvcjJybWwjXCIsXG4gICAgXCJybWxcIjogXCJodHRwOi8vc2Vtd2ViLm1tbGFiLmJlL25zL3JtbCNcIixcbiAgICBcInRpbVwiOiBcImh0dHA6Ly90aW1idWN0b28uaHV5Z2Vucy5rbmF3Lm5sL21hcHBpbmcjXCIsXG4gICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzAxL3JkZi1zY2hlbWEjc3ViQ2xhc3NPZlwiOiB7XG4gICAgICBcIkB0eXBlXCI6IFwiQGlkXCJcbiAgICB9LFxuICAgICAgXCJwcmVkaWNhdGVcIjoge1xuICAgICAgXCJAdHlwZVwiOiBcIkBpZFwiXG4gICAgfSxcbiAgICAgIFwidGVybVR5cGVcIjoge1xuICAgICAgXCJAdHlwZVwiOiBcIkBpZFwiXG4gICAgfSxcbiAgICAgIFwicGFyZW50VHJpcGxlc01hcFwiOiB7XG4gICAgICBcIkB0eXBlXCI6IFwiQGlkXCJcbiAgICB9LFxuICAgICAgXCJjbGFzc1wiOiB7XG4gICAgICBcIkB0eXBlXCI6IFwiQGlkXCJcbiAgICB9LFxuICAgICAgXCJvYmplY3RcIjoge1xuICAgICAgXCJAdHlwZVwiOiBcIkBpZFwiXG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBnZXROYW1lU3BhY2VGb3IgPSAocHJlZGljYXRlKSA9PlxuICB0eXBlb2YgbmFtZVNwYWNlc1twcmVkaWNhdGVdICA9PT0gXCJ1bmRlZmluZWRcIiA/IGRlZmF1bHROYW1lc3BhY2UgOiBuYW1lU3BhY2VzW3ByZWRpY2F0ZV07XG5cbmNvbnN0IG1ha2VNYXBOYW1lID0gKHZyZSwgbG9jYWxOYW1lKSA9PiBgaHR0cDovL3RpbWJ1Y3Rvby5odXlnZW5zLmtuYXcubmwvbWFwcGluZy8ke3ZyZX0vJHtsb2NhbE5hbWV9YDtcblxuY29uc3QgbWFwQmFzaWNQcm9wZXJ0eSA9IChwcmVkaWNhdGVPYmplY3RNYXApID0+ICh7XG4gIFwib2JqZWN0TWFwXCI6IHtcbiAgICBcImNvbHVtblwiOiBwcmVkaWNhdGVPYmplY3RNYXAub2JqZWN0TWFwLmNvbHVtbixcbiAgICBcInRlcm1UeXBlXCI6IHByZWRpY2F0ZU9iamVjdE1hcC5wcm9wZXJ0eVR5cGUgPT09IFwic2FtZUFzXCIgPyBcImh0dHA6Ly93d3cudzMub3JnL25zL3Iycm1sI0lSSVwiIDogdW5kZWZpbmVkXG4gICAgLy8gXCJkYXRhdHlwZVwiOiBcInZhbGlkIElSSSBzdHJpbmdcIlxuICB9LFxuICBcInByZWRpY2F0ZVwiOiBgJHtnZXROYW1lU3BhY2VGb3IocHJlZGljYXRlT2JqZWN0TWFwLnByZWRpY2F0ZSl9JHtwcmVkaWNhdGVPYmplY3RNYXAucHJlZGljYXRlfWBcbn0pO1xuXG5jb25zdCBtYXBSZWxhdGlvblByb3BlcnR5ID0gKHZyZSwgcHJlZGljYXRlT2JqZWN0TWFwKSA9PiAoe1xuICBcIm9iamVjdE1hcFwiOiB7XG4gICAgXCJqb2luQ29uZGl0aW9uXCI6IHByZWRpY2F0ZU9iamVjdE1hcC5vYmplY3RNYXAuam9pbkNvbmRpdGlvbixcbiAgICBcInBhcmVudFRyaXBsZXNNYXBcIjogYGh0dHA6Ly90aW1idWN0b28uaHV5Z2Vucy5rbmF3Lm5sL21hcHBpbmcvJHt2cmV9LyR7cHJlZGljYXRlT2JqZWN0TWFwLm9iamVjdE1hcC5wYXJlbnRUcmlwbGVzTWFwfWBcbiAgfSxcbiAgXCJwcmVkaWNhdGVcIjogYCR7Z2V0TmFtZVNwYWNlRm9yKHByZWRpY2F0ZU9iamVjdE1hcC5wcmVkaWNhdGUpfSR7cHJlZGljYXRlT2JqZWN0TWFwLnByZWRpY2F0ZX1gXG59KTtcblxuY29uc3QgbWFrZVByZWRpY2F0ZU9iamVjdE1hcCA9ICh2cmUsIHByZWRpY2F0ZU9iamVjdE1hcCkgPT4ge1xuICBpZiAoaXNCYXNpY1Byb3BlcnR5KHByZWRpY2F0ZU9iamVjdE1hcCkpIHtcbiAgICByZXR1cm4gbWFwQmFzaWNQcm9wZXJ0eShwcmVkaWNhdGVPYmplY3RNYXApO1xuICB9XG5cbiAgaWYgKHByZWRpY2F0ZU9iamVjdE1hcC5wcm9wZXJ0eVR5cGUgPT09IFwicmVsYXRpb25cIikge1xuICAgIHJldHVybiBtYXBSZWxhdGlvblByb3BlcnR5KHZyZSwgcHJlZGljYXRlT2JqZWN0TWFwKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgbWFwQ29sbGVjdGlvbiA9ICh2cmUsIGFyY2hldHlwZU5hbWUsIGNvbGxlY3Rpb25OYW1lLCBwcmVkaWNhdGVPYmplY3RNYXBzKSA9PiAoe1xuICBcIkBpZFwiOiBtYWtlTWFwTmFtZSh2cmUsIGNvbGxlY3Rpb25OYW1lKSxcbiAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzAxL3JkZi1zY2hlbWEjc3ViQ2xhc3NPZlwiOiBgaHR0cDovL3RpbWJ1Y3Rvby5odXlnZW5zLmtuYXcubmwvJHthcmNoZXR5cGVOYW1lLnJlcGxhY2UoL3MkLywgXCJcIil9YCxcbiAgXCJybWw6bG9naWNhbFNvdXJjZVwiOiB7XG4gICAgXCJybWw6c291cmNlXCI6IHtcbiAgICAgIFwidGltOnJhd0NvbGxlY3Rpb25cIjogY29sbGVjdGlvbk5hbWUsXG4gICAgICBcInRpbTp2cmVOYW1lXCI6IHZyZVxuICAgIH1cbiAgfSxcbiAgXCJzdWJqZWN0TWFwXCI6IHtcbiAgICBcInRlbXBsYXRlXCI6IGAke21ha2VNYXBOYW1lKHZyZSwgY29sbGVjdGlvbk5hbWUpfS97dGltX2lkfWBcbiAgfSxcbiAgXCJwcmVkaWNhdGVPYmplY3RNYXBcIjogW1xuICAgIHtcIm9iamVjdFwiOiBtYWtlTWFwTmFtZSh2cmUsIGNvbGxlY3Rpb25OYW1lKSwgXCJwcmVkaWNhdGVcIjogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjdHlwZVwifVxuICBdLmNvbmNhdChwcmVkaWNhdGVPYmplY3RNYXBzLm1hcCgocG9tKSA9PiBtYWtlUHJlZGljYXRlT2JqZWN0TWFwKHZyZSwgcG9tKSkuZmlsdGVyKChwb20pID0+IHBvbSAhPT0gbnVsbCkgKVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0ICh2cmUsIGNvbGxlY3Rpb25NYXBwaW5ncywgcHJlZGljYXRlT2JqZWN0TWFwcGluZ3MpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5ybWxUZW1wbGF0ZSxcbiAgICBcIkBncmFwaFwiOiBPYmplY3Qua2V5cyhjb2xsZWN0aW9uTWFwcGluZ3MpXG4gICAgICAuZmlsdGVyKChjb2xsZWN0aW9uTmFtZSkgPT4gY29sbGVjdGlvbk1hcHBpbmdzW2NvbGxlY3Rpb25OYW1lXS5hcmNoZXR5cGVOYW1lICE9PSBudWxsKVxuICAgICAgLm1hcCgoY29sbGVjdGlvbk5hbWUpID0+IG1hcENvbGxlY3Rpb24odnJlLCBjb2xsZWN0aW9uTWFwcGluZ3NbY29sbGVjdGlvbk5hbWVdLmFyY2hldHlwZU5hbWUsIGNvbGxlY3Rpb25OYW1lLCBwcmVkaWNhdGVPYmplY3RNYXBwaW5nc1tjb2xsZWN0aW9uTmFtZV0gfHwgW10pKVxuICB9O1xufVxuXG5leHBvcnQgeyBuYW1lU3BhY2VzLCBkZWZhdWx0TmFtZXNwYWNlIH0iLCJleHBvcnQgZGVmYXVsdCB7XG4gICBVUExPQURJTkc6IFwiVVBMT0FESU5HXCIsXG4gICBNQVBQSU5HX0NSRUFUSU9OOiBcIk1BUFBJTkdfQ1JFQVRJT05cIixcbiAgIE1BUFBJTkdfRVhFQ1VUSU9OOiBcIk1BUFBJTkdfRVhFQ1VUSU9OXCIsXG4gICBNQVBQSU5HX0NSRUFUSU9OX0FGVEVSX0VSUk9SUzogXCJNQVBQSU5HX0NSRUFUSU9OX0FGVEVSX0VSUk9SU1wiLFxuICAgQVZBSUxBQkxFOiBcIkFWQUlMQUJMRVwiXG59IiwiaW1wb3J0IGNsb25lIGZyb20gXCIuL2Nsb25lLWRlZXBcIjtcblxuLy8gRG8gZWl0aGVyIG9mIHRoZXNlOlxuLy8gIGEpIFNldCBhIHZhbHVlIGJ5IHJlZmVyZW5jZSBpZiBkZXJlZiBpcyBub3QgbnVsbFxuLy8gIGIpIFNldCBhIHZhbHVlIGRpcmVjdGx5IGluIHRvIGRhdGEgb2JqZWN0IGlmIGRlcmVmIGlzIG51bGxcbmNvbnN0IHNldEVpdGhlciA9IChkYXRhLCBkZXJlZiwga2V5LCB2YWwpID0+IHtcblx0KGRlcmVmIHx8IGRhdGEpW2tleV0gPSB2YWw7XG5cdHJldHVybiBkYXRhO1xufTtcblxuLy8gU2V0IGEgbmVzdGVkIHZhbHVlIGluIGRhdGEgKG5vdCB1bmxpa2UgaW1tdXRhYmxlanMsIGJ1dCBhIGNsb25lIG9mIGRhdGEgaXMgZXhwZWN0ZWQgZm9yIHByb3BlciBpbW11dGFiaWxpdHkpXG5jb25zdCBfc2V0SW4gPSAocGF0aCwgdmFsdWUsIGRhdGEsIGRlcmVmID0gbnVsbCkgPT5cblx0cGF0aC5sZW5ndGggPiAxID9cblx0XHRfc2V0SW4ocGF0aCwgdmFsdWUsIGRhdGEsIGRlcmVmID8gZGVyZWZbcGF0aC5zaGlmdCgpXSA6IGRhdGFbcGF0aC5zaGlmdCgpXSkgOlxuXHRcdHNldEVpdGhlcihkYXRhLCBkZXJlZiwgcGF0aFswXSwgdmFsdWUpO1xuXG5jb25zdCBzZXRJbiA9IChwYXRoLCB2YWx1ZSwgZGF0YSkgPT5cblx0X3NldEluKGNsb25lKHBhdGgpLCB2YWx1ZSwgY2xvbmUoZGF0YSkpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXRJbjsiLCJjb25zdCB1bmlxID0gKGFjY3VtLCBjdXIpID0+IGFjY3VtLmluZGV4T2YoY3VyKSA8IDAgPyBhY2N1bS5jb25jYXQoY3VyKSA6IGFjY3VtO1xuXG5leHBvcnQgeyB1bmlxIH07Il19
